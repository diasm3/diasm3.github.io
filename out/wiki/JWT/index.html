<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="https://user-images.githubusercontent.com/56494905/158747176-d67b4bc7-b546-442e-bf3c-e80341e07253.png"/><link rel="preload" as="image" href="https://user-images.githubusercontent.com/56494905/158709055-3e610708-2ac6-4d44-82ee-5e0c36dfcaf5.png"/><link rel="preload" as="image" href="https://user-images.githubusercontent.com/56494905/158618931-2a14edd7-00ed-4c2e-82b3-528acb66ef18.png"/><link rel="preload" as="image" href="https://user-images.githubusercontent.com/56494905/158748389-630b2072-c1aa-479e-8d9b-badc5ec9009e.png"/><link rel="preload" as="image" href="https://user-images.githubusercontent.com/56494905/158748708-c0b25f6a-f2fb-4fff-b8df-14bce0da82e2.png"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4d00054ca4698fec.js"/><script src="/_next/static/chunks/1bace94d-b139ae434083d54f.js" async=""></script><script src="/_next/static/chunks/170-01d7f2fd137ced57.js" async=""></script><script src="/_next/static/chunks/main-app-f006bce5492190a9.js" async=""></script><script src="/_next/static/chunks/598-b69b240bf426274b.js" async=""></script><script src="/_next/static/chunks/531-a6f513f60d7f2ed6.js" async=""></script><script src="/_next/static/chunks/app/layout-1a9ce41322de5295.js" async=""></script><script src="/_next/static/chunks/848-a557251920a40253.js" async=""></script><script src="/_next/static/chunks/app/wiki/%5Bslug%5D/page-3bb981cd3ee1ea46.js" async=""></script><title>Your Blog Title</title><meta name="description" content="Your blog description"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.13">*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}/*!sc*/
html{font-size:16px;}/*!sc*/
@media screen and (min-width: 320px){html{font-size:14px;}}/*!sc*/
@media screen and (min-width: 768px){html{font-size:16px;}}/*!sc*/
body{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
button,a{min-height:44px;min-width:44px;}/*!sc*/
input,select,textarea{font-size:16px;}/*!sc*/
data-styled.g1[id="sc-global-eaBKNu1"]{content:"sc-global-eaBKNu1,"}/*!sc*/
.iZiQNx{width:100%;padding:1rem;background:white;box-shadow:0 2px 4px rgba(0,0,0,0.1);}/*!sc*/
@media screen and (min-width: 768px){.iZiQNx{padding:1rem 2rem;}}/*!sc*/
data-styled.g2[id="sc-c74937be-0"]{content:"iZiQNx,"}/*!sc*/
.NHfvt{display:flex;flex-direction:column;gap:1rem;}/*!sc*/
@media screen and (min-width: 768px){.NHfvt{flex-direction:row;gap:2rem;}}/*!sc*/
.NHfvt a{font-size:1rem;color:#495057;text-decoration:none;transition:color 0.2s ease;}/*!sc*/
.NHfvt a:hover{color:#228be6;}/*!sc*/
data-styled.g3[id="sc-c74937be-1"]{content:"NHfvt,"}/*!sc*/
.eqaMzn h3{color:#495057;font-size:1.1rem;margin-bottom:1rem;}/*!sc*/
data-styled.g4[id="sc-fb7cae14-0"]{content:"eqaMzn,"}/*!sc*/
.TDPIL{list-style:none;padding:0;}/*!sc*/
.TDPIL li{margin-bottom:0.5rem;}/*!sc*/
.TDPIL li a{color:#6c757d;text-decoration:none;transition:color 0.2s ease;}/*!sc*/
.TDPIL li a:hover{color:#228be6;}/*!sc*/
data-styled.g5[id="sc-fb7cae14-1"]{content:"TDPIL,"}/*!sc*/
.kZhIA-D{text-align:center;margin-top:2rem;padding-top:1rem;border-top:1px solid #dee2e6;color:#868e96;font-size:0.9rem;}/*!sc*/
data-styled.g6[id="sc-fb7cae14-2"]{content:"kZhIA-D,"}/*!sc*/
.dpWTVH{width:100%;padding:1rem;background-color:#f8f9fa;}/*!sc*/
@media screen and (min-width: 768px){.dpWTVH{padding:2rem;}}/*!sc*/
data-styled.g7[id="sc-fb7cae14-3"]{content:"dpWTVH,"}/*!sc*/
.kLEGFD{display:grid;grid-template-columns:1fr;gap:1.5rem;}/*!sc*/
@media screen and (min-width: 768px){.kLEGFD{grid-template-columns:repeat(2,1fr);}}/*!sc*/
@media screen and (min-width: 1024px){.kLEGFD{grid-template-columns:repeat(3,1fr);max-width:1200px;margin:0 auto;}}/*!sc*/
data-styled.g8[id="sc-fb7cae14-4"]{content:"kLEGFD,"}/*!sc*/
.cVYoEr{padding:1rem;max-width:800px;margin:0 auto;}/*!sc*/
@media screen and (min-width: 768px){.cVYoEr{padding:2rem;}}/*!sc*/
data-styled.g9[id="sc-f070b76b-0"]{content:"cVYoEr,"}/*!sc*/
.gaoDd{margin-bottom:2rem;}/*!sc*/
.gaoDd h1{font-size:2.5rem;margin-bottom:1rem;}/*!sc*/
.gaoDd time{color:#6c757d;font-size:0.9rem;}/*!sc*/
data-styled.g10[id="sc-f070b76b-1"]{content:"gaoDd,"}/*!sc*/
.rqYiW{line-height:1.6;}/*!sc*/
.rqYiW h1,.rqYiW h2,.rqYiW h3,.rqYiW h4,.rqYiW h5,.rqYiW h6{margin:2rem 0 1rem;}/*!sc*/
.rqYiW p{margin:1rem 0;}/*!sc*/
.rqYiW code{background:#f8f9fa;padding:0.2rem 0.4rem;border-radius:4px;}/*!sc*/
.rqYiW pre{background:#f8f9fa;padding:1rem;border-radius:4px;overflow-x:auto;}/*!sc*/
.rqYiW pre code{background:none;padding:0;}/*!sc*/
data-styled.g11[id="sc-f070b76b-2"]{content:"rqYiW,"}/*!sc*/
</style></head><body><div style="min-height:100vh;display:flex;flex-direction:column"><header class="sc-c74937be-0 iZiQNx"><nav class="sc-c74937be-1 NHfvt"><a href="/">Home</a><a href="/wiki/">Wiki</a><a href="/blog/">Blog</a><a href="/search/">Search</a></nav></header><main style="flex:1"><article class="sc-f070b76b-0 cVYoEr"><header class="sc-f070b76b-1 gaoDd"><h1>JWT</h1><time dateTime="2022-03-20 14:45:40 +0900">3/20/2022</time></header><div class="sc-f070b76b-2 rqYiW"><ul>
<li>TOC
{:toc}</li>
</ul>
<h1>JWT(JSON Web Signature)</h1>
<h2>JWT인란?</h2>
<blockquote>
<p><code>JWT</code>는 RFC 7519 웹 표준으로 지정이 되어있다. JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token이라고 정의할 수 있다.</p>
</blockquote>
<h2>JWT 장점</h2>
<p><img src="https://user-images.githubusercontent.com/56494905/158747176-d67b4bc7-b546-442e-bf3c-e80341e07253.png" alt="image"/></p>
<h2>JWT의 구조</h2>
<p><code>JWT는 header + payload + signature 로 조합된 토큰이다.</code></p>
<h3>Header</h3>
<p><code>헤더는 암호화 방식을 선택하고 JWT및 JWE 등 암호화 방식을 선택할 수 있다.</code></p>
<blockquote>
<p><code>header의 인자값</code></p>
<blockquote>
<p><code>alg</code>: algorithm의 줄임말. 알고리즘 선택.<br/>
<!-- -->SHA256 or SHA512 등을 사용</p>
<p><code>typ</code>: type의 줄임말. JWT, JWE등 다른 방식의 토큰을 선택가능.</p>
</blockquote>
</blockquote>
<h3>Payload</h3>
<p><code>페이로드는 실제 데이터가가 들어가는 곳이며 토큰을 받는 사람, 제목, 보내는사람, 만료시간, 활성 날짜, 발급 시간 등을 설정할 수 있다.</code></p>
<blockquote>
<p><code>pay-load 인자값</code></p>
<blockquote>
<p><code>iss</code>: issuer 의 줄임말. 토큰 발급자.</p>
<p><code>sub</code>: subject의 줄임말. 토큰 제목.</p>
<p><code>aud</code>: audience의 줄임말. 토큰 대상자</p>
<p><code>exp</code>: expiration (time) 줄임말. 토큰 만료 시간</p>
<p><code>nbf</code>: from not before (time) 줄임말. 토큰 활성 날짜( 이날짜 이전의 토큰은 활성화되지 않을을 보장)</p>
<p><code>iat</code>: from issued at (time) 줄임말. 토큰 발급 시간.</p>
<p><code>jti</code>: from JWT ID 줄임말. 토큰 식별자(issuer가 여러명일떄 이를 구분하기 위한값)</p>
</blockquote>
</blockquote>
<h3>Signature</h3>
<p><code>시크릿키를 암호화 시키기면서 동시에 header와 payload를 합치고 최종적으로 토큰을 완성시킬 수 있다.</code></p>
<pre><code class="language-javascript">//header 64진수로 변환 
const encodedHeader = base64(utf8(JSON.stringify(header)));

//paylod를 64진수로 변환
const encodedPayload = base64(utf8(JSON.stringify(payload)));

//위 두개를 가지고 hmac 알고리즘으로 주어진 secret 키를 이용해 암호화 후 64진수로 변환
const signature = base64(hmac(`${encodedHeader}.${encodedPayload}`,
secret, sha256));


//마지막으로 다시 header + payload + signature를 합친게 JWT 토큰의 완성이다.
const jwt = `${encodedHeader}.${encodedPayload}.${signature}`;

</code></pre>
<h3>완성된 JWT 토큰</h3>
<blockquote>
<p>아래의 코드가 JWT 토큰으로 변환된 완성 모습이다.</p>
<blockquote>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>Header</code> : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</p>
<p><code>payload</code> : eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.</p>
<p><code>signature</code> :TJVA95OorM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</blockquote>
<ul>
<li>자세히 보면 . 으로 구분되어 있는 부분을 확인 할 수 있는데, 각 header와 payload 그리고 signature의 각 부분을 암호화하여 .으로 구분되어 있다</li>
</ul>
<h3>디코드된 JWT 토큰</h3>
<blockquote>
<p>https://jwt.io 에서 위 완성된 토큰을 다시 디코드를 하면 header와 payload에 관한 내용을 볼 수가 있다.
<img src="https://user-images.githubusercontent.com/56494905/158709055-3e610708-2ac6-4d44-82ee-5e0c36dfcaf5.png" alt="image"/></p>
</blockquote>
<h2>JWT 생성 과정</h2>
<blockquote>
<p><img src="https://user-images.githubusercontent.com/56494905/158618931-2a14edd7-00ed-4c2e-82b3-528acb66ef18.png" alt="image"/></p>
</blockquote>
<h2>JWT 사용목적</h2>
<blockquote>
<ol>
<li>데이터 전송시 보안 목적</li>
<li>권한 인증 목적</li>
<li>stateless</li>
</ol>
<ul>
<li>세션과는 달리 백엔드 서버가 바뀌어도 인증이 가능하다.</li>
</ul>
<ol start="4">
<li>모바일 환경에서 로그인 지속</li>
</ol>
</blockquote>
<h2>토큰을 사용하지 않았을경우 취약점</h2>
<h3>Cross-site Request Forgery(CSRF)</h3>
<blockquote>
<p>CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격이다.</p>
</blockquote>
<h3>Cross-Site Scripting (XSS)</h3>
<blockquote>
<p>악성 스크립트를 통해 사용자의 의도와 상관없는 비 정상적인 동작을 발생시키는 공격<br/>
<!-- -->(예: 쿠키값 노출, 피싱, 악성 코드가 실행 가능한 사이트로 리다이렉트 등)</p>
</blockquote>
<h2>일반적인 Token 인증 방식과 refresh 인증 방식</h2>
<h3>일반적인 token 인증 방식</h3>
<blockquote>
<p><img src="https://user-images.githubusercontent.com/56494905/158748389-630b2072-c1aa-479e-8d9b-badc5ec9009e.png" alt="Screen Shot 2022-03-17 at 1 15 18 PM"/></p>
<ol>
<li>사용자가 로그인한다.</li>
<li>서버에서 계정정보를 읽어 사용자를 확인하여 사용자의 고유한 ID 값을 부여한 뒤 기타 정보와 함께 Payload에 넣는다.</li>
<li>JWT 토큰의 유효기간을 설정한다.</li>
<li>암호화할 Secret Key를 이용해 Access token을 발급한다.</li>
<li>사용자는 Access token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.</li>
</ol>
<ul>
<li>Authorization: Bearer <!-- -->&lt;token&gt;</li>
<li>요청을 보낼 때 JWT 토큰을 Authorization header 필드에 담아보낸다.</li>
</ul>
<ol start="6">
<li>서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작여부/유효기간을 확인한다.</li>
<li>검증이 완료되면 Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.</li>
</ol>
</blockquote>
<h3>refresh token 인증 방식</h3>
<blockquote>
<p><img src="https://user-images.githubusercontent.com/56494905/158748708-c0b25f6a-f2fb-4fff-b8df-14bce0da82e2.png" alt="Screen Shot 2022-03-17 at 1 18 22 PM"/></p>
<ol>
<li>Access Token은 짧은 생명 주기를, Refresh Token은 보다 긴 생명 주기를 갖는다. ( 구체적인 기간은 케이스마다 다르다. )</li>
<li>서버로 요청 시 Access Token을 사용하고 Access Token이 만료되면, Refresh Token을 이용해서 새로운 Access Token을 받아온다.</li>
<li>Refresh Token도 만료된다면 다시 로그인을 해야한다.</li>
<li>Access Token이 탈취당하는 경우, 공격자는 사용자와 동일한 권한을 갖게 된다.
=&gt; JWT를 사용하는 경우 반드시 SSL을 이용한 암호화 통신을 사용해야 한다.</li>
<li>보안이 중요한 서비스의 경우 JWT가 Stateless함에도 불구하고, Redis등에 발급한 Access Token을 보관하기도 한다.(로그아웃 시 Redis에서 삭제)</li>
</ol>
</blockquote>
<h2>토큰처리시 백앤드 or 프론트앤드</h2>
<blockquote>
<p>공식 문서에는 이렇게 나와있다.</p>
<blockquote>
<p>각 어플리케이션 모델에 따라 백엔드 또는 프론트엔드 알아서 처리해라</p>
<p>고려해야 할 부분은 이렇다.</p>
<ol>
<li>JWT 데이터가 너무 큰가?</li>
<li>대역폭에 영향을 끼치는가?</li>
<li>백엔드에서 오는 레이턴시 (반응속도)가 느린가?</li>
<li>자잘한 요청을 한번에 묶어 큰 요청으로 바꿀수 있는가?</li>
<li>토큰 요청이 데이터베이스에 큰영향을 끼치는가?</li>
</ol>
</blockquote>
</blockquote>
<h2>미니 프로젝트에서 사용된 JWT 코드 예제</h2>
<h3>인코드 방법</h3>
<pre><code class="language-python">def api_login():
    pw_hash = hashlib.sha256(pw_receive.encode(&#x27;utf-8&#x27;)).hexdigest()

    payload = {
            &#x27;userid&#x27;: id_receive,
            &#x27;exp&#x27;: datetime.datetime.utcnow() + datetime.timedelta(days=2)
    }
    
    token = jwt.encode(payload, SECRET_KEY, algorithm=&#x27;HS256&#x27;)

</code></pre>
<h3>디코드 방법</h3>
<pre><code class="language-python">def add_comment():

    ##클라이언트 사이트에서 mytoken 이라는 쿠키를 가져온다
    token_receive = request.cookies.get(&#x27;mytoken&#x27;)
    
    ##jwt 함수를 불러와 HS256으로 인코딩된 mytoken 데이터를 payload 함수에 저장한다.
    ##이때 SECRET_KEY는 기존에 인코딩할떄의 SECRET_KEY를 넣어준다.  
    payload = jwt.decode(token_receive, SECRET_KEY, algorithms=[&#x27;HS256&#x27;])
    
    ## 몽고 DB 접속후 payload 안에있는 BODY 내용 중 userid를 확인해서 검색한 값을 userinfo에 넣어준다. 
    userinfo = mongo_connect().user.find_one({&#x27;userid&#x27;: payload[&#x27;userid&#x27;]}, {&#x27;_id&#x27;: 0})
    .....
    
</code></pre>
<h2>용어 모음</h2>
<blockquote>
<p><code>Base64</code></p>
<ul>
<li>64진법 으로 변환 주로 이메일 보낼때 쓴다. 한글이나 특수 문자들이 영향을 끼치지 않는 ASCII코드로 변환시켜 준다.</li>
</ul>
<p><code>utf8</code></p>
<ul>
<li>인코딩된 텍스트를 받고 UTF-8로 구성된 배열을 반환한다.</li>
</ul>
<p><code>sha256</code></p>
<ul>
<li>Secure hash Algorithm 256비트로 구성되어 64자리 문자열을 반환. 2의 256제곱만큼 경우의 수를 만들어 무차별 대입으로 수행시 해시 충돌사례를 찾으려할때 업겁의 시간이 소요 된다. 즉 불가능하다. 배열을 받아 sha-256 알고리즘으로 인코딩된 배열을 반환한다.</li>
</ul>
<p><code>hmac</code></p>
<ul>
<li>hash-based Message Authentication Codes 약자로 주어진 키를 가지고 코드를 생성 해당 코드만이 다시 원복할 수 있다.</li>
</ul>
<p><code>페이로드(Payload)의 뜻</code> :</p>
<ul>
<li>운송업에서 지금(pay) 해야 하는 적화물(load) 즉실 제 가지고 있는 데이터의 내용</li>
</ul>
<p><code>Stateful</code></p>
<ul>
<li>웹서버가 사용자(브라우저)의 상태 client(쿠기) or server(세션) 정보를 기억하고 있다가 유용한 정보로써 활용한다는 의미입니다.</li>
</ul>
<p><code>Stateless</code></p>
<ul>
<li>웹서버 통신(http) 특성상 사용자(브라우저)의 이전 상태 client(쿠키) or server(세션) 정보를 기록하지 않는 접속이란 의미입니다.</li>
</ul>
<p><code>Session</code></p>
<ul>
<li>서버에 저장하는 사용자정보</li>
</ul>
<p><code>cookie</code></p>
<ul>
<li>사용자 컴퓨터에 저장하는 데이터</li>
</ul>
<p><code>RS256</code></p>
<ul>
<li>RS256(RSA signature with SHA-256) 공개키를 사용할때 사용</li>
</ul>
<p><code>HS256</code></p>
<ul>
<li>HS256(HMAC with SHA-256) 비공개키를 사용할때 사용</li>
</ul>
</blockquote>
<h2>참고사이트</h2>
<blockquote>
<p>https://itstory.tk/</p>
<p>https://auth0.com/</p>
<p>https://jwt.io/</p>
<p>https://developer.okta.com/blog/2020/12/21/beginners-guide-to-jwt</p>
<p>https://junshock5.tistory.com/83</p>
<p>https://mokpo.tistory.com/14</p>
<p>https://choppadontbiteme.tistory.com/95</p>
</blockquote></div></article></main><footer class="sc-fb7cae14-3 dpWTVH"><div class="sc-fb7cae14-4 kLEGFD"><div class="sc-fb7cae14-0 eqaMzn"><h3>Navigation</h3><ul class="sc-fb7cae14-1 TDPIL"><li><a href="/">Home</a></li><li><a href="/wiki/">Wiki</a></li><li><a href="/blog/">Blog</a></li><li><a href="/search/">Search</a></li></ul></div><div class="sc-fb7cae14-0 eqaMzn"><h3>Categories</h3><ul class="sc-fb7cae14-1 TDPIL"><li><a href="/wiki/Javascript/">JavaScript</a></li><li><a href="/wiki/Python/">Python</a></li><li><a href="/wiki/Docker/">Docker</a></li><li><a href="/wiki/algorithm/">Algorithms</a></li></ul></div><div class="sc-fb7cae14-0 eqaMzn"><h3>Connect</h3><ul class="sc-fb7cae14-1 TDPIL"><li><a href="https://github.com/your-username" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="https://linkedin.com/in/your-username" target="_blank" rel="noopener noreferrer">LinkedIn</a></li></ul></div></div><div class="sc-fb7cae14-2 kZhIA-D"><p>© <!-- -->2024<!-- --> Your Name. All rights reserved.</p></div></footer></div><script src="/_next/static/chunks/webpack-4d00054ca4698fec.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[4101,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"185\",\"static/chunks/app/layout-1a9ce41322de5295.js\"],\"default\"]\n3:I[3742,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"185\",\"static/chunks/app/layout-1a9ce41322de5295.js\"],\"default\"]\n4:I[7960,[],\"\"]\n5:I[5625,[],\"\"]\n6:I[9946,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"185\",\"static/chunks/app/layout-1a9ce41322de5295.js\"],\"default\"]\n8:I[8165,[],\"OutletBoundary\"]\na:I[8165,[],\"MetadataBoundary\"]\nc:I[8165,[],\"ViewportBoundary\"]\ne:I[810,[],\"\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1gBIa67YwYncMlz2nwFiK\",\"p\":\"\",\"c\":[\"\",\"wiki\",\"JWT\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"wiki\",{\"children\":[[\"slug\",\"JWT\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"JWT\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"div\",null,{\"style\":{\"minHeight\":\"100vh\",\"display\":\"flex\",\"flexDirection\":\"column\"},\"children\":[[\"$\",\"$L3\",null,{}],[\"$\",\"main\",null,{\"style\":{\"flex\":1},\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"h2\",null,{\"children\":\"404 - Page Not Found\"}],[\"$\",\"p\",null,{\"children\":\"The page you are looking for does not exist.\"}]]}],\"notFoundStyles\":[]}]}],[\"$\",\"$L6\",null,{}]]}]}]}]}]]}],{\"children\":[\"wiki\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"wiki\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"JWT\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"wiki\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",null,[\"$\",\"$L8\",null,{\"children\":\"$L9\"}]]}],{},null]},null]},null]},null],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"OhlzHCk1xJBHgSUjTcl2K\",{\"children\":[[\"$\",\"$La\",null,{\"children\":\"$Lb\"}],[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],null]}]]}]]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:I[4023,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"848\",\"static/chunks/848-a557251920a40253.js\",\"607\",\"static/chunks/app/wiki/%5Bslug%5D/page-3bb981cd3ee1ea46.js\"],\"WikiContent\"]\n10:T25aa,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# JWT(JSON Web Signature)\n\n\n## JWT인란?\n\n\u003e `JWT`는 RFC 7519 웹 표준으로 지정이 되어있다. JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token이라고 정의할 수 있다.\n\n## JWT 장점\n\n![image](https://user-images.githubusercontent.com/56494905/158747176-d67b4bc7-b546-442e-bf3c-e80341e07253.png)\n\n\n\n## JWT의 구조\n`JWT는 header + payload + signature 로 조합된 토큰이다.`\n\n### Header\n`헤더는 암호화 방식을 선택하고 JWT및 JWE 등 암호화 방식을 선택할 수 있다.`\n\n\u003e `header의 인자값`\n\u003e\u003e `alg`: algorithm의 줄임말. 알고리즘 선택.  \n\u003e\u003e SHA256 or SHA512 등을 사용 \n\u003e\u003e\n\u003e\u003e `typ`: type의 줄임말. JWT, JWE등 다른 방식의 토큰을 선택가능.\n\n### Payload \n`페이로드는 실제 데이터가가 들어가는 곳이며 토큰을 받는 사람, 제목, 보내는사람, 만료시간, 활성 날짜, 발급 시간 등을 설정할 수 있다.`\n\n\u003e `pay-load 인자값`\n\u003e\u003e `iss`: issuer 의 줄임말. 토큰 발급자. \n\u003e\u003e\n\u003e\u003e `sub`: subject의 줄임말. 토큰 제목.\n\u003e\u003e\n\u003e\u003e `aud`: audience의 줄임말. 토큰 대상자\n\u003e\u003e\n\u003e\u003e `exp`: expiration (time) 줄임말. 토큰 만료 시간\n\u003e\u003e\n\u003e\u003e `nbf`: from not before (time) 줄임말. 토큰 활성 날짜( 이날짜 이전의 토큰은 활성화되지 않을을 보장)\n\u003e\u003e\n\u003e\u003e `iat`: from issued at (time) 줄임말. 토큰 발급 시간. \n\u003e\u003e\n\u003e\u003e `jti`: from JWT ID 줄임말. 토큰 식별자(issuer가 여러명일떄 이를 구분하기 위한값) \n\n\n### Signature\n`시크릿키를 암호화 시키기면서 동시에 header와 payload를 합치고 최종적으로 토큰을 완성시킬 수 있다.`\n\n``` javascript\n//header 64진수로 변환 \nconst encodedHeader = base64(utf8(JSON.stringify(header)));\n\n//paylod를 64진수로 변환\nconst encodedPayload = base64(utf8(JSON.stringify(payload)));\n\n//위 두개를 가지고 hmac 알고리즘으로 주어진 secret 키를 이용해 암호화 후 64진수로 변환\nconst signature = base64(hmac(`${encodedHeader}.${encodedPayload}`,\nsecret, sha256));\n\n\n//마지막으로 다시 header + payload + signature를 합친게 JWT 토큰의 완성이다.\nconst jwt = `${encodedHeader}.${encodedPayload}.${signature}`;\n\n```\n### 완성된 JWT 토큰 \n\u003e 아래의 코드가 JWT 토큰으로 변환된 완성 모습이다.\n\u003e\u003eeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n\u003e\n\u003e `Header` : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\n\u003e\n\u003e `payload` : eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.\n\u003e\n\u003e `signature` :TJVA95OorM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n- 자세히 보면 . 으로 구분되어 있는 부분을 확인 할 수 있는데, 각 header와 payload 그리고 signature의 각 부분을 암호화하여 .으로 구분되어 있다 \n\n\n### 디코드된 JWT 토큰\n\u003ehttps://jwt.io 에서 위 완성된 토큰을 다시 디코드를 하면 header와 payload에 관한 내용을 볼 수가 있다.\n\u003e![image](https://user-images.githubusercontent.com/56494905/158709055-3e610708-2ac6-4d44-82ee-5e0c36dfcaf5.png)\n\n\n\n## JWT 생성 과정\n\u003e![image](https://user-images.githubusercontent.com/56494905/158618931-2a14edd7-00ed-4c2e-82b3-528acb66ef18.png)\n\n\n## JWT 사용목적\n\n\u003e 1. 데이터 전송시 보안 목적\n\u003e 2. 권한 인증 목적 \n\u003e 3. stateless\n\u003e - 세션과는 달리 백엔드 서버가 바뀌어도 인증이 가능하다. \n\u003e 4. 모바일 환경에서 로그인 지속 \n\n\n## 토큰을 사용하지 않았을경우 취약점\n\n### Cross-site Request Forgery(CSRF)\n\u003eCSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격이다.\n\n\n### Cross-Site Scripting (XSS)\n\n\u003e 악성 스크립트를 통해 사용자의 의도와 상관없는 비 정상적인 동작을 발생시키는 공격  \n\u003e  (예: 쿠키값 노출, 피싱, 악성 코드가 실행 가능한 사이트로 리다이렉트 등)\n\n\n## 일반적인 Token 인증 방식과 refresh 인증 방식\n### 일반적인 token 인증 방식\n\u003e![Screen Shot 2022-03-17 at 1 15 18 PM](https://user-images.githubusercontent.com/56494905/158748389-630b2072-c1aa-479e-8d9b-badc5ec9009e.png)\n\u003e1. 사용자가 로그인한다.\n\u003e2. 서버에서 계정정보를 읽어 사용자를 확인하여 사용자의 고유한 ID 값을 부여한 뒤 기타 정보와 함께 Payload에 넣는다.\n\u003e3. JWT 토큰의 유효기간을 설정한다.\n\u003e4. 암호화할 Secret Key를 이용해 Access token을 발급한다.\n\u003e5. 사용자는 Access token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.\n\u003e - Authorization: Bearer \u003ctoken\u003e\n\u003e - 요청을 보낼 때 JWT 토큰을 Authorization header 필드에 담아보낸다.\n\u003e6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작여부/유효기간을 확인한다.\n\u003e7. 검증이 완료되면 Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.\n### refresh token 인증 방식\n\u003e![Screen Shot 2022-03-17 at 1 18 22 PM](https://user-images.githubusercontent.com/56494905/158748708-c0b25f6a-f2fb-4fff-b8df-14bce0da82e2.png)\n\u003e\n\u003e1. Access Token은 짧은 생명 주기를, Refresh Token은 보다 긴 생명 주기를 갖는다. ( 구체적인 기간은 케이스마다 다르다. )\n\u003e2.  서버로 요청 시 Access Token을 사용하고 Access Token이 만료되면, Refresh Token을 이용해서 새로운 Access Token을 받아온다.\n\u003e3. Refresh Token도 만료된다면 다시 로그인을 해야한다.\n\u003e4. Access Token이 탈취당하는 경우, 공격자는 사용자와 동일한 권한을 갖게 된다.\n\u003e=\u003e JWT를 사용하는 경우 반드시 SSL을 이용한 암호화 통신을 사용해야 한다.\n\u003e5. 보안이 중요한 서비스의 경우 JWT가 Stateless함에도 불구하고, Redis등에 발급한 Access Token을 보관하기도 한다.(로그아웃 시 Redis에서 삭제)\n\u003e\n\n## 토큰처리시 백앤드 or 프론트앤드 \n\n\u003e 공식 문서에는 이렇게 나와있다.\n\u003e\u003e 각 어플리케이션 모델에 따라 백엔드 또는 프론트엔드 알아서 처리해라\n\u003e\u003e\n\u003e\u003e 고려해야 할 부분은 이렇다.\n\u003e\u003e 1. JWT 데이터가 너무 큰가?\n\u003e\u003e 2. 대역폭에 영향을 끼치는가?\n\u003e\u003e 3. 백엔드에서 오는 레이턴시 (반응속도)가 느린가?\n\u003e\u003e 4. 자잘한 요청을 한번에 묶어 큰 요청으로 바꿀수 있는가?\n\u003e\u003e 5. 토큰 요청이 데이터베이스에 큰영향을 끼치는가?\n\n\n\n## 미니 프로젝트에서 사용된 JWT 코드 예제\n### 인코드 방법 \n``` python\ndef api_login():\n    pw_hash = hashlib.sha256(pw_receive.encode('utf-8')).hexdigest()\n\n    payload = {\n            'userid': id_receive,\n            'exp': datetime.datetime.utcnow() + datetime.timedelta(days=2)\n    }\n    \n    token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')\n\n```\n\n\n### 디코드 방법 \n```python\ndef add_comment():\n\n    ##클라이언트 사이트에서 mytoken 이라는 쿠키를 가져온다\n    token_receive = request.cookies.get('mytoken')\n    \n    ##jwt 함수를 불러와 HS256으로 인코딩된 mytoken 데이터를 payload 함수에 저장한다.\n    ##이때 SECRET_KEY는 기존에 인코딩할떄의 SECRET_KEY를 넣어준다.  \n    payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\n    \n    ## 몽고 DB 접속후 payload 안에있는 BODY 내용 중 userid를 확인해서 검색한 값을 userinfo에 넣어준다. \n    userinfo = mongo_connect().user.find_one({'userid': payload['userid']}, {'_id': 0})\n    .....\n    \n```\n\n\n## 용어 모음\n\u003e `Base64` \n\u003e - 64진법 으로 변환 주로 이메일 보낼때 쓴다. 한글이나 특수 문자들이 영향을 끼치지 않는 ASCII코드로 변환시켜 준다.\n\u003e\n\u003e `utf8` \n\u003e - 인코딩된 텍스트를 받고 UTF-8로 구성된 배열을 반환한다.\n\u003e\n\u003e `sha256` \n\u003e - Secure hash Algorithm 256비트로 구성되어 64자리 문자열을 반환. 2의 256제곱만큼 경우의 수를 만들어 무차별 대입으로 수행시 해시 충돌사례를 찾으려할때 업겁의 시간이 소요 된다. 즉 불가능하다. 배열을 받아 sha-256 알고리즘으로 인코딩된 배열을 반환한다.\n\u003e\n\u003e `hmac` \n\u003e - hash-based Message Authentication Codes 약자로 주어진 키를 가지고 코드를 생성 해당 코드만이 다시 원복할 수 있다. \n\u003e\n\u003e `페이로드(Payload)의 뜻` :\n\u003e - 운송업에서 지금(pay) 해야 하는 적화물(load) 즉실 제 가지고 있는 데이터의 내용\n\u003e\n\u003e`Stateful`\n\u003e - 웹서버가 사용자(브라우저)의 상태 client(쿠기) or server(세션) 정보를 기억하고 있다가 유용한 정보로써 활용한다는 의미입니다.\n\u003e\n\u003e`Stateless`    \n\u003e - 웹서버 통신(http) 특성상 사용자(브라우저)의 이전 상태 client(쿠키) or server(세션) 정보를 기록하지 않는 접속이란 의미입니다.\n\u003e\n\u003e `Session`\n\u003e - 서버에 저장하는 사용자정보\n\u003e \n\u003e `cookie`\n\u003e - 사용자 컴퓨터에 저장하는 데이터\n\u003e\n\u003e`RS256`\n\u003e - RS256(RSA signature with SHA-256) 공개키를 사용할때 사용 \n\u003e\n\u003e`HS256`\n\u003e - HS256(HMAC with SHA-256) 비공개키를 사용할때 사용\n\n\n## 참고사이트\n\n\u003e\n\u003ehttps://itstory.tk/\n\u003e\n\u003e https://auth0.com/ \n\u003e\n\u003e https://jwt.io/\n\u003e\n\u003e https://developer.okta.com/blog/2020/12/21/beginners-guide-to-jwt\n\u003e\n\u003ehttps://junshock5.tistory.com/83\n\u003e\n\u003ehttps://mokpo.tistory.com/14\n\u003e\n\u003ehttps://choppadontbiteme.tistory.com/95 \n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"$Lf\",null,{\"content\":\"$10\",\"frontMatter\":{\"title\":\"JWT\",\"description\":\"$undefined\",\"tags\":[\"JWT\",\"보안\",\"Authorization\",\"Token\",\"JSON\"],\"date\":\"2022-03-20 14:45:40 +0900\"}}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Your Blog Title\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Your blog description\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script></body></html>