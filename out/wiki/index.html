<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4d00054ca4698fec.js"/><script src="/_next/static/chunks/1bace94d-b139ae434083d54f.js" async=""></script><script src="/_next/static/chunks/170-01d7f2fd137ced57.js" async=""></script><script src="/_next/static/chunks/main-app-f006bce5492190a9.js" async=""></script><script src="/_next/static/chunks/598-b69b240bf426274b.js" async=""></script><script src="/_next/static/chunks/531-a6f513f60d7f2ed6.js" async=""></script><script src="/_next/static/chunks/app/layout-1a9ce41322de5295.js" async=""></script><script src="/_next/static/chunks/app/wiki/page-b15f73fffdd39be9.js" async=""></script><title>Your Blog Title</title><meta name="description" content="Your blog description"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.13">*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}/*!sc*/
html{font-size:16px;}/*!sc*/
@media screen and (min-width: 320px){html{font-size:14px;}}/*!sc*/
@media screen and (min-width: 768px){html{font-size:16px;}}/*!sc*/
body{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
button,a{min-height:44px;min-width:44px;}/*!sc*/
input,select,textarea{font-size:16px;}/*!sc*/
data-styled.g1[id="sc-global-eaBKNu1"]{content:"sc-global-eaBKNu1,"}/*!sc*/
.iZiQNx{width:100%;padding:1rem;background:white;box-shadow:0 2px 4px rgba(0,0,0,0.1);}/*!sc*/
@media screen and (min-width: 768px){.iZiQNx{padding:1rem 2rem;}}/*!sc*/
data-styled.g2[id="sc-c74937be-0"]{content:"iZiQNx,"}/*!sc*/
.NHfvt{display:flex;flex-direction:column;gap:1rem;}/*!sc*/
@media screen and (min-width: 768px){.NHfvt{flex-direction:row;gap:2rem;}}/*!sc*/
.NHfvt a{font-size:1rem;color:#495057;text-decoration:none;transition:color 0.2s ease;}/*!sc*/
.NHfvt a:hover{color:#228be6;}/*!sc*/
data-styled.g3[id="sc-c74937be-1"]{content:"NHfvt,"}/*!sc*/
.eqaMzn h3{color:#495057;font-size:1.1rem;margin-bottom:1rem;}/*!sc*/
data-styled.g4[id="sc-fb7cae14-0"]{content:"eqaMzn,"}/*!sc*/
.TDPIL{list-style:none;padding:0;}/*!sc*/
.TDPIL li{margin-bottom:0.5rem;}/*!sc*/
.TDPIL li a{color:#6c757d;text-decoration:none;transition:color 0.2s ease;}/*!sc*/
.TDPIL li a:hover{color:#228be6;}/*!sc*/
data-styled.g5[id="sc-fb7cae14-1"]{content:"TDPIL,"}/*!sc*/
.kZhIA-D{text-align:center;margin-top:2rem;padding-top:1rem;border-top:1px solid #dee2e6;color:#868e96;font-size:0.9rem;}/*!sc*/
data-styled.g6[id="sc-fb7cae14-2"]{content:"kZhIA-D,"}/*!sc*/
.dpWTVH{width:100%;padding:1rem;background-color:#f8f9fa;}/*!sc*/
@media screen and (min-width: 768px){.dpWTVH{padding:2rem;}}/*!sc*/
data-styled.g7[id="sc-fb7cae14-3"]{content:"dpWTVH,"}/*!sc*/
.kLEGFD{display:grid;grid-template-columns:1fr;gap:1.5rem;}/*!sc*/
@media screen and (min-width: 768px){.kLEGFD{grid-template-columns:repeat(2,1fr);}}/*!sc*/
@media screen and (min-width: 1024px){.kLEGFD{grid-template-columns:repeat(3,1fr);max-width:1200px;margin:0 auto;}}/*!sc*/
data-styled.g8[id="sc-fb7cae14-4"]{content:"kLEGFD,"}/*!sc*/
.dpwKEb{margin-bottom:2rem;}/*!sc*/
.dpwKEb h1{font-size:2rem;margin-bottom:1rem;}/*!sc*/
.dpwKEb p{color:#6c757d;}/*!sc*/
data-styled.g12[id="sc-debf4691-0"]{content:"dpwKEb,"}/*!sc*/
.bpoEYk{display:grid;grid-template-columns:1fr;gap:1rem;}/*!sc*/
@media screen and (min-width: 768px){.bpoEYk{grid-template-columns:repeat(2,1fr);}}/*!sc*/
@media screen and (min-width: 1024px){.bpoEYk{grid-template-columns:repeat(3,1fr);}}/*!sc*/
data-styled.g13[id="sc-debf4691-1"]{content:"bpoEYk,"}/*!sc*/
.bovukn{padding:1rem;max-width:1200px;margin:0 auto;}/*!sc*/
@media screen and (min-width: 768px){.bovukn{padding:2rem;}}/*!sc*/
data-styled.g15[id="sc-debf4691-3"]{content:"bovukn,"}/*!sc*/
.sGDew{height:10px;margin:2rem 0;}/*!sc*/
data-styled.g21[id="sc-debf4691-9"]{content:"sGDew,"}/*!sc*/
</style></head><body><div style="min-height:100vh;display:flex;flex-direction:column"><header class="sc-c74937be-0 iZiQNx"><nav class="sc-c74937be-1 NHfvt"><a href="/">Home</a><a href="/wiki/">Wiki</a><a href="/blog/">Blog</a><a href="/search/">Search</a></nav></header><main style="flex:1"><div class="sc-debf4691-3 bovukn"><div class="sc-debf4691-0 dpwKEb"><h1>Wiki</h1><p>Total <!-- -->143<!-- --> articles</p></div><div class="sc-debf4691-1 bpoEYk"></div><div class="sc-debf4691-9 sGDew"></div></div></main><footer class="sc-fb7cae14-3 dpWTVH"><div class="sc-fb7cae14-4 kLEGFD"><div class="sc-fb7cae14-0 eqaMzn"><h3>Navigation</h3><ul class="sc-fb7cae14-1 TDPIL"><li><a href="/">Home</a></li><li><a href="/wiki/">Wiki</a></li><li><a href="/blog/">Blog</a></li><li><a href="/search/">Search</a></li></ul></div><div class="sc-fb7cae14-0 eqaMzn"><h3>Categories</h3><ul class="sc-fb7cae14-1 TDPIL"><li><a href="/wiki/Javascript/">JavaScript</a></li><li><a href="/wiki/Python/">Python</a></li><li><a href="/wiki/Docker/">Docker</a></li><li><a href="/wiki/algorithm/">Algorithms</a></li></ul></div><div class="sc-fb7cae14-0 eqaMzn"><h3>Connect</h3><ul class="sc-fb7cae14-1 TDPIL"><li><a href="https://github.com/your-username" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="https://linkedin.com/in/your-username" target="_blank" rel="noopener noreferrer">LinkedIn</a></li></ul></div></div><div class="sc-fb7cae14-2 kZhIA-D"><p>© <!-- -->2024<!-- --> Your Name. All rights reserved.</p></div></footer></div><script src="/_next/static/chunks/webpack-4d00054ca4698fec.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[4101,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"185\",\"static/chunks/app/layout-1a9ce41322de5295.js\"],\"default\"]\n3:I[3742,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"185\",\"static/chunks/app/layout-1a9ce41322de5295.js\"],\"default\"]\n4:I[7960,[],\"\"]\n5:I[5625,[],\"\"]\n6:I[9946,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"185\",\"static/chunks/app/layout-1a9ce41322de5295.js\"],\"default\"]\n7:I[4763,[\"598\",\"static/chunks/598-b69b240bf426274b.js\",\"531\",\"static/chunks/531-a6f513f60d7f2ed6.js\",\"124\",\"static/chunks/app/wiki/page-b15f73fffdd39be9.js\"],\"WikiList\"]\n30:I[8165,[],\"OutletBoundary\"]\n32:I[8165,[],\"MetadataBoundary\"]\n34:I[8165,[],\"ViewportBoundary\"]\n36:I[810,[],\"\"]\n8:Ta8b0,"])</script><script>self.__next_f.push([1,"* [[TOC]]\n{:toc}\n\n## 2022-12-19 09:30:11\n### 첫번째 프로젝트를 마치고 나서...\n첫 직장에서 첫 플젝을 끝나고 나서 따로 회고를 적지를 않았다.\n간단히 생각 나는 것들을 적어봤다.\n\n플젝을 하면서 느낀점\n- 불정확한 지식으로 인해 숨겨진 오류\n- 겹겹이 쌓인 오류산\n- 환경변수를 넣지 않아 생기 오류는 찾기가 힘들다\n- set-cookie 할때 동일 도메인 레벨에서만 저장이 가능하다.\n- email template은 직접 다 해줘야한다.\n- raw query로 코딩을 했을때 확실히 더 알게되었다. \n- Sequelize와 같은 결과값을 가져오지만 실제로는 raw query로 최소한의 transaction으로 자유롭게 DB를 다룰수 있다.\n- 에러 메세지를 주의 깊게 보자\n- ElasticBeanstalk는 정말 짜증난다.\n- ElasticBeanstalk 셋팅시 Docker build를 docker hub으로 사용해야 초기 빌드시 힙 메모리가 모자라 서버가 다운되지 않는다.\n- 백엔드는 node 버전에 따라 크게 성능의 차이는 없었다. -\u003e 기존 레거시 코드 노드(10버전) / 모듈업데이트 후(18버전) 과 성능 테스트로는 정확히 알 수 없지만 수치는 비슷했다.\n- lambda는 생각보다 편리했다.\n- cognito는 그닥이었다... 마이그레이션 서비스도 없고 따로 만들어야 하며, idtoken에 대한 개념도 또 알아야 했다.\n- Task 관리가 힘들었다.\n- 요구조건을 이해하고 그대로 코딩으로 할때 정확하지 않았다.(이해도 부족)\n- Raw query에 대한 이해도 부족\n- 다른 사람이 작성한 코드 바로 이해하기 힘들었다... 계속 보고 또 보고 해야지 겨우 이해했다... ( 지금도 이해하는지...?)\n- 내가 작업하고 내가 배포하는 중에 확신이 들지 않았다. 지속적인 에러로 인해 대포에 대한 두려움이 생긴거 같다.\n- kubernetes는 어렵다.\n\n\n\n## 2022-10-10 17:20:22\n### 정신없이 지나간 한달\n많은 일들이 있었다. Cognito 인증 문제가 계속 발목을 잡았지만 결국에는 해결했다.\n문제는 STS(Security Token Service) 계정의 권한 문제이다. 너무나 간단했지만 그전에 안되던게 갑자기 되는지는 확실히는 모르겠다. 내가 그때 뭘했는지가 기억이 안나니까.....\n아무튼 지금 사용하는 패턴으로 봤을때는 이문제가 가장 핵심이지 않을까싶다.\n\n1. tmux에서 각 창의 session은 독립적이라 각 창마다 토큰값을 갱신해줘야한다.\n2. ElasticBeanstalk의 Cognito identity 권한 주기 STS 권한을 준다.\n\n### EB(ElasticBeanstalk) buffer size over 문제\nEB에서 loadbalance 셋팅할때 header의 buffer size가 내가 사용하려는 사이즈보다 작아서 아래와 같은 문제가 발생했다.\neb-cli를 사용해서 eb logs를 확인했더니 upstream sent too big header가 나왔다. 검색했더니 buffer size를 변경해야 한다고 한다.\n\n- 브라우져에서는 502 에러\n- nignx 에러는  *167 upstream sent too big header while reading response header from upstream\n\n\n```bash\n## 아래와 같은 폴더를 생성하고 proxy.conf를 만든다음\n$ /project-folder/.platform/nginx/conf.d/elasticbeanstalk/proxy.conf\n\n\n## 아래와 같이 입력해주고 eb-cli를 통해 deploy 해준다. \n$ vi proxy.conf\nproxy_buffer_size                       16k;\nproxy_buffers                           4 16k;\n\n## 물론eb-cli를 설치하고 env까지 다 설정해야지 아래 명령어를 실행할 수 있다.\n$ eb deploy\n\n```\n\n\n\n## 2022-09-08 20:19:33\n### 해야될게 많다\n내가 스스로 자초한 일이긴 하지만 한개씩 해결해야 한다. \n- Github -\u003e AWS codecommit 으로 옮기기 (commit 내용까지)\n- 레거시 코드 Dockerlizing 해서 EB(ElasticBeanstalk)으로 옮기고 chatbot 으로 Push Noti 하기\n\n\n## 2022-09-04 14:22:33\n### 과연 AWS repo를 사용하면 보안상 안전할까?\n\n\n\n## 2022-09-02 20:00:33\n### 경험 많은분의 조언 \n이틀동안 많은 대화를 했던거 같다. 일단 처음 코드 셋업부터 해서 많은것을 같이 구성을 다시 하고 아키텍쳐 의견을 나누고 적용하고 비교 했다.\n그러면서 AWS에 관한 내용을 많이 듣게 되었다. 역시나 AWS는 해외 기업으로 오직 능력만 보는 듯하다. 그리고 철저히 능력 위주 성과 위주 인거 같았다. 부트 캠프할때부터 조금 이상한게 Devops 부분에 대한 열정이 남다른거 같다. 안되면 되게끔 하는 성취감과 자동배포 자동노티등을 셋팅하다 보면 좀더 이쪽이 더 적성이 맞나 라는 생각 마져 든다. 뭐 재미있으니까 \n\n\n## 2022-09-01 14:00:22\n### 쿠버네티스 드디어 해결하다.\ndocker buildx 사용해서 멀티플렛폼 빌드를 하니 잘된다.\n\n\n\n## 2022-08-29 19:30:00\n### 마이그레이션 Kubernetes, Cognito\n새로운 프로젝트가 다가온다. 아마도 시간이 많이 없을 수도 있고 바쁠수도 있다. 지난번 dotenv 파일 노출로 인해 아침에 잠깐 미팅을 하고 대부분의 access key와 비밀번호를 변경하고 각 IAM role에 대한 역할을 나눠서 permission을 지정했다. 털려도 그 계정만바꿀 수 있도록 조취를 취한것이다. 다른 곳은 어떻게 환경변수를 관리하고 있는지 궁금하다. \n\n마이그레이션의 결과는 괜찮았다. API는 제대로 작성하고 EB(ElasticBeanstalk)도 잘 운영되고 있다. 다만 기존 레거시 코드들이 모두 orm 구문을 사용해서 사용한게 아니라 raw query를 이용하여 각 들어가는 내용을 수정하는 방식으로 되어 있다. query는 조금 알고 있지만 그렇게 고도화된 raw query는 바로바로 이해하기가 힘들다. \n\n인증관련하여 AWS cognito를 사용할거 같다. 뭔지는 좀더 살펴봐야 할거 같고 공부도 더 해야할거 같은데 시간은 많이 없고힘들기도 하다. MSA 경험을 이번기회에 직접 구현을 하는것이 굉장히 좋을 듯하니 좀더 힘을내서 공부를 해야 겠다고 생각한다.\n\n묵향을 다시 정독중... \n\n\n## 2022-08-26 18:46:01\n### 사건 사고 보고\n어제 계속 이어서 nestjs deploy시 아래와 같은 에러가 발생하면서 deploy가 안되고 있다... 왜 안되는지 미치도록 궁금해서 기본 API만 실행시키니 잘되었고 기존 내가 작성한 API들도 잘되었다. 이때 마이그레이션된 API를 하나라로 (service)라도 옮겨서 실행했더니 에러가 났다.. \n이게 엄청난 시간낭비인게 한번 deploy하는데 15분씩 걸리는 듯 하다. 이유는 deploy 하는데 5분정도 걸리고... 에러나서 roll back 되는데 엄청나게 시간이 오래걸린다. 미쳐버러릴거 같아서 그냥 빠르게 다른 env 만들어서 테스트를 계속 했다. \n\n[디버그방법](https://ajh322.tistory.com/241)\n계속해서 테스트를 했다. 디버그도 했다. 실행시킬때 메모리 누유가 있는지도 체크했지만 별 소득은 없었다. 아무리 봐도 빌드단에서 메모리가 부족해서 생기는 문제같은데 이게 지난번 프로젝트가 더 큰거 같은데 이런 문제가 발생하는지 궁금하다.\n\n\u003e [ERROR] An error occurred during execution of command [app-deploy] - [Docker Specific Build Application]. Stop running the command. Error: failed to build docker image: Command /bin/sh -c docker build -t aws_beanstalk/staging-app /var/app/staging/ failed with error exit status 2. Stderr:fatal error: runtime: out of memory\n\n이런 상황에서 실수를 해서 access key가 노출되었다. 내 프로젝트라면 상관없을텐데 실제 서비스 하는 것을 노출시켰으니 까마득했지만... 일단 잘 넘겼다. 노출시에 내가 알고 있던 방법은 소용이 없었고 캐시가 남아있고 어디선가 확인이 가능해서 크롤링 해서 AWS로 메일이 왔고 어느세 누군가 접속을 시도했다.\n\n1. git reset HEAD^ \n2. 이후 git commit 그리고 push \n\n이건 push 삭제인데... 링크를 타니까 보인다... 어? 나만 삭제하면 되는줄 알았는데 링크 타니까 다 보인다.... 이건 제대로 된 해결 방법이 아니였던거다. 따라서 바로 private 으로 바꾸는게 제일 안전했던것이다... 하지만 크롤링으로 이미 다 털린 후인거 같았다.\n\ngitlab으로 셋팅을하고 해야할거 같은데.. 그것도 셋팅을 한번도 안해서 어떻게 해야할지 공부를 해야 할거 같다.  \n그나저나 EB 문제는 어떻게 해결해야 할까.... \n\n\n## 2022-08-25 20:00:03\n### 퇴근길..\n나에게 계속 시험에 들게 하는 Nest.js와 ElasticBeanstalk ... 한번 해봤다고 자만했지만 역시나 케바케로 문제가 수업시 생기는데 미쳐버릴거 같다.\n- EB에서 FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory 에러를 뿜으며 도커가 올라 가지 않는다.\n- 원인은 알수 없으나 eb local run 으로 docker 에서 얼마나 메모리를 먹는지 확인 보았는데 말도 안되는 수치를 보였다. 간단한 기본 API가 몇기가???\n- 뭐가 문제인지 혼돈의 카오스다. 뭐가 문제인지 기본 Nestjs로 돌려봐서 확인해야될거 같다. \n\n## 2022-08-18 15:40:00\n### 항해동기와 만남 AWS 관계자와 만남\n어제 저녁에는 부트캠프 동기 두명을 만나 저녁을 먹으면서 이야기를 나누었다. 난 해외에 있어서 지난번 모임에서는 빠졌었는데 어느새 한국에 와서 다같이 저녁을 먹게 되었다. 다 보지는 못했지만 결국에는 개인사정으로인해 취업을 잠시 미룬 한분을 빼고 다 취업을 마쳤다. 다들 쟁쟁한 실력자들이고 성격도 너무 좋아서 어제 만난 사이처럼 친근하게 이야기를 나눌 수 있었다. 당연히 취업 후기에 대한 이야기를 나누었는데 굉장히 다양한 경험을 한 팀원 한분의 스토리가 굉장히 흥미로웠다. 그런데 이런 흥미로운 이야기의 결말은 결국 타이밍인거 같다. 실력이 좋다고 해서 바로 빱히는것도 아니었고 실력이 없다고 해서 취직을 못한것도 아니였으며, 이 회사는 붙었다 라고 생각했지만 떨어진 경우도 있었다. 또 생각지도 못한 인터뷰가 즐거웠다던가 기대했던 회사였는데 실망한 회사도 있었다. 결국에는 많은 회사의 면접으로 보고 많은 경험을 해봐야 나한테 맞는 회사가 있다는 것을 알 수가 있었던 경험이었다.\n\n방금 미팅을 마치고 이런저런 이야기를 나누었다. AWS를 최근에 이직하신 것 같았고 마이크로서비스를 적용시킬만한 적당한 프로젝트를 찾고 계셨는데 다니고 있는 회사의 케이스가 적당해보여서 관심을 보인거 같다. 아무튼 혼자서 쿠버네티스를 구축하는데 어려움이 있어서 굉장히 힘들었는데 조금이라도 조언을 받을 수 있다면 좋을 거 같다는 생각에 힘이 났던거 같다.\n\n\n\n## 2022-08-13 23:00:11\n### Kubernetes Meet up session 참가\n카페에서 쿠버네티스와 AWS를 공부하면서 계속 삽질모드로 굉장히 힘들게 공부하고 있었는데 잠깐 딴짓을 하다 MEETUP 이라는 앱에서 Kubernetes 강의를 한다는 것을 보고 바로 달려갔다.\n너무 늦게 봐서 도착하면 20분정도 늦을거 같았지만 일단 하나라도 더 건지기 위해서 그냥 무작정 Join 버튼을 누르고 찾아 갔다. 아무튼 좌석은 없었지만 Lecturer 옆에 앉아서 정면을 보고 강의를 들을 수 있었다. \n\n[레포](https://github.com/CodeSeoul/intro-kubernetes) 강의도 깔끔하게 잘하고 예제까지 그냥 아무것도 모른상태에서 튜토리얼 따라하면서 하는것보다 이해가 더 많이 되었다. 설명을 들을때는 100% 이해를 못했지만 예제\n를 보면서 따라하니 뭔가 퍼즐이 맞춰지는 느낌이고 내가 어떤것을 잘못하고 잘했는지 몇개가 눈에 띄었다. 그리고 Helm과 Argo라는 프로그램을 알게되어 좀더 배포와 CD를 편하게 할 수 있다는것을 알게 되었고 AWS 쿠버네티스 쓸때 EC2로 하라는 조언을 받았다. 앞으로 Production 진행할때 모르는게 있으면 물어봐야겠다. \n\n굉장히 유익한 시간이었다.\n\n\n\n## 2022-08-12 17:51:10\n### 퇴근길 일주차\n- 나름대로 만족한 구직 활동\n내가 주니어 개발자로 원하는 기준만큼 좋은 직장을 구했다. 이제 새롭게 시작하는 직장에서 열심히 공부하면서 더 발전해야 할 것이다....\n출퇴근 시간 2시간은 .... 자격증 공부나 해야 겠다...\n\n\n- 특이한 면접 후기 \n무엇보다도 기분좋은 면접이라는 것을 느껴서 좋았다. 일반적인 압박 면접이 아니고 토론식 면접이 새롭게 느껴졌다. 평범한 내용의 질문은 아니었다. 긴장한 나를 위해 아이스브레이킹을 통해 이력서에 특이한 점인 해외생활에 대한 질문을 많이 물어봐주셔서 긴장이 많이 풀렸다. 그 이후에는 바로 일에 관련된 질문 3개를 통해 기술면접과 인성면접을 동시에 진행했다. 첫번째 질문은 기억이 나질 않고, 두번째와 세번째가 재미있어보였다. \n두번째는 인증에 관한 내용이었다. 부트캠프에서 인증에 관련된 내용을 2번 발표하고 Oauth2 까지 담당해서 개발을 완료했던 부분때문에 자신있었지만 그닥 끌리지 않았다.\n세번쨰는 현재 서비스되고 있는 인증부분에서 어떻게 하면 법인사용자들의 대한인증을 해야될까에 대한 주제 였다. 딱히 답은 정해져 있지 않았고 이 문제에 대한 내용을 같이 토론해 보았다. 쉬운거 같이 보였지만 이것저것 기존 인증방식과의 분리를 해야할지 (필드가 더 추가되는 문제로) 기존 컬럼에 필드를 추가해야할지 고민을 해봤고 OAuth2를 적용할지 안할지 아이디 비밀번호로만 적용할지 이야기를 나누었다. \n\n답은 없었지만 생각지도 못한 실제 서비스의 확장성을 고려하면서 생기는 문제점을 토론하다보니 금방 2시간이 지나버렸다 사실 시간은 중요하지 않았다.\n\n이렇게 면접이 끝나고 놀랐던건 면접비까지 주셔서 깜짝놀랐다. 조그만한 스타트업인데... 암튼 그렇게 놀라고 재미있던 면접이 끝났고 다음날...\n\n조금 기대하던 다른 면접에 코딩과제를 통과해서 면접을 보러 갔다. 일반적인 질문들이 많이 오고 대답은 그럭저럭 잘했던거 같은데... 쓸데없는 말을 너무 많이 했던거 같다. 필요없는 말을 너무 많이 해서 그런지 나도 일관성있게 대답을 못하고 면접관과의 냉냉한 분위기를 나도 느낄 수 있었다. 그 느낌은 틀리지 않았고 당일날 불합격 통보를 받았다. \n\n\n\n\n\n\n## 2022-07-21 23:00:12\n### 드디어?!\n- 드디어...\n몇군데 연락이 와서 면접을 보고 과제 테스트도 진행해서 합격을 받았다.\n아직은 계약서를 안썼기 떄문에 확정은 아니지만 느낌이 조금 달랐다.\n다른데는 그냥 서류에서 광탈했는데 ... ㅠㅠ\n처음으로 과제 테스트를 했는데 Nest.js 버전으로 인해서 typeorm을 못쓴게 아쉽다...\n\n- 항해99 팀원 근황 \n우리 팀원들 궁금해서 카톡을 했는데 다들 잘 생존하시고 있는거 같다.\n그리고 활발하게 구직활동을 하고 있는것으로 보이고 있어서 다행이다.\n\n- 항해99 기술모의면접 후기\n질문이 다 기억이 안나는데 기억나는대로 적어보면...\n1. 채팅서버 스캐일 문제 -\u003e 면접볼때마다 질문이다. 아직 모르니 알아둬야겠다\n2. 목표하는 회사에 대해 질문을 무엇을 할것인가? -\u003e  뭐라해야할지 잘모르겠다. 갑작스러운 질문이라..\n3. 추가로 질문하신게 인상깊었는데 풀스택으로 어필을 안하는 이유를 물으셨다. -\u003e 아래 적었던 이유이다. 대기업에서는 대부분 전문적인 포지션을 원한다 얼마만큼 효율적인 코드를 짜고, 단기간에 성과를 내는 부분이다. 자칫 잘못하다가는 이것도 못하고 저것도 못하는 낙동강 오리알이 될거 같다 라는 말로 대답했다.\n4. 왜 엑세스 토큰과 리프레쉬 토큰을 사용했는지에 대한 이유 -\u003e 첫번째는 보안에 관련된 문제, 토큰 생명주기를 나누고 따로 관리하며, DB에 토큰을 저장하는것까지 생각해보면 탈취된다 했을때 피해를 최소한으로 막을 수 있을거다.\n\n## 2022-07-20 10:00:32\n### 나의 위치는 어디인가? \n- 풀스택에 대한 글을 읽고.\n어느 블로거가 말하는 풀스택 개발자에 대한 개인적인 의견을 읽어 보았다.\n요즘은 풀스택이라고 포지션을 찾는 회사는 거의 없다고 한다 그 이유는 프론트나 백엔드나 한쪽으로 전문적인 사람을 기업에서 더 선호한다라는 것이다. 그럼 나의 잡다하고 얇은 지식은 과연 쓸모가 없는것인가?\n\n- 어떤 개발자가 될것인가에 대한 생각 \n토스관련 인터뷰를 보았는데 어디선가 많이 듣던 조언을 똑같이 해준다. \n\u003e ***\"결과물 도출도 중요하지만 그 과정을 어떻게 해결하느냐가 중요하다.\"***\n항해99에서도 같은 말을 들었다.\n\n생각해보면 어떻게든 코드는 구현이 가능하다. 속도가 느리거나 빠르거나, 그러나 비지니스 로직으로 실제 서비스를 적용하면 과연 이게 효율성 있는 코드인지 아닌지는 바로 구별이 간다. \n바로 속도와 클라우드 최종 인보이스가 나올때 이다.\n\n- 서류전형\nKINX라는 회사를 처음 들어봤는데 꾀 큰 기업인거 같은데 항해99측과 협의가 되었는지 몰라도 서류전형까지는 어떻게든 패스를 했다. 이제 인성테스트(?) 약 40분간 진행하고 공통문제를 작성해야 한다.\n그리고 코딩테스트를 하는데 결과는 크게 기대는 안한다...  \n\n\n## 2022-07-19 22:30:00\n### 광탈 \u0026 해외 IT기업에 지원 \u0026 알고리즘 공부를 다시 시작\n- 서류 전형에서 광탈하고 있다. 예상했던거고 계속 도전해야겠다.\n- 해외에서는 조금 더 리쿠르터들의 활동이 활발한거 같다. 최근에 IT관련해서 일하고 있는 친구를 만나 여러가지를 물어봤는데 리크루터를 통한 취업이 활발한거 같다. \n- [hackerrank](https://hakerrank.com) 라는 사이트를 많이 사용하는거 같다. 한국에 있는 기업뿐만아니라 다른 나라도 개발자가 부족한거 같다. 내 Linkedin에 그닥 많은 이력이 있지는 않지만 일단 추가 하고 보는거 같다.\n- Nestjs에서 swagger를 셋팅하는데 ApiQuery에 gender를 입력하고 enum 리스트로 male, female 옵션을 넣으려고 했는데 왜 안되는지 잘 모르겠다.\n\n## 2022-07-17 22:40:00\n### Nestjs, Typeorm 업데이트로 인한 문제발생\n레퍼런스를 통해 확인한 내용은 customRepositry를 만들어서 기존에 entityRepository를 대체해서 주입해야 한다.\n그리고 swagger 및 test코드에 대해 조금더 확실히 넘어가야 겠다.\n\n## 2022-06-20 23:47:30\n###  멘탈 잡기\n구직 활동에 대한 초조함이 가득하다. 멘탈이 나갈꺼 같지만 그래도 다시한번 멱살잡고 나아간다.\n\n\n## 2022-06-19 23:55:42\n### 멘토 \n고등학교 선배님께 멘토 요청을 했다. 아직도 게임 업계에서 PM으로 일하시는 듯 하다.\n항해 최근에 모의 면접을 봤을때는 중고 신입으로 좋은 거 같다라고 말을 들었지만,\n현실은 그렇게 녹녹치 않은거 같다. 멘토님은 나이가 많다. 내 나이 만큼 CTO가 있을것이고, 나보다 어린 사람이 많다는 것이다.\n또한 나보다 나이도 적고 잘하는 사람 뽑을 것이다 라는게 멘토님의 의견이다. 나도 동의하고 그렇게 생각했다. 하지만 어느 커뮤니티에 나보다 더 나이가 많은 사람도 새롭게 시작하는 사람이 많은거 같다.\n남들 보다 더 노력하고 열심히 안하면 뒤쳐질 것이다. 마음을 더욱 굳건히 흔들리지 않고 해낼 수 있다는 마음으로 나아가야 할거 같다.\n\n\n## 2022-06-14 23:33:43\n### 블로그 정리\n카테고리만 만들어 놓고 정리를 안해서 너무 지저분 하다.\n링크만 있고 내용은 없는 것들은 채워넣고 양보단 질로 하나씩 준비해야겠다.\n\n\n## 2022-06-13 23:22:43\n### 불안감\n나의 위치가 어느정도 인지 잘모르겠다. \n얼마나 서류에서 광탈할지 면접에서 어떻게 광탈할지 링크드인으로 지원시 어떻게 될지 궁금하다.\n\n\n## 2022-06-12 23:34:33\n### 지원하다\n관심 있었던 회사에 일단 모두 지원을 해봤다.\n아직 내가 얼마만큼의 역량을 가지고 지원한 회사에서 얼마만큼 나의 기술을 인정해 줄지는 아직 모른다. 좀더 많은 곳에 두들겨 보고 또 준비도 해야겠다. 물론 코딩테스트와 기본 내용들도 꾸준히 준비 해야겠다.\n\n## 2022-06-09 23:33:33 \n### 가상 인터뷰\n모의 인터뷰를 했다. 아래와 같이 정리 해본다.\n1. 자기 소개는 진짜 자기 소개가 아니다. 내가 어떤 스택을 가지고 있고, 어떤 개발자인지 짧게 소개 한다.\n2. 일단 이력서에 쓴 내용들은 깊이를 막론하고 다 알고 있어야 한다. 기본적으로 이력서 베이스로 질문이 들어오기 때문이다.\n3. 따라서 약어를 모두 알고 있어야 한다. MVC, CI/CD, AWS, SSL Access Token, Refresh Token, 등\n4. 두괄식으로 말을 해야 한다. -\u003e 짧게 이것은 이것이다. 말한 후 그것에 대한 설명을 간단 명료하게 한다.\n5. 자바 스크립트에 관한 기본 내용도 나올 것이다. \n6. 다시 준비해야 한다. 이렇게 준비했다가는 광탈일 거 같다.\n\n## 2022-06-05 16:30:33 \n### WIL\n\u003e드디어 4주간의 실전 프로젝트가 끝났다. 아쉬움이 너무 많이 남지만, 웬지 모르게 최종 발표회때 굉장히 많은 협력업체들의 질문을 받은거 같다. 내용을 정리해본다.\n\n1. 아키텍쳐 문제 \n   ![image](https://user-images.githubusercontent.com/56494905/172051470-c15ad926-1d69-4672-bfb3-ae6543cd1768.png)\n* 내가 실수 + 몰랐던 부분\n    - 몽고 DB를 채팅서버랑 도커로 묶었다. (X)\n        - DB는 서버랑 묶어서 서버를 묶지 않는다. (sacle up이 불가능하다.)\n        - Redundancy가 불가능하다. \u003c- 장애 발생시 다른 인스턴스가 생겨서 에러를 방지 \n        - 가용성(Availability) 확장성(Scalability) \n        \n    -  Elastic Beanstalk 에서 Load Balancing이 작동되는 원리를 잘모르겠다.\n        - 아키텍쳐에서 내가 nginx 를 넣어 놨는데 단지 내가 ssh로 들어가서 nginx가 있어서 reverse proxy 가 되는걸로 알고 이렇게 적었는다.\n        - 그런데 생각해보니 내가 따로 서버를 나누었던 것은 그냥 각각 다른 인스턴스의 도메인이다.\n        - 즉 각각 nginx가 있더라도 reverse proxy로 작동되는게 아니라 그냥 각각의 nginx가 따로 작동되는것이다.  \n        - 그럼 EB에서 있는 LoadBalancing은 어떻게 작동되는 것일까? 좀더 생각해 봐야겠다.\n \n##  2022-05-22 16:04:33\n### WIL\n\n    \n1. 큰 문제가 생겼다. 프론트 부분이 진행이 힘들어 보인다. 내가 생각한 원인은 아래와 같다.\n    * 소통을 매일 했지만 프론트와의 대화가 깊이가 있지 못했다.\n    * 금방된다 라는 팀원의 말을 그대로 믿었다. \n    * 그 결과 실제로는 내가 생각하는 완료의 선과 다른 사람이 생각하는 완료의 선이 다르다고 확실히 느꼈다.\n        예) 팀원1) 거의 다 됐어요 -\u003e 내가 생각했던 다 됐어요의 뜻이 달랐다.\n    * 분명 다 된것이다. 내가 보더라도 CSS만 입히면 될것 처럼 보였다. 하지만 결과는 그렇지 않았다.\n\n\n2. 위와 같은 이유로 내가 행했던 행동이다.\n    * 현재 무엇이 안되고 되었나에 대한 내용을 팀원들과 TODO 리스트를 작성했다.([링크](https://www.notion.so/t-1/0d6f423b95804cbfbf90e9e245bae622))\n    * 앞으로 해야할일과 말아야할 일을 어떻게 해야하는지 알려줬다. \n        예) 마이페이지에서 디자인이 안나와서 그냥 기다리고 있다. -\u003e  디자이너와 다시 이야기해서 언제끝나는지 확인후 TODO 리스틀 확인후 언제 끝날지에 대해서 확인 후 팀원과 공유\n    * 언제 어떻게 무엇을 어떻게 끝낼지 2번에서 정했다면 오전, 점심, 저녁에 진행사항을 공유 하자고 했다.  \n    * 물론 백엔드 3명이 다 달려들어 도와줬다.  채팅, 로그인 부분, 마이페이지, 랭킹 \n\n3. 결과\n    * MVP는 완성\n    * 백엔드에서 진행해야 할 일들을 끝내지 못했다. (성능 테스트, 통합테스트) 성능 개선 및 리펙토링 \n    * 그러나 기본적인 기능들은 대부분 작동했다.\n    * 정작 내가 해야할 일들을 다른 팀원이 백업을 해서 도와줬다.\n\n\n\n\n##  2022-05-15 14:04:14\n### WIL\n1. Typeorm 쿼리문 문제 [이슈링크](https://github.com/ddang-ddang/back-end/issues/48)\n    * 내장된 typeorm 문법을 사용하려고 했다.. 하지만 처참히 실패 하루를 날렸다. [실패이슈](https://github.com/ddang-ddang/back-end/issues/52)\n2. Elastic Beanstalk 공부로 인한 다양한 삽질결과물\n    * Elastic Beanstalk는 AWS 핵심 기능의 하나이다.\n    * CI/CD, HTTPS, Load Balancing, EC2, Codepipeline, nginx 등 모든 기능들을 한꺼번에 사용할 수 있다.\n    * 다양한 방법으로 deploy를 할 수 있다.\n    * 도커에 대해 잘알면 다음으로 넘어가기 쉽다.\n    * nginx 도 들어 있어서 Reverse Proxy까지 알고 있어야한다.\n    * docker 경로 설정이 복잡하지만 해결했다. 작성해야할 문서들이 많아졌다\n    * Github -\u003e Codepipeline -\u003e Node Source -\u003e Elastic Beanstalk -\u003e 배포 완료\n    * Github -\u003e Docker 배포 -\u003e Docker Image로 -\u003e Elastic Beanstalk -\u003e 배포완료 \n    * 채팅 서버까지 연결 하려면 필히 Reverse Proxy를 이용해서 한개의 아이피의 라우터로 각각 다른 서버의 서비스를 붙여야한다.\n3. Refresh token에 관련한 내용에 대해 좀 더 알게되었다.\n    * Refresh 토큰에 관한 내용 [이슈](https://github.com/ddang-ddang/back-end/issues/39)\n    \n\u003e 나혼자 작업이 지체되고 있는거 같다. 좀더 분발해서 진도를 나가자\n\n## 2022-05-09 16:45:17\n### WIL\n- 프로젝트 진행사항 이슈\n- Entity 에서 class-validation을 사용할때 @IsNotEmpty() 옵션을 줘야지 POST가 잘 받아짐\n- local.strategy.ts 작성할때 Id를 user말고 다른걸로 설정할때 아래와 같이 usernameField를 설정하지 않으면 에러가남\n```javascript\n@Injectable()\nexport class LocalStrategy extends PassportStrategyStrategy() {\n  constructor(private authService: AuthService) {\n      super({ usernameField: 'email' })\n      }\n}\n```\n- 아직 해결중이지만 쿠키에 JWT토큰 넣고 서버에서 res.cookie('token', access_token) 해줘도 프론트팀에서 만든 프론트에서 랜덤으로 쿠키가 들어간다. 아직은 이유를 모르겠다...\n\n## 2022-05-04 20:19:56\n- 10시간 동안 회의만 하는중... \n\n## 2022-05-01 15:11:35\n### WIL\n- 실전 프로젝트 관련 내용 정리\n- Stack\n    * Frontend\n        1. react.js \n        2. kakao map API\n        3. PWA\n        4. GPS\n    * bakcend\n        1. Nest.js\n        2. Socket(예정)\n    * DevOps\n        1. Docker\n        2. Github action\n        3. pm2\n        4. aws\n        5. mysql\n- Main concept\n    * 지도상 내가 생성한 마커를 기준으로 주변 사람과 소통 및 미션을 수행후 리워즈및 명예의 전당에 오를 수 있음\n\n- target\n    * mobile user()\n\n        \n- 1일차\n    * 위치 기반 서비스에서 컨셉이 시작\n    * 포켓몬고와 같이 게임 컨셉으로 진행을 했음\n\n## 2022-04-30 20:22:42\n- 실전 프로젝트 2일차\n- 기존 2조와 같은 백엔드 팀원으로 조가 같이 됐다. 이미 익숙해서 다들 친해서 굉장히 수월하게 진행되는 느낌이다.\n- 2일만에 전반적인 기본 틀과 API ERD가 나왔다.\n- 주제는 위치기반의 커뮤니티 서비스. \n- 일요일에는 CI/CD를 좀 구성해보려고 한다.\n    - Github action, docker, pm2, mysql, nginx 이렇게 구성할 듯 싶다.\n\n\n\n## 2022-04-24 21:02:40 \n### WIL\n- 아직 해야될게 많은데 마음만 앞서고 정작 해야 될것을 조금씩 미루고 있는거 같다  \n- 아직도 우선순위로 해야 될 일을 정리하지 못하고 있는거 같으니 다시 정리해서 천천히 해야할 일을 먼저 끝내고 다음 작업을 진행하도록 스스로 다짐한다 \n- 다음 주 중으로 리더 부리더를 뽑는다고 한다. 나도 정작 해야 할 일을 잘 못하고 있는 판에 다른 사람들을 잘 이끌수 있을까 싶다. 다른 팀원들은 묵묵히 자기일을 끝내 놓고 다음 단계를 진행하는데 나는 아직 제자리 걸음인거 같다 \n- 레이지 로딩, 이거로딩, N+1문제 라는 주제로 WIL를 작성 해야한다. 한번도 들어본적이 없는 주제이다. 하지만 다른 분이 정리해 놓은 포스팅을 보고 나서 간단히 이해한 내용을 정리하려 한다\n\n\n\u003e 레이지 로딩 : 이미 DB를 다 불러와서 쓸데 없는 데이터까지 모두 한번에 가져온다. 트래픽 발생이 생길 수 있다.\n\n\u003e 이거 로딩 : 원하는 데이터를 그때그때 불러온다. 트래픽이 많이 발생하지 않지만 한번에 많은 트렌젝션이 발생한다. TYPEorm에서는 이러한 문제를 leftjoin같은 구문으로 해결한다고 한다 \n\n\u003e N+1 문제 : 이거 로딩에서 한개의 쿼리문이 발생할때 그 이상? 더 많은 개수의 쿼리가 발생된다( 옵션별로 쿼리문이 생기기 때문에)\n\n- 지금 간단히 이해한 내용은 이렇고 따로 항목을 만들어서 테스트 하면서 작성 하고 싶다.\n- TYPEorm을 아직 시작을 안했기 때문에...\n\n## 2022-04-17 09:45:15 \n### WIL\n\n- Node.js : ORM, noSQL vs SQL\n\n* ORM(Object Relational Mapping)\n    - 객체 관계 맵핑\n    - 예전에는 모든 테이블형의 데이터 구조를 가지고 Primary key와 Forigner key를 가지고 테이블간에 정의를 내렸다\n    - 하지만 복잡한 쿼리문과 가독성이 떨어지는 구조는 RDBMS의 한계라고 생각된다\n    - 따라서 이것에 대한 대안으로 객체의 개념을 데이터베이스와 연결시켜 하나의 데이터베이스 프레임워크가 되버린 듯하다\n    \n\n* NoSQL 을 사용하면서 느낀점\n    - 굉장히 자유롭다\n    - 자바스크립트의 말도안되는 확장성의 성격을 가지고 있다\n    - 한번에 간단한 구조의 데이터베이스의 활용으로는 괜찮을 듯 하다\n    - 하지만 데이터가 굉장히 많아지고 처리해야할 트렌젝션이 많아진다면? \n    - 한번에 많은 사용자가 요청을 많이 하게 된다고 하면?\n    - 서버의 성능이나 대역폭에 따라 다른 성능을 보일것으로 생각된다.\n    - Nosql 과 SQL 과 같은 사양의 서버로 같은 형식의 데이터 구조를 불러왔을때 얼마나 성능이 다른지 궁금하다\n\n\n* SQL 을 사용하면서 느낀점\n    - 역시 관계형 데이터 베이스로 관계 형성이 굉장히 복잡하다\n    - 간단한 게시판과 코멘트의 테이블을 만들고  게시판이 코멘트를 가지고 있는지 코멘트가 게시판을 가지고 있는지 결정해야 한다\n    - 또한 1 대 다 상관관계와 1대 1 관계 다대다 관계등 복잡한 테이블속에 관계를 형성하는게 앞으로 서비스 품질에 영향을 끼칠 것으로 생각된다\n    - 한번 관계를 형성하고 데이터베이스 구조가 완성이 되면 수정 및 추가 부분이 굉장히 힘들고 요구비용이 많이 든다\n    - 요구되는 사양을 충분히 생각하고 그에대해 추가적으로 기능 구현이 될 수 있는 부분을 고려해서 디비를 설계하는게 좋을 듯 하지만 이 또한 비용 적인 측면에서 추가로 들 수 밖에 없다\n\n\n* Sequelize 사용하면서 느낀점\n    - 옛날에 사용했던 느낌으로만 진행하려고 하니 막히는 부분이 굉장히 많았다\n    - ORM 방식을 처음 써보는데 MongoDB와 굉장히 유사하지만 테이블간에 관계 형성에 대해 연결해서 생각하기 굉장히 어려웠다\n    - 몽고디비는 model을 만들고 나면 한번 만든 model를 가지고 삽입 삭제 수정 등 모든 CURD 작업을 할 수 있다\n    - 하지만 Sequlize도 비슷하지만 먼저 Sync 메소드를 통해서 연결부분을 \n    \n    \n* 코드의 재활용 및 리펙토링\n    - 지난주에도 느꼈지만, 나의 코드는 굉장히 더럽다.\n    - 반면 다른 분들의 코드는 깔끔하고 가독성도 좋다\n    - 지금은 구현에만 중점을 두고 있는데 조금더 리펙토링과 가독성 측면에서 더 생각하면서 진행해 봐야겠다\n    \n    \n* 앞으로 해야할 것\n    - typescript\n    - typeorm\n    - nestJS\n    - API test  \n\n\n\n## 2022-04-13 10:29:11\n[완성링크](http://diasm.mooo.com:3005)\n\n지난 주말에 빠르게 노드관련 클론코딩을 마치고 그 베이스를 가지고 처음부터 만들어 보았다 중간중간 잊어버린 코드와 copilot 의 도움을 받아 하루?만에.. 만들긴 했지만 아래와 같은 문제점이 발생 하였다\n\n\n\n* [ ] 하다 보니 디자인이 거슬린다... \n    - CSS 손대지 마라...\n* [ ] redirect 부분이 고려가 안되었다\n    - 코멘트의 삭제 API를 불러왔을때 바로 전단계로 다시 불러오고싶지만 안된다.\n    - 아직 고민을 더 해봐야한다... \n* [ ] 예외처리 부분에 대해서 조금 더 고민해봐야한다\n    - 뭔가 잘못하고 있는거 같다... \n* [ ] 백에서 보내서 프론트에서 받은 내용이 깨지는 문제점\n    - 아래 코드를 이용해 완료했다. 모든 내용을 보낼때마다 UTF로 어떻게 보낼 것인가?\n    - res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});\n* [ ] 리펙토링을 하면서 코드의 가독성이 좋아지지만 파일 구조가 복잡해지는 문제점\n    - 리펙토링을 과하게 하지 말자\n    - 어떤 내용을 중심으로 리펙토링을 해야할지 미리 생각해야 한다\n* [ ] 변수들을 안으로 넣는가 아니면 구조화 하는가 고민해봐야하나?\n    - \n* [ ] 게시물의 ID를 몽고디비에서 제공하는 Id 변경해서 다시 해보자\n    - 기존에는 내가 임의로 생성한 number를 카운팅하는 방식으로 넘버링을 했다\n    - 그리고 게시물의 넘버링과 코멘트의 넘버링을 같이 카운터 해버리기때문에 게시물의 넘버링을 해줄 수 없다 -\u003e 근데 꼭 해줘야하나? \n* [ ] 생각을 한대로 진행은 했지만 개인적인 프로젝트를 싫행하면서 계속 바뀌는 점이 발생하였다\n    - 100% 생각대로 된다면 더할 나위 없겠지만, 생각지 못한 부분에서 막히거나 잘못 설계한 경우에는 롤백을 할 수 밖에 없다는 생각이 든다\n    - 처음 설계시 충분한 생각을 가지고 내용을 정리한 후 예외 처리같은 부분을 잘 생각해서 설계를 해야 할거 같다\n\n\n## 2022-04-10 06:49:20\n### WIL\nNode.js 주차 시작인데 꽤 재미있다. \n스파르타 강의를 보다가 뭔가 답답해서 지난번에 하다가 중단한 유튜버 강의를 보고 따라했다\n중간중간 오타 같은것도 있어서 굉장히 헤맸지만 대부분 다 해결되었다.\n\n클론코딩을 하고 나서는 정리를 하는게 굉장히 머리속에 잘 남는거 같다\n아니, 모든 공부 뒤에 정리를 하는게 머리속에 더 남는다\n아래는 리스트는 이 클론 코딩을 하면서 배운 내용이다\n\n\n* MVC(Model, View, Controller) understand\n     - Model : data initialize, data structure\n     - View : html, css, js\n     - Controller : routing, data processing, data validation\n* How to use google auth\n     - Register google dev console\n     - Add google auth to project\n     - Get the google auth token\n     - Use the token to access the google api\n     - Use passport library for google auth\n* How to use Materialize[Site link](hhttps://materializecss.com))\n* How to use Mongodb\n* How to use hbs(Express view engine for handlebar.js)\n* How to use express \n      - app.use is used to use middleware\n      - app.router is used to use router\n      - GET, POST, PUT, DELETE, PATCH\n* How to use middleware in router\n     - Middleware is a function that runs in the middle of the router\n     - So, middleware is used to check the user is logged in or not\n\n\n\n[link](https://github.com/diasm3/Node_prac/blob/97cd2be291dc3217165e96eafb186b1be604d7c1/README.md)\n\n\n## 2022-04-09 05:50:21\n토요일\n* 주특기 시작\n   * 첫 과제는 게시판 만들기\n    * get, post put, patch, delete 관한 내용을 알게되었다.\n    * 여태 그냥 axios.get()만 써왔는데 왜 이것을 쓰는지에 대해 좀더 명확하게 알게 되었다\n\n\n\n\n## 2022-04-03 22:58:40 \n### WIL\n일요일\n\n- 힙, 정렬(버블, 선택, 삽입, 퀵, 머지, 힙) 중 최소 3개\n- [[heap]]\n- [[merge_sort]]\n\n\u003e 정렬같은 경우 단골로 나오는 알고리즘 문제이다 꼭 한번씩은 다시 직접 구현해서 잊어버리지 말자\n\n\n\n\n## 2022-04-02 18:44:34\n집중력 기르기 \n1. 휴식 취하기 \n2. 계획 세우기 \n3. 명상하기\n4. 집중이 잘되는 장소 선택하기\n5. 균형잡힌 식생활하기\n6. 자주 운동하기\n7. 휴식을 취하고 환경에 변화 주기\n8. `집중력 연습을 꾸준히 하자`\n9. `내가 할 것을 명확히 하자`\n10. 한눈을 팔거나 딴 생각을 할 시간을 따로 정해두자\n11. `집중할때 호흡을 자주하자`\n12. 최소 한시간 최대 30분 간격으로 조금 쉬자\n13. `한번에 한 가지 일을 마치는 연습하자!!! `\n\n\n\u003e 나만의 위키 천천히 한개씩 완성시켜보자\n\n\n## 2022-03-29 21:39:23 \n월요일\n\n오늘은Docker로ubuntu를 만들어 SSH와 nginx를 설치해서  github actions을 통해 자동배포까지 진행해봤다 \n기초적인 CI/CD에 대한 내용을 알게 되었다 \n\n아래와 두개를 링크를 걸어보았다\n\n* [[docker-basic]]{docker 관련 기본}\n* [[github-actions]]{github action을 통한 자동배포}\n\n\n## 2022-03-27 17:49:08 \n일요일 \n\n푹 쉬었다. \n쉬는것도 중요하다고 생각한다.\n아직도 가야할 길이 길기때문에 페이스 조절을 잘해야겠다.\n\n###  WIL\n2 주차가 마무리 됐다. \n\n조금 후회가 되는 2주차 였다.\n더 집중해서 했으면 뒤쳐지지 않았을텐데...\n다시 도토리반에 들어가서 `링크드리스트`, `스택`, `큐`, `해쉬 테이블` 을 복습 할 에정이다.\n\n그래도 조금이라도 이해한 내용을 아래 적어본다\n\n* [[graph]](그래프)\n* BFS\n* DFS\n* 트리 \n\n## 2022-03-26 15:33:03 \n토요일 \n팀원들과 vscode live share를 핳면서 스택에 대해서 같이 공부했다.\n같이 코딩을 하면서 뭐가 문제인지 파악하면서 하니 재미있었다.\n가티 코딩하는 도중문제가 발생했는데 적어봐야겠다.\n\n1. 처음 설계를 정하지 않아 방향성을 잃\n2. 각자 파일을 만들고 거기에 대한 클라스를 만들고 메소를 만들어 하나의 __main__ 파일로 가져오려고 했을때 같은 데이터를 못쓰는 문제점이 있었다. \n    * 결국에는 구조적인 문제로 인해 다시 만들어야 했던거 같다.\n\n* [wikidoc](https://wikidocs.net/16073)\n* [[inheritance-python]]{파인썬 상속}\n\n\n\u003e python 상속에 대해서 조금 더 알게되었다.\n\n\n\n\n\n## 2022-03-25 06:46:47\n금요일 \n오늘도 집중해서 해보자 \n\n다시 스택과 링크드리스트 큐에 대해서 공부를 시작하였다\n복습하는 단계로 아무것도 없는 빈 페이지에서 직접 구현까지 할수 있는 단계까지가 목표이다\n\n\n## 2022-03-24 07:26:28\n목요일\n김병관 멘토님의 면접 관련 미팅\n블로그는 꾸준히 내생각의 흐름을 적는 방식으로 적어라 \n기본적인 내용 스택 같은거 \n두번쨰로 협업 능력 남탓 하지 않기 나의 부족함을 알기\n알고리즘 주차에서 사고방식의 복사\n\nOSI 7개층에 대해 항해톡을 들었는데 내걸로 만들\n\n## 2022-03-23 15:56:38\n오늘도 집중을 못하는 나 하루에 빡집중이 얼마나 될까 싶다.\n정리 못한 일주차 부터 차근차근 해야 하는데 막상 다시 하려니 막막하다.\n포기하지 말자\n- 오늘은 이진트리에 관한 내용을 진행했다.\n\n밤에 조금 더 집중이 잘되는 듯 하다\n\n\n## 2022-03-22 12:59:11 \n팀배정에 관한 내용을 전달 받았다. \n- 백엔드와 프론트엔드 두명이 리더와 부리더 짝꿍이 되어 지원한다.\n- 대면 평과와 더불어 어느정도 기술적 능력은 있어야 하지만 정신적으로 팀원의 서포트와 팀을 이끌어 갈 수 있는 역량이 필요하다.\n\n자기 반성\n- 일요일에 Vimwiki와 Vim을 셋팅하면서 굉장히 집중이 잘되었다고 자만하던중어제 오늘 집중을 못하고 있다.\n- 해야될것을 미루는 중인데 차근차근 다시 작성해야겠다. 항해가 끝나기 전까지는 항목에 있는 모든 것들이 채워지길 바란다.\n- [[MVC]] 모델에 관한 내용을 오늘에서야 처음 알았다. 공부해야될게 많다.\n\n\n## 2022-03-21 08:11:29\n부트캠프 3주차 시작\n여태 앉아있는게 어수선하고 졸립고 힘들었는데 이제 조금씩 적응되면서 집중할 수 있다.\n블로그에 정리하는게 머리속에 더 잘들어오는거 같다\n\n오늘 발표하신분의 퀄리티가 너무나 좋았다. 이름을 잊어버렸는데... 재귀 함수와 loop구분의 차이점을 쉽게 설명해주시면서 스택오버플로우가 왜 생긱는지에 대해 자세히 설명해주셔서 이해가 빨리됐다. 나도 한번 정리해야겠다\n\n## 2022-03-20 19:25:10\n### WIL [작성중]\n\u003e- 알고리즘 주차가 시작되었다.\n\u003e- 이 항목들을 많이 봐왔지만 맨날 졸립기만 하다 여전히\n\u003e- 파이썬으로도 다시 공부해야기 때문에 시간도 많이 걸리고 문법도 다시 이해해야한다.\n\n- [[array]]{배열}\n- [[linked-list]]{링크드리스트}\n- [[stack]]{스택}\n- [[queue]]{큐}\n- [[hash-table]]{헤시테이블}\n\n## 2022-03-20 17:48:51\n하루종일 vim + vimwiki랑 싸우다가 이제서야 정리를 한다\n결국에는 버전 문제 였구나..\n몇시간동안 헤매다가 이렇게 잘되는군.....\n\n## 2022-03-20 14:57:35\n오늘부터 이렇게 쓸것이다 \n\n\n\n\n\n"])</script><script>self.__next_f.push([1,"9:T44a0,"])</script><script>self.__next_f.push([1,"* [[TOC]]\n{:toc}\n\n## 2023-08-22 20:45:23\n### 프론트엔드까지...\n\n\n\n\n## 2023-07-10 07:29:00\n### 복귀\u0026 gitaction (CI/CD)\n- 휴가 복귀 했다.\n- 항해플러스 이번에는 CI/CD이다 이미 여러번 해봐서 어떻게 해볼까 싶었는데 마침 생 azure 서버를 제공 받게 되어서 docker hub로 push pull 하는 방식으로 해보았다. 약간의 문제는 있었지만 그래도 잘 해결되어 빠르게? 반나절만에 구축했다.\n- 하지만 CI는 그냥 CMD로만 실행하게끔만 해놓고 실패하면 중단되지는 않는다. 아직 그 부분은 고쳐야 할 부분이다.\n- 그 외적으로 작업한 내용은 config의 내용에 db init 내용이 들어가 있어서 분리를 했고, db logging을 스위칭 할 수 있도록 했다.\n- 트러블 슈팅이라 하면... process.env로 받은 것을 custom Provider로 해놓으면 왜 못가져오는지 잘 모르겠다.\n- string true, false의 값을 boolean으로 처리하고 싶을때 문제가 발생한다. 이 부분은 조금 테스트를 더 해봐야 겠다.\n\n\n\n## 2023-07-04 06:00:00\n### 항해 플러스 후기 4주차\n- 시간이 너무 부족하다. 특히나 하고 있는게 많고, 회사 배포일정까지 늦어지면서 굉장히 신경쓰이는 일이 많아 제대로 집중을 못하고 있다. 하지만 다른분들은 열심히 해주신 덕분에 피드백을 참조하면서 작성을 하고 있다.\n- 일단 코치님의 실업무를 기반한 조언들이 굉장히 자극을 주기 충분했다. 객체지향이란 것에 대한 생각, 같은 코드를 짜더라도 어떻게 의미 전달을 더 잘할 수 있을까에 대한 생각. TDD에 원론적인 방법과 현실을 조금씩 알게되었다.\n- Nestjs를 계속 이용하면서 좀더 깊게 알게 되는거 같았고 이미 알고 있다고 한것중에 잘못된 부분도 팀원의 도움으로 알게 되었다.\n- 예를 들어 DTO같은 경우 Entity와 혼용해서 사용했는데... (뭐 현회사에는 Entity가 interface로 되어있긴하다...) 같이 swagger 데코레이터랑 혼용해서 엉망으로 하고 있긴하다. 그런데 Entity와 Dto의 분리는 명확해야한다는걸 알게되었다.\n- 객체지향의 대한 방법과 철학을 느낌으로 알지만 아직까지 잘모르는 거 같다. 내가 이해한 바로는 컨트롤러, 서비스, 각각에 도메인에 대한 내용만 최대한 넣어야 하며 리펙토링 과정에서 생기는  다른 함수 또는 클래스는 독립적으로 작동이 되어 최대한 다른 서비스에 영향을 끼치지 않아야 한다. 아니 끼치지 않게끔 설계를 해야한다. 즉 독립적인 메소드에 대한 테스트 코드가 가능해지고 레포지토리에 대한것은 그냥 외부 모듈로서 데이터를 찍고 온다는 느낌으로 가는 것이다 라고 이해했다.\n- 처음으로 경력분들과 일하게 되면서 다양한 의견과 코드 스타일 의논도 많이 하게 되었고, 조율하는데 있어서 새로운 경험이 되었다. 아직 조그만한 스타트업을 다니면서 혼자 또는 CTO님의 코드리뷰를 받기만 했지 따로 동등한 위치의 팀원과 코딩을 한건 이번에 처음이다.\n- 순수 TDD로만 개발하는 단계여서 그런지 다들 어떻게 해야할지 막막하고 생각도 많아 초반에는 진도가 정말 안나갔다. 하지만 한번 두번 테스트 코드를 작성하고 피드백을 받으면서 자기만의 스타일 + 코치님의 조언대로 이렇게 저렇게 해보면서 테스트 코드를 작성하니 훨씬 도움이 많이 되고 방향성을 잡을 수 있었다.\n- 아마도 항해 파트1기다 보니 실험적인 측면 + 다양한 시도를 해보고 있는 느낌을 받았다.\n- 생각보다 이탈자가 많이 보이는 듯 하다. 이유는 나도 느끼고 있지만 현업 + 공부 + 프로젝트까지 하기가 정말 힘들다.\n- 토요일은 하루종일 코딩만 한다고 생각하면 된다. 하루가 없어진다....\n- 아무튼 힘들긴 하지만 이것만 집중했더라면 재미있게 진행할 수 있을거 같다.\n\n## 2023-07-03 10:38:00\n### 휴가\n- 취직하고 1년만에 휴가를 쓴다. \n- 오랜만에 필드를 나가고, 하고싶었던 수중 촬영을 위해 어드밴스 스쿠버다이빙 자격증을 따러 간다.\n- 물론 일도 해야하고...\n\n## 2023-06-11 09:22:00 \n### 항해 플러스 후기\n- 첫날이니까 뭔가 어수선하고 무엇을 해야될지 잘 모르겠었던거 같다.\n\n\n## 2023-06-10 15:31:00\n### 복잡하다\n- 어떻게하면 더 간단히 알림을 만들 수 있을까, 지금은 fcm과 inapp 알림이 복잡하게 엮여 있고, 사용자 - 파트너즈, 사용자 - 사용자 끼리의 메세지가 지속적으로 생기고 있다. \n- function을 너무 많이 쓰면 타고 들어가는 부분이 많아져서 기억하기가 힘들다... 최대 2 depth 가 적당한거 같은데. 다른 패턴은 없을까?\n\n\n## 2023-06-09 07:00:00\n### 카카오바이크\n- 오늘도 일찍와서 카카오 바이크를 탔는데.. 가격이 변동됐다??? 기본 500원에 분당 120원씩 그전보다 600원이나??? 비싸졌다.\n\n### 노티피케이션 정리\n- 노티는 InApp 알림과, App 알림이 있다. InApp 알림은 말그대로 앱안에서 알림을 받는 것이고, App 알림은 Android나 Ios 시스템상으로 노티가 오는것이다\n- APP 노티는 firebase FCM으로 작동이 되는데 Token으로 사용자를 분류 할 수 있고 시간별로 cron job으로 설정 할 수도 있다. \n\n## 2023-06-08 09:41:00\n### 국가의 부름\n- 민방위다. 하지만 코딩은 매일 해야지.\n\n## 2023-06-07 18:29:00\n### 노티는 어려워\n- 서버 작업하는데 노티가 왜이리 어려운건지 나만 어려운건지 굉장히 복잡해서 미쳐버릴거 같다. 2개의 서버에서 FCM으로 쏘면서 mysql에 저장되는데 각 일반유져, 비즈유져(2가지) 각각에 대한 조건들을 다 설정해 줘야 한다. \n- 양방향으로 쏘는거라 to, from이 x2씩 된다. 좋은 방법이 없을까? \n  \n\n## 2023-06-06 10:12:00\n### 테니스\n- 운동신경이 없는건 알지만 맨날 느낌이 오다 말다... 이상한 운동이다. 골프도 마찬가지고... 그냥 그렇다...\n\n### 항해 파트\n- EB(ElasticBeanstalk)셋팅방법을 알려드렸다. 이번에는 윈도우다. 잊어버리기전에 적어 놓자\n1. AMD 데스크탑이었다. 가상화 설정을 CMOS 셋업에서 해줘야한다.\n2. docker desktop 설치해야한다. 에러가난다. wsl을 설치 안했단다. 설치해주자.\n3. 다운이 안된다. DNS를 8.8.8.8 로 변경하니 잘 다운이 되었다.\n4. wsl --update 해주고default를 version2로 설정해준다. 앞서 Ubuntu가 설치가 되어 있어야한다.\n5. 이제 Eb-cli를 설치 한다. ( 이미 설치가 되어 있어서 시간이 많이 줄었다.)\n6. aws 에가서 secret key랑 설정을 해준다. ~/.aws/config 에서 설정해주는걸로 안다.\n7. eb 명령어로 잘 되는지 확인한다.\n8. aws console에가서 eb 환경 설정으로 시작한다.\n9. 중요한건 두가지 ELB(elastic Load Balancer)설정, public 오픈하는 체크박스를 선택해야 한다. 그리고 배포 설정은 docker 로 한다.\n10. 소스 코드로 돌아와서 Dockerfile을 만든다. expose 3000은 잊지 말자.\n11. 대부분 실수 하는부분이 CMD [\"node\", \"app.js\"]를 할때 CMD [\"npm\", \"start\"] 할때가 있다. 이럴때는 package.json 에 설정완료가 되어 있어야한다.\n12. eb local run 으로 실행이 되는지 확인하다. \n13. eb deploy 를 한다.\n\n- 내용을 이렇게 적어놨지만 어차피 엄청난 시행착오를 감안해야할 것이다. 나는 처음에 일주일 걸렸던거 같다.\n- 정말 DevOps가 준비가 안되면 Cors, setcookie등 여러 문제가 발생한다.\n\n\n\n## 2023-06-05 06:58:00\n### 오늘은 판교에서 전기자전거 타고 출근완료\n- 일요일을 충분히 쉰덕분에 아침 일찍 일어났다. 지난 주에는 지나가면서 전기자전거를 봤는데 한번도 타보질 않아서 다음에 기회가 되면 타보려고 생각했는데 바로 오늘 시간도 널널하게 판교역 현대백화점에서 카카오바이크를 빌리고 제2판교까지 타고 왔다. 새벽바람이 약간 차게 느껴졌지만 조금 타니까 살짝 땀이 나려는 순간 바람이 식혀줘서 기분이 좋았다.\n\u003e 가격은 비쌌다. 20분정도 탄거 같은데 2200원\n\n###  위키를 조금 변경해볼까 \n- 맨날 마음만 이렇게 저렇게 해볼까 하는데 막상 안한다. 다른 몇몇 분들은 위키를 예쁘게 커스터마이징 하셨던데 나도 한번 해볼까 싶다. 일단 첫번째 단계인 MD파일을 react에서 읽을 수 있나 확인해보았다. 아래를 참조 하면 된다.\n\n- [[readMDFile]]{리액트에서 MD파일 읽기}\n\n\n\n## 2023-06-04 09:15:00\n### 나른한 일요일 아침\n- 주말에는 테니스를 치면서 평일에 있던 스트레스를 조절한다. 볼 머신기가 있는 24시간 테니스장에서 치는데 가격은 비싸지만 혼자서 조용히 연습하기가 좋다. 공 하나하나 집중하면서 치다보면 한시간은 그냥 지나간다. 이 후 스벅에서 딸기스무디 한잔을 한다음 이것저것 보면서 코딩도 하고논다.\n\n## 2023-06-03 16:27:00\n### 항해99 파트타임 오프라임 질문\n- 로컬 서버로 업로드 및 다운로드 질문 -\u003e 이 문제는 서버URL + C 드라이브의 URL을 붙여서 프론트에 보내고 있었다. 당연히 안되는 것이고 get 메소드로 해당 파일에 접근 권한을 연결시켜 줘야했다. 해결완료\n- EB셋팅 방법 -\u003e docker desktop 설치, Dockerfile 생성, 다행이도 eb-cli는 설치가 되어 있었다. 그리고 이번에 EB 콘솔이 업그레이드 되면서 굉장히 셋팅을 세세하게 할 수 있는데. 별거 없다. ELB 설정 해주고, public오픈만 체크해주면 간다한게 사용할 수 있었다. 그리고 해결 완료\n- passport 카카오톡 연결- 이것은 가이드만 해줬다. 결국엔 callback으로 refreshtoken을 받았는데 프론트와 그냥 연결만했지 실질적으로 무엇을 했는지 명확하지 않았다. 그 이후 발급된 refreshToken을 가지고 이제 서버와 비교를 하면서 인증이 되어 있는 상태이면 token(accessToken)을 발행해줘야 하는 것을 알려드렸다.\n\n## 2023-06-02 08:23:00\n### DB join \u0026 App join\n- 이 질문도 항해파트타임에서 나왔다. 그리고 오늘 아침 카톡방에 주제로 나왔다.\n- DB join은 DB에서 필요한 내용을 미리 join을 해서 처리를 한다음 백엔드로 넘기는 거고, App Join은 통으로 DB에 요청해서 오는 것을 백에서 조인 처리 하는 것이다.\n- 추가 적으로 샤딩(Sharding)이란 기법이 나온다. 대용량의 데이터를 한 테이블로 관리하게 되면 부하기 오기 때문에 각각 테이블로 나눠서 하는것인다. 두가지 방법이 있다. 가로로 나눠서 즉 컬럼을 쪼갠다. 세로로 나눠서 즉 데이터를 나눈다.\n\n\n## 2023-06-01 07:26:00\n### 지속되는 문제점 발생\n- 끝가지 마무리를 안한 상태에서 되는것만 확인하고 바로 다음 것으로 넘어가는 습관이 생긴거같다.\n- 데일리 테스크 중점적으로 관리를 하자.. 근데 중간중간 들어오는 오류부분을 고칠때는 가끔 시간이 많이 걸려서 참 애매한거 같다.\n- 그런데 내가 이미 충분하게 잘 준비를 해놨다면 문제가 생기지 않았을 것이다.\n\n### 항해 기술매니져(?)\n- 사실 1년차도 안되는 짬에서 이런것을 하는게 조금 부끄럽기도 하다. 하지만 가르침으로 인해 나도 많은것을 배울 수 있고 모르는 부분도 다른 사람들의 생각을 알수가 있어서 좋다.\n\n### VIM 찾아바꾸기\n- 자꾸 잊어버린다. \n- s -\u003e 줄만 바꾸기 예제 :s/test/test2/g -\u003e\n- %s -\u003e 전체 페이지 다 바꾸기 :%s/test/test2/g\n- 10,20s -\u003e 특정 줄에서 바꾸기 :10,20s/test/test2/g\n\n### tmux template 구성하기\n- 맨날 재부팅하거나 세션이 꺼지면 일일이 들어가야하는데 이번기회에 bash shell을 만들었다. \n\n```bash\nSESSION_NAME=\"ymyd\"\n\ntmux new-session -s $SESSION_NAME -d\ntmux send-keys \"cd /Users/semyungpark/Documents/dev \u0026\u0026 yarn run start:dev\" C-m\n\ntmux split-window -v\ntmux send-keys \"cd /Users/semyungpark/Documents/dev\" C-m\ntmux rename-window -t 1 \"ymyd-backend\"\n\ntmux new-window -t $SESSION_NAME:2 -n \"ymyd-frontend\"\ntmux send-keys \"cd /Users/semyungpark/Documents/dev \u0026\u0026 nvm use 8 \u0026\u0026 npm start\" C-m\ntmux split-window -v \ntmux send-keys \"cd /Users/semyungpark/Documents/dev/\" C-m\n\ntmux new-window -t $SESSION_NAME:3 -n \"ymyd-biz-backend\"\ntmux send-keys \"cd /Users/semyungpark/Documents/dev \u0026\u0026 yarn run start:dev\" C-m\ntmux split-window -v\ntmux send-keys \"cd /Users/semyungpark/Documents/dev/ymyd/\" C-m\n\ntmux new-window -t $SESSION_NAME:4 -n \"ymyd-frontend\"\ntmux send-keys \"cd /Users/semyungpark/Documents/dev\" C-m\ntmux split-window -v\ntmux send-keys \"cd /Users/semyungpark/Documents/dev\" C-m\n\ntmux new-window -t $SESSION_NAME:5 -n \"ymyd-aio-front\"\ntmux send-keys \"cd /Users/semyungpark/Documents/dev\" C-m\ntmux split-window -v\ntmux send-keys \"cd /Users/semyungpark/Documents/dev\" C-m\n\n#tmux new-window -t $SESSION_NAME:5 -n \"gpt\"\n#tmux send-keys \"cd /Users/semyungpark/Documents/dev\" C-m\n\ntmux new-window -t $SESSION_NAME:6 -n \"blog\"\ntmux send-keys \"vi\" C-m\n\ntmux select-window -t $SESSION_NAME:0\ntmux attach-session -t $SESSION_NAME\n```\n\n\n## 2023-05-30 07:25:00\n### 타임존에 대한 고찰\n- 지난번에 어이 없는 버그를 발경하게 되었다. 썰을 풀자면.... 기존에는 EC2로 서버가 운영되고 있다가 EB(ElasticBeanstalk)로 변경하면서 내가 서버셋팅을 KST(한국 시간 +9)으로 변경하였다. 그런데... 3개월간 노티가 제대로 안간것이었다 이유인 즉슨 cron job을 utc 기준으로 셋팅을 해놨기때문에 9시간씩 밀렸던것이다. \n- 내가 KST로 셋팅했던 이유는 내가 개발 하는 서비스는 한국 전용이고 진짜 최대 3만명을 넘기지 않는다. 단지 그 이유였다.\n- 그런데 오늘 아침 단톡방에서 mysql시간이 변경되지 않고 이상하게 저장되는 부분을 답변해줬는데 다른분꼐서 경악을 하면서 UTC로 변경하라고 답변만 하고 떠났다. 왜 물어봤지만 대답이 없어 찾아봤다. 왜 UTC로 해야하는지\n\n1. 다양한 멀티 디바이스에서 버그가 일어날수 있다.\n2. mysql에서 오프셋을 지원하지 않을 수도 있다.(오래된 글이라 확인해봐야함...)\n3. 미국 같은 어떤 주에서는 섬머타임으로 시간이 변경될 수 도 있다.\n\n- reference\n    - [레딧링크](https://www.reddit.com/r/Wordpress/comments/w2yazw/check_if_there_is_a_typo_what_should_i_do_couldnt/)\n    - [스택오버플로우](https://stackoverflow.com/a/25647094)\n    - [다른개인홈페이지](http://yellerapp.com/posts/2015-01-12-the-worst-server-setup-you-can-make.html)\n    \n## 2023-05-29 10:04:00\n### 아침형 인간\n- 출퇴근 합치면 4시간, 5시에 일어나서 준비하고 밥먹고 5시 40분정도에 집을 나선다. 그리고 나서 대략 7시20분~30분정도에 사무실에 도착한다.\n- 거의 반년이상을 이렇게 하니까 더더욱 아침형 인간이 되벼렸다. 하루가 길고 피곤하기도 하지만 최대한 컨디션을 유지하도록 노력하고 있다. 주말에는 테니스에 열중하고 있다. 적어도 아침에 7시에는 나와서 2시간정도 연습을 하고 레슨도 받고 동호회도 나간다. 그래도 하루에 절반도 안지나가서 카페에 가서 컴퓨터를 켜서 이런저런 코딩도 끄적여 보고 졸다가 내가 좋아하는 딸기스무디도 먹는다. \n\u003e 뭐 만족하고 있다.\n\n## 2023-05-28 22:18:00\n### Nestia 사용해보자\n- 알고는 있었는데 굉장히 유용한거 같다. \n- 한줄로 정리하면 NestJs에서 Dto class를 사용하지 않고 interface를 사용하는데 그 상태를 그대로 배포를 한다음 프론트에서 라이브러리를 받아서 Api를 사용하는 것이다.\n- 한줄로 하긴 긴거 같지만 결국엔 Type이변경이 되어도 프론트에서는 바로 바로 에러가 발생해서 변경할 수 있도록 하는거 같다.\n- 일단 써봐야겠다.\n\n## 2023-05-28 09:09:00 \n### 밀려있던 일기를 조금씩 써본다.\n- 하루에 하나씩만 적자.. 너무 밀렸다.. ㅠㅠ\n- 시간 순서는 일단 기억이 안나니까 노션을 확인하면서 체크를 하면서 정리해야겠다.\n  - 쿠키 설정이 나를 미치게 한다. 다시한번 정리해야 잊어버리지 않을거 같다.\n  - 두번째 프로젝트를 진행하고 있다.\n  - 항해 플러스를 시작하게 되었다. (대용량 처리 및 TDD)\n  - \n  - EC2 -\u003e Docker EB(ElasticBeanstalk) 마이그레이션 완료\n  - DeadLock 문제 해결\n  - Isolation Level에 대해서 알게됨 solation level변경\n    - Repeatable-read → read-commited\n    - 1차적으로 해결은 했다. 하지만 추후에도 DeadLock 에러가 발생해서 Procedure 구문들을 없앴다.(내가 하려했지만 시간이 없었다....)\n  - Index 설정을 배워서 굉장한 퍼포먼스 성능을 이끌었다.\n\n\n\n## 2023-01-21 22:39:11\n### 벌써 2023년.... \n- 해야될게 너무 많은데...\n\n\n## 2023-01-12 13:00:00\n### DeadLock과 알수없는 트랙픽 해결\n- \n\n\n"])</script><script>self.__next_f.push([1,"a:T760,* TOC\n{:toc}\n\n# Array 개념과 APIs \n## Delarartion \n```javascript\n\nconst arr1 = new Array()\nconst arr2 = [1,2]\n\n//2. Index posistion\nconst fruits = ['apple', 'banana' ]\nconsole.log(fruits)\nconsole.log(fruits.length) /// 2개\nconsole.log(fruits[0]) //apple\nconsole.log(fruits[1]) //banana\nconsole.log(fruits[3]) //undefined\nconsole.log(fruits[fruits.length -1]) //마지막 익덱스\n\n//3. Looping over an array\n//print all fruits\n// a. for\n\nfor (let i=0; i \u003c fruits.length; i++){\n    console.log(fruits[i])\n}\n\n\n//b. for of\nfor(let fruit of fruits){\n    console.log(fruit)\n}\n\n\n//c. forEach\nfruits.forEach((value) =\u003e console.log(value))\n\n\n//4. Addition, Deletion, copy\n//push :add an item to the end\nfruits.push('strawberry', 'peach')\nconsole.log(fruits)\n\n//pop : remove an item from the end\nfruits.pop()\nfruits.pop()\nconsole.log(fruits)\n\n\n//unshift :add an item to the beginning\nfruits.unshift('strawberry', 'lemon')\nconsole.log(fruits)\n\n\n//shift: remove an item from the beginning\nfruits.shift() // 느림\nfruits.shift()\nconsole.log(fruits)\n\n//splice : remove an item by index position\nfruits.push('strawberry', 'peach', 'lemon')\nconsole.log(fruits)\nfruits.splice(1, 1) // 1부터 1까지 지워짐 \nconsole.log(fruits)\nfruits.splice(1, 1, 'apple', 'watermelon') // 1부터 1까삽입까지 가능함 \nconsole.log(fruits)\n\n\n//comine two arrays\nconst fruits2 = ['pear', 'apple']\nconst newFruits = fruits.concat(fruits2)\nconsole.log(fruits)\n\n\n\n// 5. searching\n// find the index\nconsole.log(fruits)\nconsole.log(fruits.indexOf('apple'))\nconsole.log(fruits.indexOf('watermelon'))\nconsole.log(fruits.indexOf('watermelon')) //없으면 -1 반환\n\n// includes\nconsole.log(fruits.includes('watermelon'))\nconsole.log(fruits.includes('watermelon'))\n\n// lastIndexof\n// 제일 마지막에 있는 인덱스를 가져옴\n\nfruits.push('apple')\nconsole.log(fruits.lastIndexOf('watermelon'))\n\n\n```\n\n\n\n\n\nb:Tc52,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 5장 Arrow Function\n* 기본적인 빌딩 블럭\n* 여러번 사용가능\n* 작업을 수행 또는 값을 계산\n\n## Function declartion \n- function name(param1, param2){ body... return}\n    * 하나의 함수에서는 하나만 해라\n    * 이름은 동작하는 작업의 이름으로\n    * 함수는 객체이다\n    * e.g. createCardnadPoint -\u003e createCard, createPoint\n\n```javascript\nfunction printHello() {\n    console.log('Hello')\n}\nprintHello()\n\n\nfunction log(message){\n    console.log(message)\n}\n\n// 자바스크립에서는 형이 뭔지 모름 \n// 형을 알기 위해 typescript를 사용함 -\u003e babel \nlog('hello@')\nlog(1234)\n```\n\n```javascript\n// 2. Parameters\n// premitive parameters: passed by value\n// object parameters: passed by reference\nfunction changeName(obj){\n    obj.name = 'coder'\n}\n\nconst me = {name: 'me'}\nchangeName(me)\nconsole.log(me) // coder\n// 객체의 주소값에 있는 값을 변경해주기때문에 변경 가능\n\n```\n```javascript\n// 3.Default Parameters\n\nfunction showMessage(message, from='unkown'){\n    if(from === undefined){\n        ....\n    }\n}\n\n```\n\n\n\n```javascript\n// 4.Rest Parameters(added in ES6)\nfunction printALl(...args){\n    for(let i=0,i \u003c args.length; i++){\n        console.log(args[i])\n    }\n    for (const arg of args) {\n        console.log(arg)\n    }\n    \n    args.forEach((arg) =\u003e console.log(arg))\n}\n\nprintAll('dream, 'coding', 'ellie')\n\n```\n\n```javascript\n// 5. Local scope\nlet globalMessage = 'global' // global variable\nfunction printMessage(){\n    let message = 'heelo'\n    console.log(message)\n    console.log(globalMessage)\n}\nprintMessage()\n\n```\n\n\n\n```javascript\n// 6. Return a value\n\nfunction sum(a,b){\n    return a + b\n}\n// return 없으면 undefined\n\n\n```\n\n\n\n```javascript\n// 7. Early return, early exit\n// 조건이 맞지 않는 경우 빨리 리턴하라\n\n\n// bad \nfunction upgradeUser(user){\n    if (user.point \u003e 10 ){\n        // long upgrade logic\n    }\n}\n\n// good\nfunction upgradeUser(user){\n    if(user.point \u003c= 10){\n        return\n    }\n    //long upgrade logic\n}\n\n```\n\n## function expression\n\n```javascript\nprint() // Error\n\nconst print = function () { // annoymous function \n    console.log('print')\n}\n\nprint()\nconst printAgain = print\nprintAgain()\nconst sumAgain = sum\nconsole.log(sumAgain(1,3))\n\n```\n\u003e 함수 선언하는것과 변수에 함수를 선언하는것의 가장 큰 차이점은 `호이스트` 이다\n\n\n## call back hell\n\n```javascript\n//call back function \nfuction randomQuiz(answer, printYes, PrintNo){\n    if (answer === 'love you'){\n        printYes()\n    } else {\n        printNo()\n    }\n}\n\n\nconst printYes = function() {\n    console.log('yes')\n}\nconst printNo= function() {\n    console.log('No')\n}\n\nrandomQuiz('wrong', printYes, printNo)\nrandomQuiz('love you', printYes, printNo)\n\n```\n\n\n## Arrow Function\n\n```javascript\n\n\nconst simplePrint = () =\u003e console.log('simplePrint')\nconst add = (a, b) =\u003e a + b \n// 위와 같다\nconst add = function(a,b) {\n    return a + b\n}\n\n```\n\u003e 차이점은? \n\n\n## IIFE\n\n```javascript\n//바로 호출하고 싶으면아래와 같이 사용하라\n\n(function hello(){\n    console.log('IIFE')\n})()\n\n)\n\n\n\n```\n\n"])</script><script>self.__next_f.push([1,"c:T6c1,* TOC\n{:toc}\n\n# async or defer \n```javascript\n# filename : main.js\nconsole.log(\"hello world\")\n```\n\nconsole에서 node로 실행 가능\n```bash\n$ node main.js\nhello world\n```\n\n\n## async\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n    \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\" /\u003e\n        \u003ctitle\u003eDocument\u003c/title\u003e\n        \u003cscript async src=\"main.js\"\u003e\u003c/script\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv\u003e\u003c/div\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n```\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n    \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\" /\u003e\n        \u003ctitle\u003eDocument\u003c/title\u003e\n        \n       //빨리 받는 순서로 미리 받고\n       //a b c 순서대로 읽지 않는다\n        \u003cscript async src=\"a.js\"\u003e\u003c/script\u003e\n        \u003cscript async src=\"b.js\"\u003e\u003c/script\u003e\n        \u003cscript async src=\"c.js\"\u003e\u003c/script\u003e\n        \n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv\u003e\u003c/div\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n```\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n    \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\" /\u003e\n        \u003ctitle\u003eDocument\u003c/title\u003e\n        \n        //미리 3개다 읽고 순서대로 불러온다\n        // a -\u003e b -\u003e c\n        \n        \u003cscript defer src=\"a.js\"\u003e\u003c/script\u003e\n        \u003cscript defer src=\"b.js\"\u003e\u003c/script\u003e\n        \u003cscript defer src=\"c.js\"\u003e\u003c/script\u003e\n        \n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv\u003e\u003c/div\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n```\n\n\n## Use strict\n\u003e왜 써야하는가?\n\n유연한 언어로 많은 실수가 할 수있다.\n\nadded ECMAScript 5\n\n\n```javascript\n'use strict':\n\nconsole.log(\"Hello WOrld\")\n\n```\n\n\n\n\n\n한줄씩 읽는다\nscript 태그가 있으면 내용물을 읽고 계속 진행한다\n만약 js 파일 크다면 사이트 로딩이  \n\n\n\n\n##ref \n* [mozilla](https://developer.mozilla.org)\n* [엘리강의](https://www.youtube.com/watch?v=tJieVCgGzhs\u0026list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2\u0026index=2)\nd:Tb96,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 👍 챕터 4에서 말하고자 하는 내용\n\n\u003e 불을 키다 = 1\n\u003e 불을 끄다 = 0\n\u003e\n \u003e 즉 CPU의 작동원리를 이해하라.\n\n- 챕터 1,2,3에서는 모스부호를 이용해서 서로 이해할 수 있는 **통신규약**을 만들어 상호 작용을 할 수 있는 방법을 알려줬다.\n- 챕터 4에서는 전기신호를 가지고 불을 키고(1) 끄는(0) 방식을 이용하여 서로 상호 작용을 할 수 있는 방법을 제시한다.\n- 전압(V), 전류(I), 저항(R)을 이해하자.\n\n## 🙇‍♂️  모스부호는 어렵다. \n\n\n\u003e 불이 켜지면 1, 꺼지면 0 으로 통일하자 우리는 CPU와 상호 작용을 하고 싶다.\n\u003e\n\u003e 전자가 이동하는 원리를 이용해 CPU와 **통신을** 하고 싶은거다.\n\n## ❔ 기계를 이해시켜라.\n\n\n\u003e 생각해보자 건전지가 수명을 다해서 불이 희미하게 켜진다. 이럴때는 우리가 정해놓은 0과 1중 어떤것으로 분류해야할까?\n\u003e\n\u003e \u003e 사람은 시각으로 빛이 들어오기때문에(입력) 이것이 1이라는 것이라고 생각할 수 있다.\n\n**하지만 `CPU는`?**\n\n아쉽지만 CPU는 우리가 생각한것보다 똑똑하지 않다.\n\n그러므로 CPU가 이해 할 수 있도록 전자를 잘 다루어 이해 시키도록 해야한다.\n\n\n## ⭐ 1과 0을 구별하라\n\n일정한 볼트를 유지하면 1과 0을 확실하게 구별할 수 있다. (0v 또는 5v)\n\n\u003e 일정한 볼트를 유지하려면?\n\n**전류와 저항을 잘 컨트롤해야한다!**\n**따라서 옴의 법칙을 잘 알아야한다.**\n\n## P = E \\* I\n\n  \u003e P = power in `watts` \u003c와트\u003e\n  \u003e\n  \u003e E = emf in `volts` \u003c\u003e\n  \u003e\n  \u003e I = current in `amperes`\n\n `위 내용은 참고만하자` \n\n## V = I \\*R \n\n  \u003e V = `Volts` \u003c전압\u003e \n  \u003e\n  \u003e I = `Current Flow` \u003c전류\u003e\n  \u003e\n  \u003e R = `Resistance` \u003c저항\u003e\n  \n\n  - 저항 : 파이프 속의 흐름을 막는 것 ( 옴)\n  - 전류 : 파이프 속의 어느 한 지점에서 다닐 수 있는 물의 양 ( 암페어 )\n  - 전압 : 파이프 속의 물의 속도 ( 볼트 )  \n## ❓ 용어 정리\n\n\u003e1. 원자\n\u003e    - 우리가 보고 만질 수 있는 모든 것을 원자라고 한다. \n\u003e2. 전자\n\u003e   - 원자핵 주변에서 떠돌고 있는 것. \n\u003e   - 전자가 일정한 간격으로 원자핵 주변을 돌며 일정 전자수를 유지하려 한다. \n\u003e3. 전하 \n\u003e  - 양자 = (+)\n\u003e  - 전자 = (-)\n\u003e4. 건전지의 구조\n\u003e  - 음극 : 전자를 발생 -\u003e 출발 \n\u003e  - 양극 : 전자를 요구 -\u003e 도착 \n\u003e5. 직렬\n\u003e    - 건전지를 일직선으로 연결 \u003e 1.5v + 1.5v  = 3.0v  \n\u003e6. 병렬\n\u003e    - 건전지를 1 1 자로 연결 \u003e 1.5v and 1.5v = 1.5v \n\u003e7. 전도성\n\u003e   - 전자가 쉽게 떨어져 나가서 이동 할 수 있는 물체 ( 전선, 구리, 철)\n\u003e8. 비전도성\n\u003e   - 전자가 떨어져 나갈 수 없는 물체 (고무, 공기 등...)\n\u003e9. 반도체\n\u003e   - 말그대로 반쯤 통한다. 즉 전자를 잘 다니게 또는 전자를 못다니게 할 수 있다. (CPU 칩셋)\n"])</script><script>self.__next_f.push([1,"e:T1909,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 논리게이트란? \n* 전기를 입력받아 스위치를 이용해서 다양한 출력 방법을 구연할 수 있다\n\n* 11장에서 알아야 할점 \n1. 게이트의 종류 특성 \n2. 릴레이와 스위치의 차이점\n3. 게이트의 표현방법 ( 논리식, 기호, 진리표)\n4. 드모르간의 법칙\n\n\n\n## 게이트\n\n\u003e\n![image](https://user-images.githubusercontent.com/56494905/159281773-6555f7a9-0268-46b3-84b1-323eddc0f82c.png)\n\n\n\n## 논리곱과 논리합\n\u003e * OR\n\u003e `A + B = A` `b = A` 또는 `B`\n\n\n\u003e * AND \n\u003e `A x B = A` `b = A` 와 `B` \n\n## 게이트의 종류\n### `AND 게이트`\n* 가장 기본적인 게이트로 두개의 입력값이 1이 되어야 결과값도 1이 된다 \n$$ Y = A  \\times B \\\\\n Y = A \\cdot B\\\\ \n Y = AB $$\n\n* 기호\n\n![image](https://user-images.githubusercontent.com/56494905/159424649-0e2b9119-384a-405c-97d4-27c74bb2f025.png)\n\n* 진리표\n \n| Input A | Input B | Ouput Y |\n| :-:     | :-:     | :-:    |\n| 0       | 0       | 0      |\n| 0       | 1       | 0      |\n| 1       | 0       | 0      |\n| 1       | 1       | 1      |\n\n--------------------------\n### `OR 게이트`\n* 입력값이 하나라도  1이 되면 결과값도 1이 된다.\n$$ \\\\ Y = A + B $$\n\n* 기호\n \n![image](https://user-images.githubusercontent.com/56494905/159424792-cfbf6ab3-1eec-4087-af0b-a7c38c56d632.png)\n\n* 진리표\n\n| Input A | Input B | Ouput Y |\n| :-:     | :-:     | :-:    |\n| 0       | 0       | 0      |\n| 0       | 1       | 1      |\n| 1       | 0       | 1      |\n| 1       | 1       | 1      |\n\n--------------------------\n### `NOT 게이트` \n* 1일 들어가면 부조건 0 , 0이 들어오면 1\n$$ \\\\ Y = A + B $$\n\n* 기호\n\n![image](https://user-images.githubusercontent.com/56494905/159424844-d8cba4e4-9423-4e76-98e8-0df3f3d4b69e.png)\n\n* 진리표\n\n| Input A | Ouput Y |\n| :-:     | :-:    |\n| 0       | 1      |\n| 1       | 0      |\n\n--------------------------\n### `Buffer 게이트`\n* 입력된 정보를 그대로 출력\n$$\\\\ Y = A $$\n\n* 기호\n\n![image](https://user-images.githubusercontent.com/56494905/159601277-10179f5d-924c-40ae-ac56-344e5dc015d6.png\n)\n\n* 진리표\n\n| Input A | Ouput Y |\n| :-:     | :-:    |\n| 0       | 0       |\n| 1       | 1      |\n\n--------------------------\n\n### `NAND 게이트`\n\n* NOT + AND 즉 AND의 부정\n$$ \\\\ Y = \\overline{A \\cdot B}  $$\n\n* 기호\n\n![image](https://user-images.githubusercontent.com/56494905/159453967-7d1d322d-5ebe-49b7-9865-70db0d995446.png)\n\n* 진리표\n\n| Input A | Input B | Ouput Y |\n| :-:     | :-:     | :-:    |\n| 0       | 0       | 1      |\n| 0       | 1       | 1      |\n| 1       | 0       | 1      |\n| 1       | 1       | 0      |\n\n\n--------------------------\n### `NOR 게이트`\n\n* NOT + OR 즉 OR의 부정\n$$ \\\\ \\overline{A \\cdot B} $$\n\n\n* 기호\n\n\u003e![image](https://user-images.githubusercontent.com/56494905/159454332-ae46a968-bf2f-47d1-84e9-454eff7a4028.png)\n\n* 진리표\n\n\n| Input A | Input B | Ouput Y |\n| :-:     | :-:     | :-:    |\n| 0       | 0       | 1      |\n| 0       | 1       | 0      |\n| 1       | 0       | 0      |\n| 1       | 1       | 0      |\n\n--------------------------\n### `XOR 게이트`\n\n* 입력신호가 모두 같으면 0, 한개라도 틀리면 1출력\n$$ \\\\ Y = A \\oplus B \\\\ \nY = \\overline{A}B + B\\overline{B}\n$$\n\n* 기호\n\n\u003e![image](https://user-images.githubusercontent.com/56494905/159454370-413b39b6-ee3b-4768-bd3b-183a54fe8af2.png)\n\n* 진리표\n\n| Input A | Input B | Ouput Y |\n| :-:     | :-:     | :-:    |\n| 0       | 0       | 0      |\n| 0       | 1       | 1      |\n| 1       | 0       | 1      |\n| 1       | 1       | 0      |\n\n\n--------------------------\n### `XNOR 게이트`\n\n* Not + XOR 즉 XOR의 부정\n$$ \\\\ Y = A \\odot  B \\\\ \nY = A \\oplus B \\\\\nY = AB + \\overline{A}\\overline{B}\\\\\n$$\n\n\n* 기호\n\n\u003e![image](https://user-images.githubusercontent.com/56494905/159454394-ec096680-3910-4e5d-b5a4-282caeebbd44.png)\n\n* 진리표\n\n| Input A | Input B | Ouput Y |\n| :-:     | :-:     | :-:    |\n| 0       | 0       | 1      |\n| 0       | 1       | 0      |\n| 1       | 0       | 0      |\n| 1       | 1       | 1      |\n\n\n--------------------------\n\n\n## 스위치와 릴레이의 차이점 \n\n|        공통점        |                          차이점                          |\n|          -           |                            -                             |\n| 전력을 공급 차단한다 | 릴레이는 다른 라인의 전력을 `자동`으로 컨트롤 할 수 있다 |\n|                      |          스위치는 직렬연결로 전력을 컨트롤한다           |\n\n\n\n|        | 장점                                                 | 단점                                         |\n| -      | -                                                    | -                                            |\n| 릴레이 | 낮은 전력으로 다른 입력 전압전류를 컨트롤 할 수 있다 | 복잡한 구조를 이해하고 릴레이에 따라 Spec이 다르다.                                             |\n| 스위치 | 단순해서 설치 및 이용이 편리하다                     | 연결된 부분에 전기를 단순 컨트롤밖에 못한다. |\n\n\n\n\u003e 스위치과 같은 역할이다. 다만 작은 전류를 통해서 큰전류를 통제하는 스위치다\n\n릴레이는 쉽게 말해 ON, OFF가 있는 일종의 '스위치' 입니다.\n\n하지만 우리가 일반적으로 알고있는 불을 켜고 끌때 누르는 스위치와는 `동작원리`가 다릅니다.\n\n우리가 일반적으로 접하는 스위치는 수동'으로 ON, OFF 해주지만, 릴레이는 '자동'으로 ON,OFF 할 수 있게끔 í´주는 전자부품 입니다. \n\n조금 더 전문적으로 말하자면, 별도로 분리되어 흐르는 전기를 스위칭할 수 있는 신호 또는 펄스를 만들어 줍니다. \n이러한 릴레이는 작동하기위해 필요한 전압은 낮지만, 입력될 수 있는 전압은 높습니다.\n\n그렇기 때문에 릴레이는 흔히 낮은 전압/전류를 이용하여 더 높은 전압/전류를 제어하는데에 많이 사용합니다.\n\n\n## 논리회로\n\u003e논리회로란 논리연산을 통해 전기 장치를 제어하는 통로\n![image](https://user-images.githubusercontent.com/56494905/159283479-fcc317c9-3a2f-46f9-9877-9097f0e69c54.png)\n\n## 드모르간의 법칙\n$$ \\overline{A}\\times\\overline{B}=\\overline{A + B} \\\\\n    \\overline{A} + \\overline{B} = \\overline{A \\times B} $$\n\n\n\n\n\n"])</script><script>self.__next_f.push([1,"f:Td20,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# class 와 object \n- class은 틀만 만들고 (메모리에 저장안되)\n- object는 틀을 가지고 실제 다양한 종류의 데이터를 저장한다\n\n## 'use strict' in ES6\n// Object-oriented programming\n// class : template\n// object : instance of a class\n// JavaScript classes\n//  - introduced in ES6\n//  - syntactical sugar over prototype-based inheritance\n\n\n\n## class\n```javascript\nclass Person {\n    // constructor\n    constructor(name, age){\n    //fields\n    this.name = name\n    this.age = age\n    }\n\n    speak(){\n        console.log(`${this.name}: hello!`)\n    }\n}\n\n\nconst me = new Person('me', 20)\nconsole.log(me.name)\nconsole.log(me.age)\n```\n\n\n```javascript\n//getter\n//setter\n\nclass User {\n    constructor(firstName, lastName, age){\n        this.firstName = firstName\n        this.lastName = lastName\n        this.age = age // setter 에 age를 불러온다\n    }\n    \n    get age() { \n        return this._age // 상위 prototype 에서 this.age를 계속 가져오려고 하기 떄문에\n        // 그래서 _age라는 다른 변수명을 사용한다\n    }\n    \n    set age(value) {\n        this._age = value\n        this._age = value \u003c 0 ? 0 : value\n    }\n}  \n\n\n* Fields (public, private)\n```javascript\nclass Experiemnt{\n    publicField = 2\n    #privateField = 0  //class 내부에서만 값을 읽고 쓰고 할 수 있다\n}\n\nconst experiment = new Experiemnt()\nconsole.log(experiment.publicField) // 실행가능\nconsole.log(experiment.privateField) //실행 불가능 -\u003e undefined\n```\n\n\n* Static\n\n```javascript\nclass Article {\n    static pulisher = 'dream coding'\n    constructor(articleNumber){\n        this.articleNumber = articleNumber\n    }\n    \n    static printPublisher(){\n        console.log(Article.publisher)\n    }\n}\n\nconst aritcle1 = new Article(1)\nconst article2  = new Article(2)\n\nconsole.log(Article.publicsher) //클래스 함수에 내장하는 함수로 인스턴스에서는 포함이 안된다\nconsole.log(article1.printPublisher) // undefined\nArticle.printPublisher()\n```\n\n* inheritance 상속 \n\n```javascript\n\nclass Shape{\n    constructor(height, width, color){\n        this.height = height\n        this.width = width\n        this.color = color\n    }\n    \n    draw() {\n        console.log(`drawing ${this.color} color of`)\n    }\n    getArea() {\n        return width * this.height \n    \n    }\n}\n\nclass Rectangle extends Shape {} // Shape 에 있는 내용을 그대로 가져 올 수 있음\nclass Triangle extends Shape {\n    draw() {\n        super.draw() // 부모에 있는 내용을 그대로 져올 수 있음\n        console.log('*')\n    }\n    getArea(){\n        return (this.width * this.height) /2\n    }\n    \n    \n    toString() {\n       return `Triangle color: ${this.color} ` \n    \n    }\n\n} // Shape 에 있는 내용을 그대로 가져 올 수 있음\n\n\nconst rectangle = new Rectangle(20, 20, 'blue')\nrectangle.draw()\nconst triangle = new Triangle(20, 20, 'red')\n```\n\n## Class checking: instanceOf\n```javascript\nconsole.log(rectangle instanceof Rectangle)\nconsole.log(triangle instanceof Rectangle)\nconsole.log(triangle instanceof Triangle)\nconsole.log(triangle instanceof Shape)\nconsole.log(triangle instanceof Object)\ncosnoel.log(triangle.toString())\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n아까 이야기 했던것은...  객체를 비교할 수 있나?\n프로토 타입에 관한 내용을 정리하자\n"])</script><script>self.__next_f.push([1,"10:T608,* TOC\n{:toc}\n\n# DFS (Depth Fisrt Search) 깊이 우선 탐색 \n* Graph와 stack을 이용한 최단거리 찾기 문제?\n\n## 그래프 순회\n* 그래프의 각 정점을 방문하는 `그래프 순회(Graph Traversals)` 에는 크게 `깊이 우선 탐색(Depth First Search)`과 `너비 우선 탐색(Breadth-First Search)`의 2가지 알고리즘이 있다\n\n- DFS\n    * 주로 `스택`이나 `재귀`로 구현\n    * 백트래킹으로 구현시 효율이 좋다\n    \n- BFS\n    * 주로 `큐`로 구현\n\n\n## 그래프를 포현하는 방법\n* 인접 행렬(Adjacency Matrix)\n    \n- 인점 리스트(Adjacency List)\n\n    ![image](https://user-images.githubusercontent.com/56494905/161710801-d9868256-850c-4a18-85ad-a933a7a4c647.png)\n\n\n```python\n# dictonary 로 표현하면 아래와 같다\ngraph = {\n    1 : [2,3,4],\n    2 : [5],\n    3 : [5],\n    4 : [],\n    5 : [6,7],\n    6 : [],\n    7 : [3],\n}\n```\n\n## 재귀로 구현 (Recursion) \n\n```python\ngraph = {\n    1 : [2,3,4],\n    2 : [5],\n    3 : [5],\n    4 : [],\n    5 : [6,7],\n    6 : [],\n    7 : [3],\n}\n\ndef recursive_dfs(v, discovered=[]):\n    discovered.append(v)\n        for w not in discovered:\n            discovered = recursive_dfs(w, discovered)\n        return discovered\n```\n\n## 스택으로 구현(Stack)\n\n```python\ndef iterative_dfs(start_v):\n    discovered = []\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        if v not in discovered:\n            discovered.append(v)\n            for w in graph[v]:\n                stack.append(w)\n    return discovered\n```\n\n11:T5d6,* TOC\n{:toc}\n\n# Docker compose란?\n- Docker compose 는여러개의 Dockerfile를포함하고 그걸 컨트롤 하는 Dockerfile의 부모격이다.\n- docker compose로 세세한 각 dockerfile에 대한 셋팅을 할 수 있고 docker cli로 실행하는 동일한 방식을 스크립트로 만들어 실행 할 수 있다.\n\n## Docker compose를학습하기 전에 알아야할 내용\n- 기본적인 docker의 작동원리\n- dockerfile의 작동원리\n- 기본적인shell command \n- 버"])</script><script>self.__next_f.push([1,"전 충돌에 대한 내용(원영님이 잘 정리했다.)\n    * [링크](https://choewy.github.io/gitbook/issue/3)\n\n\n\n## 초기 셋팅\n- 원하는 프로젝트 이름으로 폴더를 생성\n- 그안에 docker-compose.yml 생성 후 원하는 dockerfile를 다시 자식 폴더에 넣고 필요한 셋팅파일들을 구조화 하고 넣는다\n\n```bash\n- docker-compose.yml\n- nginx\n    - Dockerfile\n    - nignx.conf\n- nestserver\n    - Dockerfile\n    - src\n- nodeserver\n    - Dockerfile\n    - index.js\n```\n\u003e 도커 컴포즈를 구성할때는 루트 폴더에 docker-compose.yml 파일이 있고 각 하위 폴더에 각각 Dockerfile을 검색하여 하나씩 docker로 구성된다.\n\n\n## \n\n\n## docker compose network\n- none\n- bridge\n- maclan\n- local\n\n\n## Docker compose 기본\n```docker\nweb:\n    build: .\n    ports:\n        - \"5000:5000\"\n    volumes:\n        - .:/code\n    links:\n        - redis\nredis:\n    images: redis\n```\n\n\n\n## reference\n- [참고 사이트](https://engineer-mole.tistory.com/221)\n\n\n\n12:T775,* TOC\n{:toc}\n\n# Dockerfile 설정방법\n## Dockerfile을 습득하기 앞서 필요한 내용\n- 기본적인 shell command\n- Docker의 기본적인 구조 및 사용방법(image, container)\n\n\n \n## 매커니즘\n- 폴더를 생성 후 Dockerfile 을 만든 후에 스크립트를 넣으면 안에 있는 모든 파일을 읽으며 docker image파일이 생성된다.\n\n## 스크립트 명령어\n- FROM : 베이스가 될 도커 이미지 \u003c이미지 이름\u003e:\u003c태그\u003e \n- MAINTAINER : 작성자 정보\n- CMD : Shell Script 를 실행할 수 있다.\n- LABEL : 라벨 작성 (docker inspect 명령으로 label을 확인 가능) \n- EXPOSE : 호스트와 연결할 포트 번호를 설정한다.(도커내부로만 가능 외부는 portforwarding 해줘야함)\n- ENV : 환경변수 설정\n- ADD : 파일 / 디렉터리 추가\n- COPY : 파일 복사\n- ENTRYPOINT : 컨테이너가 시작되었을때만 스크립트 실행\n- VOLUME : 볼륨을 마운트 (내컴퓨터에 스토리지를 연결)\n- USER : 명령 실행할 사용자 권한 지정\n"])</script><script>self.__next_f.push([1,"- WORKDIR : \"RUN\", \"CMD\", \"ENTRYPOINT\" 명령이 실행될 작업 디렉토리\n- ARG : Dockerfile 내부 변수\n- ONBUILD : 다른 이미지의Base Image로 이는 경우에 실행될 명령 수행\n- SHELL : default shell 지정\n\n\n## 기본 Dockerfile 스크립트\n```Dockerfile\nFROM ubuntu:20.1\n//도커이미지 우분투20.1을 사용(local에 해당 이미지가 없으면 자동다운 )\n\nRUN apt-get update \u0026\u0026 apt-get install -y vim apache2\n// shell script명령어로 초기 apt update후 vim 과 apache를 설치\n\nCOPY index.html /var/www/html/\n//Dockerfile에 같이 있는 index.html 파일을 apache  root 폴더인/var/www/html/ 에 넣는다\n\nCMD [\"/usr/sbin/apachectl\", \"-D\", \"FOREGROUND\"]\n//shell script명령어로 apache 실행 명령어 옵션에 -D를 넣고 실행\n```\n\n## reference\n- [참고사이트](https://blog.d0ngd0nge.xyz/docker-dockerfile-write)\n\n13:T9ac,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 가장 큰 차이점 \n\n\n\n## for...in\n-    \n\u003e The for...in statement iterates over all enumerable properties of an object that are keyed by strings (ignoring ones keyed by Symbols), including inherited enumerable properties.\n\n\n* 왜for...in을 사용할까?\n    - for...in 은 연속적인 객체 프로퍼티를 위해 만들어졌다 그러나 배열을 위해 쓰기는 추천하지 않는다. for each가 이미 있기때문이다. \n    - 디버깅때 목적으로 많이 쓸것이다. 객체의 프로퍼티를 체크하는데 쉬울것이다. 그래도 배열은 데이터를 저장하는 많이 사용한다 (key-value 방식의 데이터) \n\n\n\u003eWhy Use for...in?\n\u003eGiven that for...in is built for iterating object properties, not recommended for use with arrays, and options like Array.prototype.forEach() and for...of exist, what might be the use of for...in at all?\n\u003eIt may be most practically used for debugging purposes, being an easy way to check the properties of an object by outputting to the console or otherwise. Although arrays are often more practical for storing data, in situations where a key-value pair is preferred for working with data with properties acting as the key, there may be instances where you want to check if any of those keys hold a particular value.\n\n\n\n## for...of\n* for...of 정의\n    * for...of 는 반복적이고 나열가능한 객체(문자열, 배열, array-liked objects(Nodelist), TypedArray, Map, Set 그리고 사용자지정 iterables)\n    \nString, array, array-linked objects(NodeList), TypedArray, Map, Set, and user-defined iterables.\n\n\u003e The for...of statement creates a loop iterating over iterable objects, including: built-in String, Array, array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object.\n\n\n## Symbol 형\n* 특징\n    - 객체의 프로퍼티 키로 무낮형과 심볼형을 사용한다\n    - 이때 어떤 객체의 프로퍼티의 키가 symbol이어야만 for...of가 사용될 수 있다\n\n## iterable 객체\n* 반복 가능한(iterable, 이터러블) 객체는 배열을 일반화한 객체이다. 이터러블 이라는 개념을 사용하려면 for...of를 사용할 수 있다\n\n\n\n\n\n\n# 참고사이트\n* [모질라 공식사이트](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)\n\n\n\n\n"])</script><script>self.__next_f.push([1,"14:T37a0,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# Data Privacy?\n\u003e Privacy란 개인의 사생활이나 집안의 사사로운 일 또는, 그것이 남에게나 사회에 알려지지 않으며 간섭받지 않는 권리.\n\n## 왜 데이터의 privacy가 중요한가?\n\n* 범죄에 사용 될 가능성이 있고 사용자를 교란 및 괴롭힐 수  도 있다\n* 개인정보가 유출되면 원하지 않는 광고들을 많이 받을 수 있다 \n* 개인의 사생활을 추적할 수 있어, 언제나 추적 감시 대상이 될 수 있다\n* 또한 기업의 중요 문서 등이 탈취되면 기업에 기술 및 가치를 탈취 당할 수 있다 \n\n\n# http vs https\n## `http`(HyperText Transfer Protorcol)\n\n* HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. [^protocol]\n* 모든 데이터 교환의 기초\n* 클라이언트-서버 프로토콜(통신규약)\n* 텍스트 기반의 통신 규약으로 `인터넷에서 데이터를 주고받을` 수 있는 프로토콜이다.\n    ![image](https://user-images.githubusercontent.com/56494905/159731726-9ef04fce-62c0-4a72-bee9-fef8e382f7cb.png){:width=\"80%\", align=\"center\"}\n\n## `https`(HyperText Transfer Protocol over Secure Socket Layer )\n* http 기반에 `SSL`을 추가 보완한 프로토콜\n\n    ![image](https://user-images.githubusercontent.com/56494905/161882125-1095a3bf-632c-4d3f-80e4-f01ff34102b8.png)\n\n## http/https 비교\n\n| 차이점            | http     | https                    | 설명                                                   |\n| -                 | :-:      | :-:                      | -                                                      |\n| 보안성            | 낮음     | 높음                     | 상대적으로 https가 보안성 측면에서 높다                |\n| 사용계층          | 응용계층 | 전송계층과 응용계층 사이 | SSL/TLS 가 중간에 위치하여 한번더 체크를 한다          |\n| 사용포트          | 80       | 443                      | 443 포트로 먼저 certificate 을 확인 후 통신한다        |\n| 전달데이터 암호화 | No       | Yes                      | https는 암호화 되서 전송된다                           |\n| 속도              | 빠름     | 상대적으로 느림          | 상대적으로http보다  https가 더 느리다(Handshake때문에) |\n\n\n\n# TLS/SSL\n## TLS(Transport Layer Security)\n- TLS 특징\n    * 클라이언트와 서버의 암호화 정보 교환을 목적을 두고 1999년 개발되었다\n    * TLS는 웹뿐만아니라 이메일, 메세지,  VoIP 등 에 쓰인다\n    * 최신버전인 TLS 1.3  2018년에 나왔다\n    * 기존 버전의 암호화 프로토콜인 `SSL`을 포함하고 있다\n    * `대칭키 암호`[^symmetric-key-algorithm]을 사용하여 암호화한다\n\n\n## SSL(Secure Socket Layer) \n\u003e SSL or Secure Sockets Layer 암호화 기반의 인터넷 보안 프로토콜이다.\n\n- SSL 특징\n    * 1995년 네스케이프사에서 처음 개발되었다\n    * 개발 목적은 프라이버시 보장, 인증, 데이터 진실성을 위해 개발되었다 \n    * 암호화 알고리즘을 사용하여 데이터를 암호화함\n    \n\n- SSL 사용방법 \n    * CA(Certificate authorities)에서 인증서를 발급\n    * 서버에 설치 후 웹서버 설정\n    \n## TLS vs SSL \n    \n\u003e TLS는 SSL 3.0을 계승하는 암호화 프로토콜이다\n\u003e 즉 앞으로 `TLS == SSL` 라고 생각하면 된다\n\n## SSL 암호화 방식 \n- 대칭키 방식\n    * 해시 테이블 처럼 키가 있어야 암호화를 할 수 있다 \n    * 암호화 할때 1234이라는 암호로 키를 사용했다면 1234이 있어야 복호화 할 수 있다\n    * 대칭키를 공유할때 위험이 노출되기 때문에 매우 위험하다\n- 비대칭 키 방식\n    * 공개키(public key)와 개인키(private key)를 가진다 \n    * 공개키로 암호화 하는 경우와 개인키로 암호화 하는것으로 구분\n    * 암호화할때의 키와 복호화할 때의 키 값이 다르면 비대칭 키라고 한다\n    \n\u003e CA에서 발급받은 인증서는 제 3자가 소유하고있는 사이트를 보장해준다는 의미\n\u003e 즉 데이터가 안전하게 암호화 되어 전송되고 있다는 뜻이다\n\n\u003e 구글에서는 공식적으로 Search eninge ranking 이라는 항목으로 `https 암호화`를 적용시 `상위 검색순위`에 들어가게 됨으로 꼭 https를 적용시키자 \n[SEO 체크리스트 공식문서](https://g.co/WebmasterChecklist)\n\n![image](https://user-images.githubusercontent.com/56494905/161895465-1bbe2acc-ff94-49d4-a594-b92d0292f58c.png){:width=\"50%\"}\n\n\n\n## 인증서(Certificate)  \n- CA(Certificate authorities) 기관의 종류\n    - 무료\n        * Let's Encrypt\n        * WoSign \n        * AWS Certificate \n        * CloudFlare SSL \n \n     - 유료\n        * Verisign\n        * GoDaddy\n        * GlobalSign\n        * Comodo(Sectigo)  \n        * Thawte  \n        * GeoTrust \n        * DigiCert  \n\n    * 실제로 적용된 사례\n    \n        ![image](https://user-images.githubusercontent.com/56494905/161885376-8022a886-fc79-46c9-a073-6839952e2fbe.png){:width=\"50%\"}\n        \n        ![image](https://user-images.githubusercontent.com/56494905/161917519-916e0d93-6011-46fb-8bf2-16c6d19fdc3f.png){:width=\"50%\"}\n    \u003e 각자브라우져에 자물쇠 부분을 클릭해서 Certificate 부분을 보면 도메인의 소유자의 대한 내용이 상세히 나온다 즉 SSL이 적용된 사례라고 볼 수 있다\n\n\n## 인증서 구매 및 셋팅\n\n- CA 사이트에서 구매 후 \n\n    ![image](https://user-images.githubusercontent.com/56494905/161897304-cb440634-2169-43b8-8228-accd707c9341.png){:width=\"50%\"}\n\n- 도메인 내용 입력장면\n\n    ![image](https://user-images.githubusercontent.com/56494905/161897397-47589b99-6113-468a-85dc-944d5b5a3828.png){:width=\"50%\"}\n\n- 생성된 private key\n\n    ![image](https://user-images.githubusercontent.com/56494905/161899159-9c07101d-e829-4562-a127-9c465263dd74.png){:width=\"50%\"}\n- cludeflare.com의 certificate의 정보\n    * 도메인 네임이 인증되어있고 어떤 내용으로 발생되었는지\n    * 어떤 사람, 기관, 기종에서 발생되었는지\n    * 발급한 인증기관\n    * 인증기관의 디지털 서명\n    * 관련된 서브 도메인들\n    * 인증날짜\n    * 만료날짜\n    * Public 키 \n        \n    ![image](https://user-images.githubusercontent.com/56494905/161919187-83ea6c6e-8a84-4839-88a5-a213005fe8ec.png){:width=\"50%\"}\n \n\n- 인증기관의 등록 절차가 모두 완료 후 아래와 같은 4가지 키 와 인증서를 받게 된다\n    * ssl.key : 서버쪽 비공개키\n    * ssl.crt : 디지털 인증서\n    * ca.pem : ROOT CA 인증서\n    * sub.class1.server.ca.pem : 중계자 인증서\n\n- Apache 또는 Nginx 또는 Node.js 에 설치\n    ... 생략[나중에...]\n        \n\n\n\n## SSL 작동원리\n* 작동원리 \n    1. 핸드쉐이크를 통한 서버 인증 확인 절차\n    2. 절차 완료 후 클라이언트와 서버 둘다 세션 획득 성공 \n    3. 대칭 암호화 데이터 전송(세션 키를 이용해서) \n\n* 알아야할 개념 \n    1. 대칭 키 알고리즘(Symmetric-key algorithm)\n    2. 비 대칭 키 암호\n    3. 인증서(certificate) \n    4. CA (Certificate authority)\n    5. 핸드쉐이크(3way Handshake)\n    6. 암호화 알고리즘 (RSA 기타 등등...)\n\n\n\u003c!--\n- 대칭 키 암호(Symmetric-key algorithm)\n    * 암호화 할때 같은 암호키를 쓰는 것\n\n- 공개 키(public key)\n    * 모든 사람이 언제든지 키를 공유함\n    \n- 비공개 키(private key)\n    * 어떠한 방식으로 키를 조심스럽게 다름사람한테 보내야 한다\n\n- 공개키와 비공개키(대칭키) \n    * 실제 데이터 -\u003e `대칭 키(비공개키)`\n    * 대칭 키(비공개 키) -\u003e `공개키`\n    \n\u003e 실제 데이터를 대칭키로 암호화 한 후, 다시 그 키를 공개키로 암호화 한다\n--\u003e\n\n### SSL Handshake를 통한 서버 인증 확인 절차\n\n- SSL Handshake의 전체적인 흐름도\n\n    ![image](https://user-images.githubusercontent.com/56494905/161886749-b3359817-3331-41c7-8505-ec0222642733.png){:width=\"100%\"}\n\n- SSL Handshake RSA key 교환방식 알고리즘을 사용한 순서도표\n\n    ![image](https://user-images.githubusercontent.com/56494905/162109026-5095b356-4443-46a3-bde1-9802f498321e.png)\n\n\u003c!--\n| 순서 | 포함된 데이터                                                | 클라이언트                           | 방향성  | 서버                                           | 일어나는 일                                                                                                             |\n| :-:  | :-:                                                          | :-:                                  | :-:     | :-:                                            | :-:                                                                                                                     |\n| 1    | TLS version, the ciper suites, client random                 | \"hello\" 메세지를 서버에 보낸다       | --|                                                | 클라이언트가 서버에 접속한다. 사용할 수 있는 알고리즘을 서버로 보낸다, 이미 세션 아이디가 있다면 기존 세션키를 확인한다 |\n| 2    | SSL certificate, server's chosen cipher suite, server random |                                      | \u003c-----  | \"hello\"에 다시 인증서를 넣고 클라이언트로 보냄 |                                                                                                                         |\n| 3    | premaster secret                                             | 공개키로 암호화한 키를 서버로 보낸다 | --|                                                | 공개키는 인증서에 포함되어 있음, 인증서를 브라우져 안에 있는 CA list와 대조하여 확인                                    |\n| 4    |                                                              |                                      |         | 비공개키로 premaster secret 을 다시 복호화     | pre master key -\u003e master key 로 복호화                                                                                  |\n| 5    | session key                                                  | 세선키를 생성                        |         | 세션키를 생성                                  | 각자 서로 공유한 client random, server random을 가지고 session key를 생성                                               |\n| 6    | finished                                                     | finished를 서버에 보냄               | \u003c-| finished를 클라이언트에 보냄                   | 서로 finished가 보내서 확인함 (세션키를 이용하여 최종 연결완료)                                                         |\n\n--\u003e\n\n### 세션(데이터 전송 준비완료)\n* 마지막으로 대칭 키가 준비가 완료\n* 세션키를 가지고 암호화 한다음 데이터를 전송\n\n\n\n# 7 가지 Man-in-the-middle attack \n* IP spoofing\n    * 공격자가 IP 주소를 변형시켜 일반적인 클라이언트인척 속인 후 서버에 접속해서 추적을 피하는 해킹 기법이다 \n* DNS spoofing\n    * 공격자는 금융기관등의 사이트와 동일한 사이트를 만들어 강제로 가짜 사이트로 이동하게 하는 방식이다\n* HTTPS spoofing\n    * 링크주소는 https로 되어 있지만 사실 링크된 사이트는 http로 된 사이트로 연결되어 클라이언트의 정보를 뺴는 방식\n* SSL hijacking\n    * http로 된 URL에 접속할때 공격자가 설정해 놓은 SSL 서버에 접속을 유도하여 클라이언트와 서버 중간에서 데이터를 가로채는 공격방식\n* Email hijacking\n    * 금융기관을 사칭한 사이트로 접속을 유도하여 사용자 정보를 빼는 방식\n* Wi-fi eavesdropping\n    * 공공 wifi를 사용하면 공격자가 router에 연결된 디바이스의 패킷 정보를 모니터 할 수 있다.\n* Stealing browser cookies\n    * 쿠키 탈취는 클라이언트 내부에 저장된 개인정보가 탈취되는 것을 말한다\n    \n\u003e https 로 미리 암호화된 상태로 연결되었다면 데이터가 `중간에 탈취`되더라도 `세션키로 암호화` 되어 있어서 좀더 안전할 수가 있다. \n\u003e\u003e 단 좀비 컴퓨터를 이용해 여러대의 컴퓨터가 한곳을 집중적으로 공격하는 DDOS 공격에는 https는 도움이 안된다.\n\n\n\n# 결론\n\n\u003e 랜선을 타고 다니는 모든 데이터는 안전하지 않다\n\u003e\u003e 다만 이중 삼중으로 암호화시 좀더 보안성이 향상 된다\n\u003e\u003e 따라서 `https`는 선택이 아닌 `필수`다\n\n\n# 참고사이트\n* [모질라 공식사이트](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)\n* [http 상태코드](http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)\n* [Cloudflare](https://www.cloudflare.com/learning/ssl/what-is-ssl/)\n* [링크](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)\n* [Mozila - ChiperSuite](https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_Ciphersuite)\n* [Norton](https://us.norton.com/internetsecurity-wifi-what-is-a-man-in-the-middle-attack.html)\n\n# 주석\n[^protocol]:  프로토콜은 컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계이다. 기기 간 통신은 교환되는 데이터의 형식에 대해 상호 합의를 요구한다. 이런 형식을 정의하는 규칙의 집합을 프로토콜이라고 한다. \n[^statuscode]: http 반환코드: 클라이언트의 데이터 요청에 따른 서버 반환 코드\n[^handshake]: 프로토콜(protocol): 서버와 클라이언트의 소통 과정을 나타낸다. \n[^SYC]: 동기화(Synchronization  )\n[^ACK]: 승인(Acknowledgement) \n[^symmetric-key-algorithm]: 대칭키 암호(symmetric-key algorithm) 암호화 알고리즘의 한 종류로, 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘을 의마한다.\n[^personal-information]: Personal information : 어떤 사람의 자세한 정보 즉 이름, 주소 기기정보, 계정정보 및 암호 등이다\n"])</script><script>self.__next_f.push([1,"15:T836,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# JSON(Javascript Object Notation)  \n* ECMAScript 3rd 1999\n* AJAX (Asynchronous JavaScript And XML)\n* XHR (XMLHttpRequest)\n\n- 장점\n    * simplest data interchange format\n    * lightweight text=based structure\n    * easy to read\n    * key-value pairs\n    * used for serialization and transmission of data between the network the network connection\n    * independent programming language and platform\n\n\n\n\n##  Object to JSON (Serialize)\n\n* 간단한 예제\n\n```javascript\n// stringfy(obj)\nlet json = JSON.stringify(true)\nconsole.log(json)\n```\n\n* 배열을 넣으면 \"\" 더블쿼트로 나온다\n\n```javascript\nlet json = JSON.stringify(['appe', 'banana'])\nconsole.log(json) //[\"apple\", \"banana\"]\n```\n\n* 간단한 객체를 만들어서 넣어보자\n\n```javascript\n\nconst rabbit = {\n    name: 'tori',\n    color: 'white',\n    size: null,\n    birthDate: new Date(),\n    symbol : Symbol(\"id\"),\n    jump: () =\u003e {\n       console.log(`${name} can jump`) \n    }\n\n//\njson = JSON.stringify(rabbit)\nconsole.log(json) \n```\n\n* 위 객체를 마음대로 변경 추가 삭제도 가능\n\n\n```javascript\n \n //\njson = JSON.stringify(rabbit, ['name']) //name만 출력가능\nconsole.log(json) \n\n//\njson = JSON.stringify(rabbit, (key, value) =\u003e {\n    console.log(`key: ${key}, value: ${value}`)\n    return key === `name` ? `ellie` : value\n\n}) //출력되는 JSON 데이터 파일을 컨트롤 가능\nconsole.log(json) \n}\n```\n\n\n## JSON to Object(Deserialize)\n\n* JSON을 다시 Object로 만드는것은 `JSON.stringify()`를 이용하면 된다\n* 두번째 parameter 에서 call back 함수를 넣어 원하는 데이터를 쉽게 고칠 수 있다 \n\n\n\n\n\n```javascript\n// JSON to Object\njson = JSON.stringify(rabbit)\nconst obj = JSON.parse(json)\nconsole.log(obj)\nrabbit.jump()\nobj jump() //함수는 포함이 되지 않음 \n\n\nconsole.log(rabbit.birthDate.getDate())\nconsole.log(obj.brithDate) // string으로 할당\n//\n\n//revivor\nconst obj = JSON.parse(json, (key, value)=\u003e{\n    console.log(`key: ${key}, value: ${value}`)\n    return key === 'birthDate' ? new Date(value) : value\n})\nconsole.log(obj)\n\n```\n\n\n\n"])</script><script>self.__next_f.push([1,"16:T25aa,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# JWT(JSON Web Signature)\n\n\n## JWT인란?\n\n\u003e `JWT`는 RFC 7519 웹 표준으로 지정이 되어있다. JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token이라고 정의할 수 있다.\n\n## JWT 장점\n\n![image](https://user-images.githubusercontent.com/56494905/158747176-d67b4bc7-b546-442e-bf3c-e80341e07253.png)\n\n\n\n## JWT의 구조\n`JWT는 header + payload + signature 로 조합된 토큰이다.`\n\n### Header\n`헤더는 암호화 방식을 선택하고 JWT및 JWE 등 암호화 방식을 선택할 수 있다.`\n\n\u003e `header의 인자값`\n\u003e\u003e `alg`: algorithm의 줄임말. 알고리즘 선택.  \n\u003e\u003e SHA256 or SHA512 등을 사용 \n\u003e\u003e\n\u003e\u003e `typ`: type의 줄임말. JWT, JWE등 다른 방식의 토큰을 선택가능.\n\n### Payload \n`페이로드는 실제 데이터가가 들어가는 곳이며 토큰을 받는 사람, 제목, 보내는사람, 만료시간, 활성 날짜, 발급 시간 등을 설정할 수 있다.`\n\n\u003e `pay-load 인자값`\n\u003e\u003e `iss`: issuer 의 줄임말. 토큰 발급자. \n\u003e\u003e\n\u003e\u003e `sub`: subject의 줄임말. 토큰 제목.\n\u003e\u003e\n\u003e\u003e `aud`: audience의 줄임말. 토큰 대상자\n\u003e\u003e\n\u003e\u003e `exp`: expiration (time) 줄임말. 토큰 만료 시간\n\u003e\u003e\n\u003e\u003e `nbf`: from not before (time) 줄임말. 토큰 활성 날짜( 이날짜 이전의 토큰은 활성화되지 않을을 보장)\n\u003e\u003e\n\u003e\u003e `iat`: from issued at (time) 줄임말. 토큰 발급 시간. \n\u003e\u003e\n\u003e\u003e `jti`: from JWT ID 줄임말. 토큰 식별자(issuer가 여러명일떄 이를 구분하기 위한값) \n\n\n### Signature\n`시크릿키를 암호화 시키기면서 동시에 header와 payload를 합치고 최종적으로 토큰을 완성시킬 수 있다.`\n\n``` javascript\n//header 64진수로 변환 \nconst encodedHeader = base64(utf8(JSON.stringify(header)));\n\n//paylod를 64진수로 변환\nconst encodedPayload = base64(utf8(JSON.stringify(payload)));\n\n//위 두개를 가지고 hmac 알고리즘으로 주어진 secret 키를 이용해 암호화 후 64진수로 변환\nconst signature = base64(hmac(`${encodedHeader}.${encodedPayload}`,\nsecret, sha256));\n\n\n//마지막으로 다시 header + payload + signature를 합친게 JWT 토큰의 완성이다.\nconst jwt = `${encodedHeader}.${encodedPayload}.${signature}`;\n\n```\n### 완성된 JWT 토큰 \n\u003e 아래의 코드가 JWT 토큰으로 변환된 완성 모습이다.\n\u003e\u003eeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n\u003e\n\u003e `Header` : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\n\u003e\n\u003e `payload` : eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.\n\u003e\n\u003e `signature` :TJVA95OorM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n- 자세히 보면 . 으로 구분되어 있는 부분을 확인 할 수 있는데, 각 header와 payload 그리고 signature의 각 부분을 암호화하여 .으로 구분되어 있다 \n\n\n### 디코드된 JWT 토큰\n\u003ehttps://jwt.io 에서 위 완성된 토큰을 다시 디코드를 하면 header와 payload에 관한 내용을 볼 수가 있다.\n\u003e![image](https://user-images.githubusercontent.com/56494905/158709055-3e610708-2ac6-4d44-82ee-5e0c36dfcaf5.png)\n\n\n\n## JWT 생성 과정\n\u003e![image](https://user-images.githubusercontent.com/56494905/158618931-2a14edd7-00ed-4c2e-82b3-528acb66ef18.png)\n\n\n## JWT 사용목적\n\n\u003e 1. 데이터 전송시 보안 목적\n\u003e 2. 권한 인증 목적 \n\u003e 3. stateless\n\u003e - 세션과는 달리 백엔드 서버가 바뀌어도 인증이 가능하다. \n\u003e 4. 모바일 환경에서 로그인 지속 \n\n\n## 토큰을 사용하지 않았을경우 취약점\n\n### Cross-site Request Forgery(CSRF)\n\u003eCSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격이다.\n\n\n### Cross-Site Scripting (XSS)\n\n\u003e 악성 스크립트를 통해 사용자의 의도와 상관없는 비 정상적인 동작을 발생시키는 공격  \n\u003e  (예: 쿠키값 노출, 피싱, 악성 코드가 실행 가능한 사이트로 리다이렉트 등)\n\n\n## 일반적인 Token 인증 방식과 refresh 인증 방식\n### 일반적인 token 인증 방식\n\u003e![Screen Shot 2022-03-17 at 1 15 18 PM](https://user-images.githubusercontent.com/56494905/158748389-630b2072-c1aa-479e-8d9b-badc5ec9009e.png)\n\u003e1. 사용자가 로그인한다.\n\u003e2. 서버에서 계정정보를 읽어 사용자를 확인하여 사용자의 고유한 ID 값을 부여한 뒤 기타 정보와 함께 Payload에 넣는다.\n\u003e3. JWT 토큰의 유효기간을 설정한다.\n\u003e4. 암호화할 Secret Key를 이용해 Access token을 발급한다.\n\u003e5. 사용자는 Access token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.\n\u003e - Authorization: Bearer \u003ctoken\u003e\n\u003e - 요청을 보낼 때 JWT 토큰을 Authorization header 필드에 담아보낸다.\n\u003e6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작여부/유효기간을 확인한다.\n\u003e7. 검증이 완료되면 Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.\n### refresh token 인증 방식\n\u003e![Screen Shot 2022-03-17 at 1 18 22 PM](https://user-images.githubusercontent.com/56494905/158748708-c0b25f6a-f2fb-4fff-b8df-14bce0da82e2.png)\n\u003e\n\u003e1. Access Token은 짧은 생명 주기를, Refresh Token은 보다 긴 생명 주기를 갖는다. ( 구체적인 기간은 케이스마다 다르다. )\n\u003e2.  서버로 요청 시 Access Token을 사용하고 Access Token이 만료되면, Refresh Token을 이용해서 새로운 Access Token을 받아온다.\n\u003e3. Refresh Token도 만료된다면 다시 로그인을 해야한다.\n\u003e4. Access Token이 탈취당하는 경우, 공격자는 사용자와 동일한 권한을 갖게 된다.\n\u003e=\u003e JWT를 사용하는 경우 반드시 SSL을 이용한 암호화 통신을 사용해야 한다.\n\u003e5. 보안이 중요한 서비스의 경우 JWT가 Stateless함에도 불구하고, Redis등에 발급한 Access Token을 보관하기도 한다.(로그아웃 시 Redis에서 삭제)\n\u003e\n\n## 토큰처리시 백앤드 or 프론트앤드 \n\n\u003e 공식 문서에는 이렇게 나와있다.\n\u003e\u003e 각 어플리케이션 모델에 따라 백엔드 또는 프론트엔드 알아서 처리해라\n\u003e\u003e\n\u003e\u003e 고려해야 할 부분은 이렇다.\n\u003e\u003e 1. JWT 데이터가 너무 큰가?\n\u003e\u003e 2. 대역폭에 영향을 끼치는가?\n\u003e\u003e 3. 백엔드에서 오는 레이턴시 (반응속도)가 느린가?\n\u003e\u003e 4. 자잘한 요청을 한번에 묶어 큰 요청으로 바꿀수 있는가?\n\u003e\u003e 5. 토큰 요청이 데이터베이스에 큰영향을 끼치는가?\n\n\n\n## 미니 프로젝트에서 사용된 JWT 코드 예제\n### 인코드 방법 \n``` python\ndef api_login():\n    pw_hash = hashlib.sha256(pw_receive.encode('utf-8')).hexdigest()\n\n    payload = {\n            'userid': id_receive,\n            'exp': datetime.datetime.utcnow() + datetime.timedelta(days=2)\n    }\n    \n    token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')\n\n```\n\n\n### 디코드 방법 \n```python\ndef add_comment():\n\n    ##클라이언트 사이트에서 mytoken 이라는 쿠키를 가져온다\n    token_receive = request.cookies.get('mytoken')\n    \n    ##jwt 함수를 불러와 HS256으로 인코딩된 mytoken 데이터를 payload 함수에 저장한다.\n    ##이때 SECRET_KEY는 기존에 인코딩할떄의 SECRET_KEY를 넣어준다.  \n    payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\n    \n    ## 몽고 DB 접속후 payload 안에있는 BODY 내용 중 userid를 확인해서 검색한 값을 userinfo에 넣어준다. \n    userinfo = mongo_connect().user.find_one({'userid': payload['userid']}, {'_id': 0})\n    .....\n    \n```\n\n\n## 용어 모음\n\u003e `Base64` \n\u003e - 64진법 으로 변환 주로 이메일 보낼때 쓴다. 한글이나 특수 문자들이 영향을 끼치지 않는 ASCII코드로 변환시켜 준다.\n\u003e\n\u003e `utf8` \n\u003e - 인코딩된 텍스트를 받고 UTF-8로 구성된 배열을 반환한다.\n\u003e\n\u003e `sha256` \n\u003e - Secure hash Algorithm 256비트로 구성되어 64자리 문자열을 반환. 2의 256제곱만큼 경우의 수를 만들어 무차별 대입으로 수행시 해시 충돌사례를 찾으려할때 업겁의 시간이 소요 된다. 즉 불가능하다. 배열을 받아 sha-256 알고리즘으로 인코딩된 배열을 반환한다.\n\u003e\n\u003e `hmac` \n\u003e - hash-based Message Authentication Codes 약자로 주어진 키를 가지고 코드를 생성 해당 코드만이 다시 원복할 수 있다. \n\u003e\n\u003e `페이로드(Payload)의 뜻` :\n\u003e - 운송업에서 지금(pay) 해야 하는 적화물(load) 즉실 제 가지고 있는 데이터의 내용\n\u003e\n\u003e`Stateful`\n\u003e - 웹서버가 사용자(브라우저)의 상태 client(쿠기) or server(세션) 정보를 기억하고 있다가 유용한 정보로써 활용한다는 의미입니다.\n\u003e\n\u003e`Stateless`    \n\u003e - 웹서버 통신(http) 특성상 사용자(브라우저)의 이전 상태 client(쿠키) or server(세션) 정보를 기록하지 않는 접속이란 의미입니다.\n\u003e\n\u003e `Session`\n\u003e - 서버에 저장하는 사용자정보\n\u003e \n\u003e `cookie`\n\u003e - 사용자 컴퓨터에 저장하는 데이터\n\u003e\n\u003e`RS256`\n\u003e - RS256(RSA signature with SHA-256) 공개키를 사용할때 사용 \n\u003e\n\u003e`HS256`\n\u003e - HS256(HMAC with SHA-256) 비공개키를 사용할때 사용\n\n\n## 참고사이트\n\n\u003e\n\u003ehttps://itstory.tk/\n\u003e\n\u003e https://auth0.com/ \n\u003e\n\u003e https://jwt.io/\n\u003e\n\u003e https://developer.okta.com/blog/2020/12/21/beginners-guide-to-jwt\n\u003e\n\u003ehttps://junshock5.tistory.com/83\n\u003e\n\u003ehttps://mokpo.tistory.com/14\n\u003e\n\u003ehttps://choppadontbiteme.tistory.com/95 \n"])</script><script>self.__next_f.push([1,"17:T4a4,* TOC\n{:toc}\n\n# 기본문법\n\n* 문법 시작과 끝을 알려준다\n- `\\begin\n\\end`\n\n- 그냥 `$$` 열고 닫아도 된다.\n- 곱셈 : `times`\n- 덧셈 : `+`\n- 아래에 넣기: `_n`\n- 제곱 : `^n`\n\n\u003e `$$A + B = A$$` -\u003e \n$$ A + B = A $$\n\n그럼 책에 있는 내용을 넣어볼까?\n\n$$ (N \\times ((M \\times ( W + T)) + (F \\times (1 - W)))) + B $$\n\n오 잘된다\n\n이정도면 간단한건 쓸수 있겠다.\n\n## math\n![image](https://user-images.githubusercontent.com/56494905/159516288-6b187e56-afb3-4c43-a29f-fc5ad7736fc6.png)\n\n![image](https://user-images.githubusercontent.com/56494905/159516477-3fd20f9d-1d3d-4625-b082-e395d7b878c7.png)\n## accents and over/under commnads\n![image](https://user-images.githubusercontent.com/56494905/159516049-8bb0a2a4-26c1-4b9c-a7a1-b7fcfde9e019.png)\n\n## 심볼\n![image](https://user-images.githubusercontent.com/56494905/159515854-c14f23fa-64cd-4760-86a8-1627a1b1ebc7.png)\n\n\n## 참고 사이트\n* [참고 사이트](https://goodtogreate.tistory.com/entry/LaTex-%EC%82%AC%EC%9A%A9-Tip-%EC%A0%95%EB%A6%AC) \n* [참고PDF](extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=https%3A%2F%2Fwww.icl.utk.edu%2F~mgates3%2Fdocs%2Flatex.pdf)\n\n18:T1168,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# CS스터디 3장 \n* [유튜브 링크](https://youtu.be/OCCpGh4ujb8)\n\n\n## let vs var \n\n```javascript\n//1. Use strict\n//\n'use strict'\n\n// 2. Variable\n// let (added in ES6)\n\nlet name = 'ellie'\nconsole.log(name)\nname = hello\nconsole.log(name)\n```\n\n## Variable\n### let \n- Mutable type\n\n\u003e 써야함\n\n\n-------------------------------------------\n### var\n\u003e 쓰지마세요!\n\n왜?\n\n```javascript\n// 선언하기도 전에도 사용할 수 있다\n// var hoisting (move delcaration from boottm to top)\n\nconsole.log(age)\n//undefined\nage = 4 \nconsole.log(age)\nvar age \n```\n- var hoisting[^hoisting]\n    * 선언을 매 위로 올린다\n    * 선언도 하기 전에 출력, 저장 할 수 있음\n    * 블럭 스코프 무시\n\n-------------------------------------------\n### const \n\u003e Immutable type \n\n* 포인터를 가르키는 부분이 잠겨있다 즉 변경 불가\n\n\n\n1. 값을 변경하지 말아야 하는 이유\n    * 보안상의 문제 \n        - 혹시라도 해커가 변경하면 프로그램이 엉망이됨\n    * thread safety \n        - 다양한 thread 가 동시에 변수를 변경하는데 위험함\n    * redue human mistakes\n        - 협헙시에 사람이 실수하는 부분을 더 줄여준다\n    \n-------------------------------------------\n### block scope\n\u003e 블럭 안에 있는것은 블럭 안에서만 가능하다\n\n1. 끝까지 메모리에 남는다\n2. global 로 저장됨\n3. 필요한 부분만 적절하게 사용해야함\n\n\n```javascript\nlet globalName = 'global name'\n{\n    //항상 메모리에 탑제된다\n    let name = 'ellie'\n    console.log(k)\n    name = 'hello'\n    \n    console.log(name)\n    //hello\n    console.log(globalName)\n    //global name\n}\nconsole.log(name)\n//undefined\nconsole.log(globalName)\n//global name\n\n```\n\n\n-------------------------------------------\n## Variable types\n\n1. primitive(single item)\n    * number\n    * string\n    * bloolean\n    * null\n    * undefined\n    * symbol\n2. object(box container)\n    * function\n    * first-class function\n\n\n### Primitive\n- number \n    * 따로 다른 타입을 선언해 줄 필요없다.\n    * type 이 자동으로 적용된다\n```javascript\nconst infinity = 1/ 0\n// Infinity\nconst negativeInfinity = -1 /0\n// -Infinity\nconst nAn = 'not a number' / 2\n// NaN\n```\n\n-------------------------------------------\n- bigInt\n    * 숫자의 크기가 클때 쓴다\n```javascript\nconst bigInt = 1234123412487293487928374892734n\nconsole.log(`value: ${bitInt}, type :${typeof bigInt}`)\n// value :  ....  type bigInt\n```\n\n-------------------------------------------\n- String\n    * template literals(string)\n```javascript \n${variable Name}\n```\n\n-------------------------------------------\n- Boolean\n    * false -\u003e 0, null, undefined, NaN, ''\n    * true -\u003e any other value\n\n\n-------------------------------------------\n- null\n\u003e\n\n-------------------------------------------\n- undefined\n\u003e 선언은 되었지만 아직 변수를 주지 않았다\n\n-------------------------------------------\n- symbol\n\u003e create unique identifiers for objects\n    * 알고리즘, 자료구조 할때 사용한다\n    * 고유값을 지정하기 위해 사용한다\n    * 출력할때는 .description 으로 출력한다.\n    \n```javascript\n//기본 사용법 \nconst gSymbol1 = Symbol('id')\nconst gSymbol2 = Symbol('id')\n\nconsole.log(gSymbol2 === gSymbol1)\n//false\n```\n```javascript\n//같은 심볼출력하기\n//Symbol.for\nconst gSymbol1 = Symbol.for('id')\nconst gSymbol2 = Symbol.for('id')\n\nconsole.log(sgSymbol1 === sgSymbol2 )\n// true\n```\n```javascript\n//같은 심볼출력하기\nconst gSymbol1 = Symbol('id')\nconst gSymbol2 = Symbol('id')\n```\n\n-------------------------------------------\n### Object \n\u003e real-life object, data structure\n\n\n\n```javascript\n//const로 elie를 수정할 수 없지만 자식의 값은 변경 가능함\nconst detail= {name : \"me\", age : 20}\ndetail.name = \"you\"\n// const 로 선언했지만 객체의 내용은 변경 할 수 있음\n```\n\n\n\n## Dynamic typing: dynamically typed language\n\u003e 선언할때 어떤타입인지 설정하지 않는다\n\n```javascript\nlet text = 'hello'\nconsole.log(text.charAt(0))\n//h \n\nconsole.log(`value: ${text}, type: ${tyepof text}`)\ntext = '7' + 3\n//자동으로 문자열 7이 문자열7로 변경된다\n// 10\n\nconsole.log(`value: ${text}, type: ${tyepof text}`)\ntext ='8' + '3'\n// string -\u003e number \n\n\ntext = '8' / '2'\n```\n\n\n\n# 주석\n[^hoisting]: hoisting: 언제 어디든 제일 위에서부터 선언되어 있음\n\n\n\n\n\n"])</script><script>self.__next_f.push([1,"19:Tf15,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 진정한 마이크로서비스란? \n마이크로서비스는 소프트웨어 아키텍쳐 페턴으로 크고 복잡한 어플리케이션을 파편화로 각자 독립적인 프로세서들로 구성하는 것을 마이크로서비스라고 한다. 각각의 서비스들은 최대치의 퍼포먼스를 발휘하고 확장성이 용이하며 보수가 편리하다는 장점이 있다. \n\nTCP로 데이터를 받기 떄문에 사실상 아무 언어나 상관 없이 각 모듈마다 구성이 가능하다. \n\n\nAgile 방식의 개발 환경과 맞게 진행가능하며 독립적으로 배포가 가능하다.\n\n\u003e예를 들어 쿠팡의 각 메뉴에 대한 팀이 따로 있다고 한다. 그 메뉴를 담당하는 팀들은 그 모듈만 관리하게 되고 그 모듈은 독립적으로 실행되어 문제가 발생해도 다른 모듈과 존속적이지 않아 전체 서버다운이 발생하지 않는다.\n\n## 마이크로서비스를 도입시에 생각해봐야할 부분?\n    - 과연 우리 서비스에 맞는 방식인가? \n    - 마이크로서비스를 위해 얼마나 더 많은 코드가 필요한가?  (앞으로\n    - 백엔드만 마이크로서비스를 구성한다면? 프론트도 파편화로 구성이 가능할까?\n    - 각각의 마이크로서비스의 레포는 어떻게 관리가 되어야 할것인가? \n    - 문서화는 어떻게 해야할것인가?\n    - 이러한 복잡도는 감당할 수준인건가?\n    - 어플리케이션의 파편화는 어느정도로 해야할 것인가? \n\n\n## 마이크로서비스의 5가지 장점\n\n1. Decoupled components\n   - 다른 모듈의 상관없이 쉽게 변경하고 쉽게 업데이트 할 수 있다\n2. Scalability \n   - 마이크로서비스의 다른 메모리를 공유하지 않는다 이것은 쉽게 스케일링 할 수 있고 리소스를 플렉시블하게 늘릴 수 있다. \n3. Faster to build \n    - 어플리케이션을 작은 단위로 분리할때 병렬적으로 각 모듈을 개발할 수 있다. \n4. Language and technology agnostic \n    - 다른 프레임워크나 다른 언어를 사용해도 된다. 진입 장벽이 낮고 각 팀원들마다 다른 언어를 사용해도 되며 다른 프레임워크를 사용해도 된다. \n5. Reduces complexity \n    -마이크로서비스의 파편화로 쉽게 이해할 수 있고, 보수, 테스트를 한번에 진행할 수 있다.\n\n# 그럼 마이크로서비스를 구축하려면?\n\n\u003e 각 언어 및 프레임워크에서 지원하는 방식의 네트워크를 사용하여 각 모듈을 연결해서 사용한다.\n\n## Nestjs 에서 해야할것\n1. Nestjs에서 필요한 마이크로서비스 모듈을 제공해 주고 있다. 각 서비스에 맞는 프레임워크를 사용하면 된다. restapi 를 쓸때는 Rabbitmq를 쓰는거 같다.\n    1) rabbitmq\n    2) kafka -\u003e 실시간 스트리밍의 \n    3) MQTT \n    4) gRPC\n2. kubernetes를 이용하여 각 마이크로서비스의 도커를 묶어서 서버를 운용한다. \n\n## kubernetes에서 해야할것\n//\u003c!--\n1. 각 포즈(파즈?)에서 \n--\u003e\n\n## AWS에서 해야할 것\n1. \n\n## 목표  \n\u003e 각 pods에다가 모듈을 올리고 통신이 되는지 확인해야한다\n\n1. TCP/IP를 사용하여 각 마이크로서비스간의 통신으로 reqeust-response 를 데이터 통신할 수 있다. \n\n## 앞으로의 계획  \n1. 쿠버네티스관한 공부내용을 정리\n2. Nestjs 의 마이크로서비스에 관한 내용을 정리 및 레퍼런스를 만들어 AWS에 배포 \n3. AWS 관한 내용을 숙지\n4. 최종적으로 Nestjs으로 작성된 각각의 모듈들을 각 컨테이너(Pods)에 넣고 서비스를 운영\n\n\n## Reference \n- [쿠버네티스 공식 문서](https://kubernetes.io/docs/concepts/overview/components/) \n- [쿠버네티스 정리된 블로그](https://seongjin.me/kubernetes-cluster-components)\n"])</script><script>self.__next_f.push([1,"1a:Tac9,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# mysql \n## docker로 설치 방법\n```bash\n$ docker pull mysql\n\n// m1 칩셋에서는 docker pull mysql이 안먹는다\n// 아래 명령어로 받자\n\n$ docker pull --platform linux/x86_64 mysql\n\n\n// 이미지가 제대로 다운로드 됐는지 확인한다 \n$ docker images\n\n\n\n// 도커 컨테이너를 실행시키고 이름은 mysql-docker 루트의 비번은 password(변경해서) 3306포트로 설정한다\n$ docker run --name msyql-docker -e MYSQL_ROOT_PASSWORD=\u003cpassword\u003e -d -p 3306:3306 mysql:lates\n\n// docker list 확인\n$ docker ps -a \n\n$ docker start mysql-docker\n\n$ docker exec -it mysql-docker bash\n\n//권한주기 로컬호스트로만 작동하고 싶으면  localhost로외부 전체 다 접속하고 싶으면 %로 변경\n$ grant all privileges on *.* to '아이디'@'localhost';\n\n//혹시라도 CURD만 기능 넣고 싶다 \n$ grant select, insert, update on DBname.* to '아이디'#'%';\n\n$ flush privileges\n\n\n```\n\n## EC2 서버 셋팅 방법\n- ubuntu 20 버전으로 EC2 micro2 버전을 선택한다\n- key 값을 받는다 \n\n```bash\n\n// 다운받은 폴더에 들어가서\n$ cd test_mysql_aws\n\n// 파일 실행권한 설정\n$ chmod 400 my_test_key.pem\n\n//ssh로 접속\n$ ssh -i “my_test_key.pem” ubuntu@ec2SSSSSS214.us-east-2.compute.amazonaws.com\n```\n\n- 프로그램 설치\n\n```bash\n$ sudo apt update\n$ sudo apt install mysql-server nodejs npm\n```\n    \n- 한국 시간 맞추기\n\n```bash\nsudo ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime\n```\n\n- port fowarding \n- security 에서 inbound 항목에서 5000과 80 번 번호를 추가하고 아래의 명령어를 입력하자\n\n```bash\n$ sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 5000\n```\n\n\n\n\n- sudo mysql\n\n```bash\n// 관리자로 들어감\nmysql\u003e sudo mysql\n\n// 관리자 테이블에 user 테이블에서 사용자를 확인한다\nmysql\u003e select user from mysql.user;\n\n\n// 사용자 아이디를 임의로 추가하다 @ 'localhost' -\u003e 이것을 % 로 변경하면 외부도메인에서 접속할 수 있다\nmysql\u003e CREATE USER 'diasm'@'localhost' IDENTIFIED BY '123';\n\n// 권한 내요을 확인한다\nmysql\u003eSHOW GRANTS FOR diasm@localhost;\n\n// root 관리자의 암호를 변경\nmysql\u003e ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'your_password_here';\n\n// 적용\nmysql\u003e FLUSH PRIVILEGES;\n\n// 나가기\nmysql\u003e exit\n\n//셋팅한 암호치고 접속\n$ sudo mysql -u root -p\n\n// 백엔드에서 셋팅한 데이터베이스 이름\nmysql\u003e create database database_name\n```\n\n## 참고 사이트\n- [링크](https://www.mysqltutorial.net/mysql-select-database/)\n- [링크2](https://velog.io/@gillog/MySQL-%EC%9C%A0%EC%A0%80-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0)\n\n## Sequelize 사용법\n** 작성중\n\n\n\n"])</script><script>self.__next_f.push([1,"1b:T1480,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 4장 Operator if for-loop \n\n## 전장 복습\n- Immutable data types: premitive types, frozen objects (i.e object.freeze())\n- Mutable data types : all objects by default are mutable in JS\n\n변하지 않는 데이터 타입 : 기본형 타입, 객체 등\n변하는 데이터 타입 : 모든 객체\n\n## Operator\n* String concatenation\n```javascript\nconsole.log('my' + ' cat')\n//my cat\nconsole.log('1' +2)\n//12 문자열로 반환 \nconsole.log(`string literals: 1 + 2 = $(1 + 2)`)\n//`` 백틱을 이용하면 변수의 값을 문자열 내로 사용할 수 있다\n//${변수명 또는 숫자} \n```\n\n\n* Numeric operators\n```javascript\nconsole.log(1 + 1) //더하기\nconsole.log(1 - 1) // 빼기\nconsole.log(1 / 1) // \nconsole.log(1 * 1)\nconsole.log(1 % 1)\nconsole.log(1 ** 1)\n```\n\n* Increment decrement opertiors\n    - preIncrement\n    ```javascript\n    let ocunter = 2\n    const preIncrement = ++counter \n    //counter = counter +1\n    //preIncrement = counter\n    ```\n    - postIncrement\n    ```javascript\n    let counter = 2\n    const postIncrement = counter++\n    //postIncrement = counter\n    //counter = counter + 1\n    ```\n    - preDecrement\n    ```javascript\n    let counter = 2\n    const preDecrement = --counter \n    //counter = counter - 1\n    //preDecrement = counter\n    ```\n    - postDecrement\n    ```javascript\n    let counter = 2\n    const postDecrement = counter--\n    //postDecrement = counter\n    //counter = counter + 1\n    ```\n\n\n* Assingment operators\n```javascript\nlet x = 3\nlet y = 6\nx += y  // x = x + y\nx -= y\nx *= y\nx /= y\n```\n\n\n* Comparison operators\n```javascript\nconsole.log(10 \u003c 6) // less than\nconsole.log(10 \u003c= 6) // less than or equal\nconsole.log(10 \u003e 6) // greater than\nconsole.log(10  6) // greater than equal\n```\n\n* logical operators:  (or), \u0026\u0026 (and), ! not\n \n```javascript\nconst value1 = false\nconst value2 = 4 \u003c 2\n\n\n// || (or), finds the first truthy value\nconsole.log(`or: ${value1 || value2 || check()}`)\n//or는 제일 처음이 참이면 멈춘다\n//제일 간단한것을 앞으로 놓고 복잡도가 높은 함수는 뒤로 넣는다\n\n\n// $$ (and), finds the first falsy value\nconsole.log(`and: ${value1 \u0026\u0026 value2 || check()}`)\n//and는 모든것이 같아야 실행된다\n//nullableObject \u0026\u0026 nullableObject.somthing\n//true값을 반환하는 객체값이 true 면 somthing 인스턴스를 불러온다\n//아래의 코드와 같다\n\nif(nullableObject != null){\n    nullableObject.somthing\n}\n\nfunction check(){\n    for(let i =0; i\u003c 10; i++){\n    //wasting time\n    console.log('what')\n    }\n    \n}\n```\n\n\n* Equality\n\n```javascript\nconst stringFive = '5'\nconst numberFive = 5\n\n// == loose equlity, with type conversion\n//값만 비교하는 비교구문\nconsole.log(stringFive == numberFive) //true 형이 달라도 숫자나 문자가 같다\nconsole.log(stringFive != numberFive) //false \n\n// === strict equality, no type conversion\n//타입을 모두 비교하는 엄격한 비교구문\nconsole.log(stringFive === numberFive) //false 형이 다르니 틀린 겂이다\nconsole.log(stringFive !== numberFive) //true\n\n// object equality by reference\nconst me1 = { name: 'me'}\nconst me2 = { name: 'me'}\nconst me3 = me1 \nconsole.log(me1 == me2) // 객체 잠조 주소를 가르키니까 다른 값이다 FALSE\nconsole.log(me1 === me2) // 객체의형이 같아도 참조 주소가 다르니까  FALSE \nconsole.log(me1 === me2) // 객체의 주소를 다시 받아 왔으니까 같은 값이다 TRUE\n\n\n// equality - puzzler\nconsole.log(0 == false) // true\nconsole.log(0 === false) // false\nconsole.log('' == false) // true\nconsole.log('' === false) // false\nconsole.log(null == undefined) // true\nconsole.log(null === undefined) // false\n\n```\n\n* Conditional operators: if\n\n```javascript\n//if, else if, else\n\nconst name = 'ellie'\nif (name === 'ellie'){\n    console.log('you are my father')\n} else if ( name === 'coder'){\n    console.log('You are the chicken')\n} else {\n    console.log('unkwon')\n}\n\n```\n\n* Ternary operator: ?\n\n```javascript\n//condition ? value1 : value2\nconsole.log(name === 'me' ? 'yes' : 'no')\n```\n\n* Switch statment\n \n```javascript\n//use for multiple if checks\n//use for enum-like value check\n//use for multiple type checks in TS\n\nconst browser = 'IE'\nswitch (browser) {\n    case 'IE':\n        console.log('go away!')\n        break\n    case 'Chrome': //같은 출력값을 나타나게 할때는 생략 가능\n    case 'FIreFox':\n        console.log('love you!')\n        break\n    default:\n        console.log('same all')\n        break\n}\n\n```\n\n* Loops\n\n```javascript\n// while loop, while the condition is truthy\n// body code is executed\n\nlet i = 3\nwhile (i\u003e0){\n    console.log(`while: ${i}`)\n    i--\n}\n\n\n\n\n//do while 문은 조건을 나중에 실행 시킨다\ndo {\n    console.log(`do while: ${i}`)\n    i--\n\n} while (i \u003e 0)\n\n\n\n\n// for loop, for(begin; condition; step)\nfor (i= 3; i\u003e0; i--){\n    console.log(`for: ${i}`)\n}\n\n\n\n\n\nfor (let i = 3; i \u003e0; i = i -2 ){\n    //inline variable declaration\n    console.log(`inline variable for: ${i}`)\n}\n\n\n\n\n// nested loops\nfor (let i = 0; i \u003c 10; i++){\n    for (let j = 0; j \u003c 10; j++{\n    console.log(`i: ${i}, j:${j}`)\n    }\n}\n\n// break, continue\n// for 를 끝내는거 break\n// if문에서 그냥 continue  하는게 좋음\n\n```\n\n\n\n\n\n\n\n"])</script><script>self.__next_f.push([1,"1c:T1199,"])</script><script>self.__next_f.push([1,"\n- TOC\n  {:toc}\n\n\n\n## PUT과 PATCH\n- put : 자원의 전체 교체, 자원교체 시 모든 필드 필요( 만약 전체가 아닌 일부만 전달할 경우, 전달한 필드 외 모두 Null or 초기값)\n- patch : 자원의 부분 교체, 자원교체시 일부 필드 필요\n\n## 멱등성\n- 동일한 요청을 한 번 보내는 것과 여러번 연속으로 보내는 것이 같은 효과를 지나고, 서버의 상태도 동일하게 남을 때, 해당 HTTP메서드가 `멱등성`을 가지고 있다라고 말한다\n\n\n| 멱등성                                       | 비 멱등성                   |\n| :- :                                         | :-:                         |\n| GET, HEAD, PUT, DELETE,OPTIONS, TRACE(en-US) | POST, PATCH, CONNECT        |\n| 여러번 보내도 같은 효과                      | 여러번 보내면 보낸만큼 효과 |\n\n\n\u003e \n\n## PUT\n9.6 PUT\n\n   The PUT method requests that the enclosed entity be stored under the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing resource, the enclosed entity SHOULD be considered as a\n   modified version of the one residing on the origin server. If the\n   Request-URI does not point to an existing resource, and that URI is\n   capable of being defined as a new resource by the requesting user\n   agent, the origin server can create the resource with that URI. If a\n   new resource is created, the origin server MUST inform the user agent\n   via the 201 (Created) response. If an existing resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent\n   to indicate successful completion of the request. If the resource\n   could not be created or modified with the Request-URI, an appropriate\n   error response SHOULD be given that reflects the nature of the\n   problem. The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range) headers that it does not understand or implement\n   and MUST return a 501 (Not Implemented) response in such cases.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n   The fundamental difference between the POST and PUT requests is\n   reflected in the different meaning of the Request-URI. The URI in a\n   POST request identifies the resource that will handle the enclosed\n   entity. That resource might be a data-accepting process, a gateway to\n   some other protocol, or a separate entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies the entity enclosed\n   with the request -- the user agent knows what URI is intended and the\n   server MUST NOT attempt to apply the request to some other resource.\n   If the server desires that the request be applied to a different URI,\n   \n   \n   \n## PATCH \n19.6.1.1 PATCH\n\n   The PATCH method is similar to PUT except that the entity contains a\n   list of differences between the original version of the resource\n   identified by the Request-URI and the desired content of the resource\n   after the PATCH action has been applied. The list of differences is\n   in a format defined by the media type of the entity (e.g.,\n   \"application/diff\") and MUST include sufficient information to allow\n   the server to recreate the changes necessary to convert the original\n   version of the resource to the desired version.\n\n   If the request passes through a cache and the Request-URI identifies\n   a currently cached entity, that entity MUST be removed from the\n   cache.  Responses to this method are not cachable.\n\n   The actual method for determining how the patched resource is placed,\n   and what happens to its predecessor, is defined entirely by the\n   origin server. If the original version of the resource being patched\n   included a Content-Version header field, the request entity MUST\n   include a Derived-From header field corresponding to the value of the\n   original Content-Version header field. Applications are encouraged to\n   use these fields for constructing versioning relationships and\n   resolving version conflicts.\n\n   PATCH requests must obey the message transmission requirements set\n   out in section 8.2.\n\n   Caches that implement PATCH should invalidate cached responses as\n   defined in section 13.10 for PUT.\n\n\n## IETF?\n* The Internet Engineering Task Force(IETF)\n\n\n# 참고사이트\n* [IETF](https://datatracker.ietf.org/doc/html/rfc2616#section-9.6)\n\n"])</script><script>self.__next_f.push([1,"1d:T563,* TOC\n{:toc}\n\n# react에서 파일 읽기 \n- 맨날 마음만 이렇게 저렇게 해볼까 하는데 막상 안한다. 다른 몇몇 분들은 위키를 예쁘게 커스터마이징 하셨던데 나도 한번 해볼까 싶다. 일단 첫번째 단계인 MD파일을 react에서 읽을 수 있나 확인해보았다.\n\n- 주의해야 할 부분은 md파일을 읽을때 global.d.tsx 파일을 생성해주고 아래와 같이 해줘야한다.\n```javascript\ndeclare module \"*.md\"\n```\n\n```Javascript\nimport React from \"react\"\nimport logo from \"./logo.svg\"\nimport ReactMarkdown from \"markdown-to-jsx\"\nimport post from \"./2022.md\"\nimport \"./App.css\"\n\nfunction App() {\n  let [readable, setReadable] = React.useState({ md: \"\" })\n\n  React.useEffect(() =\u003e {\n    fetch(post)\n      .then((res) =\u003e res.text())\n      .then((md) =\u003e {\n        setReadable({ md })\n      })\n  }, [])\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\n        \u003cp\u003e\n          \u003cReactMarkdown children={readable.md} /\u003e\n          Edit \u003ccode\u003esrc/App.tsx\u003c/code\u003e and save to reload.\n        \u003c/p\u003e\n        \u003ca\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        \u003e\n          Learn React\n        \u003c/a\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  )\n}\n\nexport default App\n```\n1e:T996,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n## Description (개요)\n\n현재 개발된 부분은 간단하게 서버에서 JWT토큰을 발행후 3600초 동안 유지하는 방식으로 테스트를 완료했습니다.\n하지만 실제 서비스에서는 보안에 관련하여 좀더 신경써야 하기때문에 Access Token 과 Refresh Token을 이용한 3 Handshake 방식의 인증 방식을 사용하려고 합니다.(5월 16일 개발 예정)\n\nTo @pol-dev-shinroo\n 지금 테스트를 진행할때는 3600초동안 JWT토큰이 유지될거라 3600 이후에는 다시 JWT토큰을 받으려면 로그인을 다시 해야하는 문제점이 있습니다.\n따라서 Access Token과 Fresh Token에 대해 이해 하시고 나중에 적용할때 준비를 해두시면 좋을 듯 합니다.\n\n[리엑트에서 Refresh Token 관리법 레퍼런스](https://slog.website/post/10) \n[백에서 Refresh Token 레퍼런스](https://velog.io/@kingth/%EC%84%9C%EB%B2%84-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EC%84%B8%EC%85%98%EC%BF%A0%ED%82%A4-%ED%86%A0%ED%81%B0)\n\n작동방식\n----------------------\n\u003e 가정 1. Access Token과 Refresh Token이 둘다 없을때\n### **클라이언트**\n1. 로그인 요청\n### **서버**\n2. **Access Token**과 **Refresh Token**을 발행한다\n      - Access Token : 생명주기가 짧은 토큰(예: 1시간)\n      - Refresh Token: 생명주기가 긴 토큰(예: 2주일)\n  3. Refresh Token은 서버DB에 저장\n  4. Client에게 Access Token, Refresh Token을 보낸다\n  ### **클라이언트**\n  5. Refresh Token을 안전한 곳에 저장\n  6. Access Token을 헤더에 넣고 필요한 요청을 보낸다.\n  ### **서버**\n  7. Access Token을 검증 후 필요한 데이터를 보낸다.\n\n------------------------\n\n\u003e 가정 2. Access Token은 만료 되고, Refresh Token이 유효할때 \n\n###   **클라이언트** \n1. Access Token과 함께 데이터 요청\n(보내기전에 Access Token안에 payload안에 유효기간을 알 수 있어서 재발급 요청 가능)\n\n ###  **서버**\n2. Access Token 확인 -\u003e 만료 \n3. 클라이언트에서 Refresh Token 요청 및 확인(payload 안에 유효기간확인가능)\n4. Refresh Token이 아직 유효하면\n5. Access Token을 바로 발급 후 헤더로 전송\n  \n\n\n-------------------------------\n\u003e 가정3. accessToken은 만료 되고, refreshToken도 만료될때 \n -\u003e **다시 로그인해야함**\n\n 개요  \n\n\n## reference\n- (https://hello-judy-world.tistory.com/74){사이트 주소}\n"])</script><script>self.__next_f.push([1,"1f:T9b8,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# Unit Test에 대한 이해(번역) \n- Unit 테스트에 대한 공부를 하기 위해 구글링한 자료를 번역해본다.\n- 의역과 오역이 있을수 있다는 \n- reference : https://blog.logrocket.com/unit-testing-nestjs-applications-with-jest/\n\n## Intro\n\n프로그램 테스트는 꾀 어려운 컨셉이다. 그래서 그런지 많은 프로그래머들은 버그가 발생하는것에 두려움을 느껴 테스트를 기피하게 된다. 특히 Node.js 생태계에서는 항시 필요한 느낌은 아닌데 반면에Java 생태계에서는 리소스가 부족한거 같다.\n\n그럼에도 불구하고 테스트 코드를 작성해야 한다. 유닛테스트는 그중 가장 쉬운 편에 속하는데 유닛 테스트란 무엇인가에 대해 알아보고자 한다. 유닛 테스트는 `가장 작은단위에 포커스`를 맞춘 테스트이다. 유닛이란 단일 함수 또는 메소드인데 만약 순수한 함수라면 다른 이슈가 발생하지 않을거고굉장히 쉬운 결과값을 알 수 있게 된다.\n\n```jaavscript\nexpect(add(2,2)).toBe(4);\n```\n\n위 코드를 보고 우리는 바로 단정할 수 없는게 모든 함수들이 순수 함수로만 되어있지는 않기때문에 주의해야한다. 그리고 테스트 코드는 일반 함수보다 좀더 복잡하고 어렵다.\n\n통상적으로 우리가 작성하는 함수들은 다른 함수를 위해 내부적으로 사용하는 함수이다. 예를 들어 `userService.createUser()` 같은경우에는 내부적으로 `userRepository.create()`를 불러서 유저엔티티를 만들고 `userRepository.save()`를 사용해 데이터베이스에 저장하게 된다. 이 경우에는 테스트 결과를 하는게 헛수고 이고, 코드가 제대로 작동되는지 확신할 수 없다.\n\n유닛 테스트는 단지 비지니스로직에 대한 함수 그 자체를 테스트하기 위한 테스트이다.\n\n그렇기 때문에 이러한 예제같은경우 `userRepository.create()`가 함수가 불러오는 자체를 확인해야 하는거고, 인자값\n\n\n## What makes unit testing unique\n\n유닛 테스트는 의존적이 않아야하며 빨라야한다. 그리고 그 유닛에 대한 크기 에 대한 속도를 예상할 수 있다.? \u003c-- 좀더 확인해야함 \n유닛 테스트는 커밋이 완료된 후에는 꼭 테스트를 해야한다. 그중 GIT으로 어떤 파일이 어떤 내용으로 변경됬는지 추적할 수 있다\n\nEnd-to-End(E2) 테스트는\n\n"])</script><script>self.__next_f.push([1,"20:Tf6b,"])</script><script>self.__next_f.push([1,"\n## [[diary]]{Diary}\n\n- [[2022]]{2022년 일일기록}\n- [[2023]]{2023년 일일기록}\n\n## Web Programming\n\n- FrontEnd\n  - [[react]]{React}\n  - [[flask]]{Flask}\n  - [[css]]{css}\n\n- [[backend]]{BackEnd}\n  - [[oauth]]{Oauth란?(작성중)}\n  - [[nodejs]]{Nodejs}\n  - [[todo-memo]]{mongodb \u0026 router}\n  - [[pm2]]{pm2(production manage program)}\n  - [[refreshtoken]]{refresh 토큰 구현하기}\n  - [[nestjs]]{Nestjs}\n  - [[nodeEventLoop]]{Node Event Loop}\n  - [[socketio]]{socket}\n  - [[jest]]{test code}\n  - [[microservice]]{nestjs의 마이크로서비스}\n\n- GIT(형상관리)\n  - [[commitconvention]]{커밋 컨벤션}\n  - [[gitreset]]{푸시 후 되돌리자}\n  - [[gitCommitCopyToNewRepo]]{기존 커밋내용을 새로운 레포에 복사하기}\n\n- Mysql\n  - [[mysql_sequelize]]{mysql\u0026sequelize}\n\n- DevOps\n  - CI/CD\n    - [[jenkins]]{Jenkins}\n    - [[git-actions]]{Git-action auto Deploy}\n    - [[gitactions3cloudfront]]{git action + s3 + cloudfront + https}\n\n  - [[Docker]]\n    - [[DockerImage]]{docker image란?}\n    - [[DockerContainer]]{docker container란?}\n    - [[DockerNetwork]]\n    - [[Dockerfile]]{Dockefile설정}\n    - [[DockerCompose]]{DockerCompose사용법}\n    - [[dockerBuildx]]{크로스플렛폼 이용시 m1 -\u003e aws ec2 }\n\n  - [[AWS]]\n    - [[ElasticBeanstalk]]{ElasticBeanstalk 손쉬운 Backend 배포}\n    - [[cognito]]{Cognito 간단하게 사용자 인증을 개발하자}\n    - EC2\n    - [[S3]]\n    - [[Codepipeline]]{Codepipeline으로 CI/CD 구축하자}\n    - [[Amplify]]{손쉬운 FrontEnd 배포}\n    - [[CloudFront]]{CloudFront로 서버 캐싱(빠른 로딩)}\n    - [[CloudWatch]]{Cloud Watch로 손쉬운 로그 관리}\n    - [[RDS]]{Relational Database Service}\n    - [[Route53]]{DNS}\n    - [[Certificate]]{SSL}\n    - [[ParameterStore]]\n\n  - Nginx\n    - reverse proxy\n    - conf.d\n\n  - SSL\n    - [[whatisLetEncrypt]]{Let's Encrypt란?}\n\n  - Cheerio\n    - [[Cheerio]]{Cheerio 사용법}\n\n## Linux \u0026 Server\n\n- [[Docker]]{Docker 사용법}\n- [[vim]]{Vim 사용법}\n- [[tmux]]\n- [[linux-locale]]{Ubuntu locale(언어설정)}\n- [[fish-shell]]{fish shell}\n- [[ssh]]{ssh}\n\n## Synology\n\n- [[Synology]]{시놀로지}\n\n## [[sparta]]{스파르타(Bootcamp)}\n\n- [[miniproject]]{미니프로젝트}\n- [[homework]]{과제톡(알고리즘)}\n- [[cs-homework]]{항해톡(웹일반지식)}\n- [[cs-study]]{CS스터디(기초CS)}\n- [[interview50q]]{인터뷰50Q}\n- [[lastComment]]{마지막 후기}\n- [[plus]]{항해플러스}\n- [[lastCommentPlus]]{항해플러스후기}\n\n## [[algorithm]]{알고리즘(Algorithm)}\n\n- 선형구조\n  - [[linked-list]]{연결리스트(linked-list)}\n  - [[hash-table]]{해시테이블(hash-table)}\n\n## [[Javascript]]{자바스크립트(Javascript)}\n\n- Javascript ES6\n  - [[origin]]{1장. 기원}\n  - [[async-defer]]{2장. sync와 defer 차이점}\n  - [[letVsVar]]{3장. let vs var}\n  - [[operator-if-for-loop]]{4장. operator, if, for loop}\n  - [[arrow-function]]{5장. arrow fuction?}\n  - [[class-vs-object]]{6장. class vs object}\n  - [[what-is-object]]{7장. object가 무엇인가}\n  - [[array-APIs]]{8장. Array}\n  - [[json-js]]{10장.JSON 개념}\n  - [[callback-function]]{11장.callback promise async await}\n\n  - 작성중\n  - [[promise-js]]{12장. 프로미스 개념부터 활용까지 }\n  - [[async-await]]{13장. async 와 await }\n- syntax\n  - [[spread-syntax]]{Spread-syntax[...array]}\n  - [[forinforof]]{forin과 forof}\n- Method \u0026 Library\n\n## [[Python]]{파이썬(Python)}\n\n- Syntax\n  - [[enumerate]]{배열에 키값넣기 (enumerate)}\n  - [[range]]{for-loop-range}\n  - [[magic-mothod]]{magic-mehtod}\n  - [[inheritance-python]]{파인썬 상속(inheritance)}\n- Library\n  - [[deque]]{deque}\n  - [[random-python]]{random 난수 발생 library}\n  - [[deque-mothod]]{deque}\n  - [[python-heapq]]{힙큐(heapq)}\n\n\n## Etc\n\n- [[regex]]{정규표현식}\n- [[naming]]{기호 영어이름}\n- [[Latex]]{Latex 사용법}\n- [[program]]{프로그램 추천}\n- [[link-list]]{사이트 링크모음}\n"])</script><script>self.__next_f.push([1,"21:T69f,* TOC\n{:toc}\n\n# 그래프(Graph)\n## 기본개념 \n\n\n### 오일러 경로\n### 해밀턴 경로\n### 그래프 순회\n- DFS(깊이우선탐색)\n- BFS(너비우선탐색)\n### 백트래킹 (N-Queen)\n\u003e 백트래킹은 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후볼를 포기(백트랙)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제에 특히 유용하다.\n\n\u003e leetcode 문제\n\u003e https://leetcode.com/problems/n-queens/\n\n![image](https://user-images.githubusercontent.com/56494905/159195564-27e88352-4d69-4ea9-a660-18c68cffa969.png)\n\n``` python\ndef nqueen(n):\n    visited = [-1] * n # 배열을 n개 만든다 \n    cnt=0 # 카운터 변수 선언\n\n    # 범위를 벗어 났는지 확인\n    def is_ok_on(nth_row):\n        #\n        for row in range(nth_row):\n            if visited[nth_row] == visited[row] or nth_row - row == abs(visited[nth_row] - visited[row]):\n                return False\n        return True\n\n    def dfs(row):\n        if row \u003e= n:\n            nonlocal cnt\n            cnt += 1\n            grid = [['.'] * n for _ in range(n)]\n            for idx, value in enumerate(visited):\n                grid[idx][value] = 'Q'\n            return\n\n        for col in range(n):\n            visited[row] = col\n            if is_ok_on(row):\n                dfs(row + 1)\n\n    dfs(0)\n    return cnt \n\nprint(nqueen(int(input())))\n```\n\n# assert nqueen(4) == [[\".Q..\", \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"]]\n\n\n```\n\n\n\n\n### 제약 충족 문제\n\n\n## 문제풀이  \n### 교재 내용\n\n### leetcode solution\n\n## 풀면서 잘 몰랐던 부분 \n\n## 파이썬문법 모르는 부분 \n\n## 주석\n\n\n\n22:T11df,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 기호 영어로 표기\n\n\u003e 기억하자 읽을줄 모르면 설명도 못한다\n\n\n| 문자 | 영 문                                     | 한 글             |                 또 다른 영문표기 |\n| :-:  | :-                                       | :-:               |                              :-: |\n|      | Space (스페이스)                          | 공백, 공란        |                    blank, ghost\u0026 |\n| ~    | Tilde (틸드)                              | 물결(표)          |                                  |\n| `    | Grave (그레이브)                          | 강세표            |               accent, back quote |\n| !    | Exclamation point (익스클레메이션 포인트) | 느낌표            |       exclamation mark, wow, hey |\n| @    | At Sign (앳사인 또는 앳)                  | 골뱅이            |                   at, each, rose |\n| #    | Crosshatch (크로스해치)                   | 우물표시          |             pound, number, sharp |\n| $    | Dollar sign (달러 사인)                   |                   |            cash, currency symbol |\n| %    | Percent sign (퍼센트 사인)                | 백분표            |          double-oh-seven, grapes |\n| ^    | Circumflex (서큠플렉스)                   | 모자, 윗꺾쇠      |                 carrot, hat, cap |\n| \u0026    | Ampersand (앰퍼센드)                      |                   |                              and |\n| *    | Asterisk (아스테리스크)                   | 별표              |   star, spider, times, wildcard* |\n| (    | Left parenthesis (레프트 퍼렌터시스)      | 소괄호 열기       |            (open) paren, so, sad |\n| )    | Right parenthesis (라이트 퍼렌터시스)     | 소괄호 닫기       |             close (paren), happy |\n| -    | Hyphen (하이픈)                           | 붙임표, 빼기표시  |       minus (sign), dash, option |\n| _    | Underscore (언더스코어)                   | 밑줄              |              underline, underbar |\n| +    | Plus sign (플러스 사인)                   | 더하기 표시       |                  add, cross, and |\n| =    | Equal sign (이퀄 사인)                    | 같음표            |                    gets, becomes |\n| \\|   | Vertical bar (버티컬 바)                  |                   | pipe, vertical line, broken line |\n| \\    | Back slash (백 슬래시)                    | 원표시            |                                  |\n| ←    | Back space (백 스페이스)                  | 왼쪽 화살표       |                                  |\n| {    | Left brace (레프트 브레이스)              | 중괄호 열기       |                            brace, curly bracket |\n| }    | Right brace (라이트 브레이스)             | 중괄호 닫기       |                          unbrace |\n| [    | Left bracket (레프트 브라켓)              | 대괄호 열기, 꺾쇠 |                          bracket |\n| ]    | Right bracket (라이트 브라켓)             | 대괄호 닫기       |                        unbracket |\n| :    | Colon (콜론)                              | 쌍점              |                                  |\n| ;    | Semicolon (세미콜론)                      | 반쌍점            |                                  |\n| \"    | Quotation mark (쿼테이션 마크)            | 큰따옴표          |                     double quote |\n| '    | Apostrophe (어퍼스트로피)                 | 작은따옴표        |                                  |\n| ,    | Comma (콤마)                              | 쉼표, 반점        |                                  |\n| .    | Period (피리어드)                         | 마침표, 온점      |             dot, decimal (point) |\n| \u003c\u003e   | Angle brackets (앵글 브라케츠)            | 거듭 인용표       |                           angles |\n| \u003c    | Less than (레스 댄)                       | 거듭 인용표 열기  |                             less |\n| \u003e    | Greater than (그레이터 댄)                | 거듭 인용표 닫기  |                             more |\n| ?    | Question mark (퀘스천 마크)               | 물음표            |           query, what mark, what |\n| /    | Slash (슬래시)                            | 빗금              |                spare, divided-by |\n\n## ref\n* [참고사이트](https://syntaxsugar.tistory.com/entry/%ED%8A%B9%EC%88%98-%EA%B8%B0%ED%98%B8-%EB%AA%85%EC%B9%AD%EC%9D%B4%EB%A6%84)\n\n\n\n"])</script><script>self.__next_f.push([1,"23:T699,\n- TOC\n  {:toc}\n\n# Javascript is synchronous\n\n```javascript\nconsole.log(\"1\")\n\nsetTimeout(() =\u003e {\n  console.log(\"hello world\")\n}) //지정한 시간이 지나면 콜백함수를 불러올 수 있음\n\nconsole.log(\"2\")\nconsole.log(\"3\")\n```\n\n## Synchronous callback/ Asynchronous callback\n\n```javascript\nfunction printImmediately(print) {\n  print()\n}\n\nprintImmediately(() =\u003e console.log(\"hello\"))\n\n// Asynchronous callback\n\nfunction printWithDelay(print, timeout) {\n  setTimeout(print, timeout)\n}\n```\n\n## callback hell example\n\n```javascript\n\nclass UserStorage {\n    loginUser(id, password, onSuccess, onError) {\n        setTimeout(() =\u003e {\n            if(\n            (id === 'ellie' \u0026\u0026 password === 'dream') ||\n            (id === 'coder' \u0026\u0026 password === 'academy')\n            ) {\n                onSuccess(id)\n            } else {\n                onError(new Error('not found'))\n            }\n            }\n\n        }, 2000)\n    }\n    getRoles(user, onSucccess, onError) {\n        setTimeout(() =\u003e {\n            if(user === 'ellie'){\n                onSuccess({ name:'ellie', role: 'admin'})\n            } else {\n                onError(new Error('no access'))\n            }\n        }, 1000)\n    }\n}\n\n\n\n## Call back hell example\n\n```javascript\nconst userStorage = new UserStorage()\nconst id = prompt(\"enter your id\")\nconst password = prompt(\"enter yINFP-Tour password\")\nuserStorage.loginUser(\n  id,\n  password,\n  (user) =\u003e {\n    userStorage.getRoles(\n      user,\n      (userWithRole) =\u003e {\n        alert(`Hello ${userWithRole.name}, you have a ${userWithRole.role}`)\n      },\n      (error) =\u003e {\n        console.log(error)\n      }\n    )\n  },\n  (error) =\u003e {\n    console.log(\"error\")\n  }\n)\n```\n24:T80f,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 상속 inheritance \n## 각자 만든 method를 한곳에 사용 하고싶다. \n\n\u003e 2022-03-26 15:33:03 \n토요일 \n팀원들과 vscode live share를 하고 같이 스택에 대해서 같이 코딩을 해보았다 .\n그런데 아래와 같은 문제가 발생했다.\n\n1. 각자 파일을 만들고 메소드를 만들었다. push pop randompop\n2. __main__파일로 import 해서 method를 불러왔다. \n3. __main__이라는 파일에서 Node 객체들 만들고 각자 만들었던 method를 가져와 상속시켰지만 `작동하지` 않았다 \n\n\u003e 상속이 왜 안될까?\n\n\n```python\n# __main__.py 파일\nfrom smhong import Stack, Node\n\nfrom sunghye import * \nfrom semyung import * \nfrom ksj import * \n\nclass Stack_(Semyung, stack_ksj, Sunghye, Stack):\n     def __init__(self):\n         self.max = 10\n         self.size = 0\n         self.top = None\n\n     def __str__(self):\n         ss = []\n         while top:\n             ss.append(top.item)\n            top = top.next\n      \n         return str(ss)\n a = Stack_()\n\n a.push(1)\n a.pop()\n a.push(1)\n print(a)\n```\n\n\n## 변수가 공유가 안된다 \n\n1. 각자 만든 메소드를 한 파일에 \n\n\n```python\n#  __main__.py \n\n# semyung 파일에서 모든 클라스를 가져온다\n# ksj 파일에서 모든 클라스를 가져온다\nfrom semyung import *\nfrom ksj import *\n\n\n\n# 아래와 같이 두가지 파일을 만들고 \n\n# semyung.py\n## push method\n\ndef push(self, value):\n    if self.head is not None:\n        self.head =  Node(value)\n        \n    self.temp = self.head.next\n    self.head.next = Node(value)\n    self.head = self.temp\n    \n    \n# ksj.py\n## pop, randompop method\n\ndef pop(self):\n    if self.top is not None:\n        node = self.top\n        self.top = self.top.next\n        self.size -= 1\n        return node.item\n\ndef randompop(self):\n    ran = randrange(1, self.size)\n    node = self.top\n\n    for _ in range(ran-1):\n        if not node:\n            return None\n        node = node.next\n    result = node.next\n\n    node.next = node.next.next    \n    return result.item\n\n````\n"])</script><script>self.__next_f.push([1,"25:T726,* TOC\n{:toc}\n\n# AWS로 Repo로 이주하기\n\u003e 소스코드의 보안적인 측면에서 이주를 한다. 레거시 코드에서 모든 키들이 올라가있다. 벌써 몇번 유출되어서 수습하고 해결 방안을 찾던중 AWS에서도 레포를 제공하기때문에 이주한다. \n\u003e 그런데 깃허브는 기본이 public으로 되어있어서 credential한 내용을 한번이라도 올리면 어디선가 crwaler가 몇 초만에 가져가 버린다. 주의 해야한다.\n\n## AWS codecommit 가격\n- 5명 아래\n    - 1,000 레포지토리 / 어카운트\n    - 최대 25,000까지 요청가능 \n    - 50GB/달 용량\n    - 10,000 Git 요청/달\n- 6명 부터 1달러씩 추가\n    - 1,000 레포지토리 / 어카운트\n    - 최대 25,000까지 요청가능 \n    - 10GB/계정  \n    - 2,000 Git 요청/계정\n\n\n## Github -\u003e Codecommit\n\n```bash\n## you can try this, it's easy and straightforward. This will push all commits before (and including) the hash you use as \u003clast-commit-hash-from-old-repo\u003e to the other repo:\n\n$ git clone https://github.com/path/to/new-repo.git new-repo\n$ cd new-repo\n$ git remote add old https://github.com/path/to/old-repo.git\n$ git remote update\n$ git merge --allow-unrelated-histories \u003clast-commit-hash-from-old-repo\u003e\n$ git push origin main\n## if anyone needs to push all commits from a repo to another as a single commit (like I needed), you can simply add --squash to the merge command like this:\n\n$ git clone https://github.com/path/to/new-repo.git new-repo\n$ cd new-repo\n$ git remote add old https://github.com/path/to/old-repo.git\n$ git remote update\n$ git merge --squash --allow-unrelated-histories \u003clast-commit-hash-from-old-repo\u003e\n$ git push origin main\n```\n## reference\n- [https://stackoverflow.com/questions/37471740/how-to-copy-commits-from-one-git-repo-to-another](링크)\n26:Tff4,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 항해99\n## 항해99 선택한 이유\n\u003e 나의 개발자로서 위치를 파악할수 있었고, 포트폴리오 추가, 협업등을 한번에 해결할 수 있었다.\n\n### 30대 중반에 개발자로 재 취직 결심 \n난 해외에 계속 살면서 개발자와 먼 다른 직업을 가지고 있었다. 하지만 뼈속까지 공대 성향으로 어떤 일을 하던 업무프로세스의 효율을 위해 프로그래밍을 조금씩 해서 적용했다. 그런데 문득 그냥 개발자를 하는게 어떤가 싶었다. 그래서 다시 독학을 결심하고 뭔가 공부를 하기 시작했다. \n\n### 독학의 서러움 \n독학은 너무나 힘들고 지쳤다. 일단 예전에는 마땅한 에디터도 없이 뭔가 TextEditor 같은 걸로 했는데 VSCODE나 GIT이나 이런게 너무나 생소했다. 아무튼 Vscode나 VIM이나 이런걸 익히는데 시간을 많이 쏟았다. \n그리고 나서 개인적으로 관심있던 코인을 가지고 뭔가 한두개씩 만들었다. 그냥 아는 지식으로 라이브러리를 가지고 와서 Telegram으로 연결하고 API를 가져왔다. Google Sheet로 환율이나 코인 환차도 계산하면서 만들었다. 이때는 내가 백엔드를 하고 있는것도 모르고 있었다.\n그리고 나서 Google Sheet보다는 HTML로 만들고 싶어서 React로 만들어 보고 싶었는데 DOM이란 개념때문에 지속적으로 API를 받아서 화면을 재생성하는 자체가 생소했다.\n너무나 스트레스에다가 어려웠다. 그러던 어느날...\n\n### 뜻밖의 면접의 기회? 그리고 좌절\n나는 해외에 살고 있었다. 어느날  친구 앞에서 내가 개발한(코딩한) 것을 보여주면서 이것저것 신나게 설명을 하던중 친구의 여자친구가 면접이라도 보라고 연락이 왔다. 알고봤더니 현지 유명한 은행 HR부서에 일하고 있었고 나름 높은 직위에 있던 친구의 여자친구는 친절하게 다른 직원을 연결해서 빠르게 코딩 테스트 일정을 잡아줬다.  \n그날이 왔고 코딩테스트를 봤다... 한번도 코딩테스트라는 것을 들어본적도 없고 들어봤어도 쳐다보지도 않았던 나는 그냥 죽을 쓰게 되었다. 그리고 나서 오기가 생겨서 다시 조금 공부하고 다시 도전했다가 두번째 테스트에는 아예 중간에 포기했다.\n\n너무 억울해서 인터뷰라도 보게 해달라고 했다. 결과는 더 비참했다...\n질문의 대답은 하나도 못하고 그냥 애처럼 나좀 취직시켜달라는 애기였던 것이다. \n\n### 항해99와의 만남\n엄청난 기회를 놓친 나는 심각했다. 나의 개발능력이 그래도 초보는 아니라고 생각했지만 심각하게 뉴비였고 준비도 안되었던 것이다. 이대로는 시간이 아깝고 이해력과 끈기가 부족한 나는 독학으로는 절대 안될거 같았다.  \n\n이때 번뜩 떠오른 부트캠프.구글에 검색최상단에 항해99가 나왔다.\n포트폴리오? 실전프로젝트? 내가 원하던거다 그리고 몇 일 후에 결제를 완료했다.\n\n## 커리큘럼\n\u003e 미니프로젝트 알고리즘과 CS공부 그리고 발표 마지막 최종 프로젝트\n\n### 미니프로젝트 \n망했다. 한마디로 Python가지고 개발하는건데 모두들 너무 미숙했다.\n\n\n## 항해99 장단점\n\u003e 비전공자에게는 기회를 전공자에게는 날개를!\n\n### 장점 \n99일을 지나고 나서는 여러 사람들의 반응과.\n\n## 팀원들의 중요성\n\u003e 굉장히 중요하다 다른 사람들과 함께 무엇을 만드는것은 굉장히 어렵다. 서로 다른 성격과 다른 생각을 가진 사람들이 한가지 목표를 이루는게 쉽지는 않았다. 서로 배려해주고 이해해 줘야 한다.\n\n## 개발자 취업 후기\n\u003e 취직의 기쁨. 개발자의 첫걸음 \n\n## 결론은 `나한테` 좋은 선택이었다.\n\u003e 나에게는 신의 한수\n\n### 항해 시작부터 취직까지 166일 \n`2월 23일 항해99 합격 - 6월 18일 항해99 수료 -  8월 8일 첫출근` \n\n\n"])</script><script>self.__next_f.push([1,"27:T12c6,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 연결리스트를 이해하자 \n* 링크드 리스트는 정렬된 객체 모음이다.\n* 그러면 일반적인 List 와 linked list 의 차이점은 무엇일까?\n* list는elements를 메모리 블럭에 저장하고 \n  linked list는자기 자신의 elements의 참조값을 저장한다\n\n## 메인 컨셉 \n먼저 linked list가 어떻게 생겼는지 보자\n1. Data는 노드 안에 변수 값을 저장하고 있다\n2. Next는 다음 노드의 참조값을 저장하고 있다. \n그림으로 표현하자면 \n\n\u003e![image](https://user-images.githubusercontent.com/56494905/160308041-a9beed32-9690-49b8-bdfa-0ad7b8c29fa2.png)\n\n첫번째 노드는 head 라고 한다\nhead는 시작점을 알려주는 첫번째 단계이고 순차적 반복되며 다음 노드를 가르킨다\n마지막 데이터에서는 None을 가리키면서 마지막 이라는 지점을 알려준다\n\u003e![image](https://user-images.githubusercontent.com/56494905/160308173-5abf3af7-cbab-4ab9-9dc5-16f073ab90d4.png)\n\n## 실제로 적용해보기 \n\u003e 스택(stack) 큐(queue) 그래프(graph)\n\n\n### 스택(stack) or 큐(Queues)\n\n\n|      | 특징          |\n|:-:||\n| 스택 | 한쪽으로만 들어오고  나갈 수 있다        |\n| 큐   | 한쪽으로만 들어오고 다른 쪽으로만 나간다 |\n| 그래프 | 각 노드의 꼭지점에서 다음 노드를 가르킨다|\n\n* 큐(queue)\n\u003e 큐와 스택은 입력 방법은 동일하지만 삭제 방법은 다르다\n\u003e 큐는 시작과 끝을 지정해 주고 끝을 항상 삭제 후 돌아온다\n\n* collecitons 라는 라이브러리에 deque 함수를 쓰면 쉽게 큐를 구현할 수 있다\n\n\n```python\nfrom collecitons import deque\n\nqueue = deque()\nqueue\n\n\nqueue.append(\"1\")\nqueue.append(\"2\")\nqueue.append(\"3\")\nprint(queue)\n\n```\n\n위 코드를 보면 제일 먼저 들어온 1이 제일 처음으로 나가야한다\n\n\n\n```python\n\n\u003e\u003e\u003e queue.popleft()\n'1'\n\n\u003e\u003e\u003e queue\ndeque(['2','3'])\n\n\u003e\u003e\u003e queue.popleft()\n'2'\n\n\u003e\u003e\u003e queue\ndeque(['3'])\n\n```\npopleft() 함수를 사용하면 항상 head elemets의 값이 pop된다\n\n\n\n\n\n* 스텍(stack)\n\n\n\n### 구현해보기\n\n\n* class 를 만들어 링크드 리스트 메소드를 만들어 \nhead 변수를 None으로 초기화한다 \n\n\n* head 에 저장될 노드 class를 만들고 노드 안에는 data 와 다음 링크드 리스트를 가르킬 변수를 만든다\n\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n    def __repr__(self):\n        return self.data\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    def __repr__(self):\n        node = self.head\n        nodes = []\n        while node is not None:\n            nodes.append(node.data)\n            node = node.next\n        nodes.append(\"None\")\n        return \"-\u003e\".join(nodes)\n```\n\n\n\n* Search \n\n\n```python\n# node 가 None 일때까지 계속 반복해서 검색\n# 그리고 다음 node도 그 다음의 node.next를 넣어서 계속 반복\n\ndef __iter__(self):\n    node = self.head\n    while node is not None:\n        yield node\n        node = node.next\n```\n\n\n* Insert \n\n```python\n# 그냥 head에 넣으면 된다\n\ndef add_first(self, node):\n    node.next = self.head\n    self.head = node\n```\n\n* Inserting at the end\n\n```python\n# 첫번째 head 부분을 체크 한 후\n# for 문으로  \ndef add_last(self, node):\n    if self.head is None:\n        self.head = node\n        return\n    for current_node in self:\n        pass\n    current_node.next = node\n```\n\n\n\n\n```python\n\nclass Node:\n    def __init__(self,value, next=None):\n        self.value = None\n        self.next = None\n\nclass Queue:\n    def __init__(self,value):\n        self.front = None\n        self.rear = None\n        \n        \n    def push(self, value):\n        # 첫번쨰 노드가없다면. \n        # 바로 노드를 연결 시킨다 \n        if self.front is not None:\n            self.front = Node(value, next=None)\n        \n        # 첫번째 노드가 있다면\n        temp = self.front\n        self.front.next = temp\n        self.front = Node(value, next=None)\n        \n    def pop(self):\n        if self.front is not None:\n            return 0\n            \n        node = self.front \n        \n        while node is Not None:\n```\n\n\n\n![image](https://user-images.githubusercontent.com/56494905/160309198-fe3d1c08-74b0-4518-ab21-007a0a359a6d.png)\n\n\n\n* 스택(Stack)\n\n![image](https://user-images.githubusercontent.com/56494905/160309232-b3bd639a-acf0-492b-92d7-6db2c546c421.png)\n\n\n* 그래프(Graph)\n\n![image](https://user-images.githubusercontent.com/56494905/160309407-75f23fdf-e5f9-40aa-9492-79e4feba5d58.png)\n \n\n\n\n## 연습 \n\n\n## 파이썬문법 모르는 부분 \n\n## Ref\n* [Link](https://www.tutorialspoint.com/python_data_structure/python_stack.htm)\n* [Real python](https://realpython.com/linked-lists-python/)\n"])</script><script>self.__next_f.push([1,"28:Tb9f,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# Object란?\n- Objects\n    * One of the JavaScript's data types\n    * a collection of related data and/or functionality\n    * Nearly all objects in JavaScript are instances of Object\n    * object = { key : value}\n\n\n\n## Literals and properties \n\n```javascript\nconst obj1 = {} // 'object literal' syntax\nconst obj2 = new Object() // 'object constructor' syntax\n\nprint(name, age)\n\nfunction print(person) {\n    console.log(person.name)\n    console.log(person.age)\n}\n\nconst ellie = { anme: 'ellie', age:4} //바로 객체를 만들 수 있음 \nprint(ellie)\n\n\nellie.hasJob = true  //이미 다 정의되어 있어도 그냥 넣어 줄 수 있지만 좋은 생각은 아니다\nconsole.log(ellie.hasJob)\n\n\n// can delete properties later\ndelete ellie.hasJob // 삭제 까지도 가능함\n```\n## Computed properties\n```javascript\n\n//key should be always string\nconsole.log(ellie.name) // 아래와 같은걸로 출력할 수 있다\nconsole.log(ellie['name']) //배열처럼 출력할 수 있다\n//어떤키가 필요한지 모를때 이렇게 쓴다\nellie['hasJob'] = true\nconsole.log(ellie.hasJob)\n\nfunction printValue(obj, key){\n    console.log(obj[key])\n}\nprintValue(ellie, 'name')\n```\n\n## Property value shorthand\n\n```javascript\nconst person1 = {name: 'bob', age:2}\nconst person2 = {name: 'steve', age:3}\nconst person3 = {name: 'dave', age:4}\n\n\nconst person4 = makePerson('elli', 30 )\n\nconst person5 = Person('elile', 30)\n\nfunction makePerson(name, age){\n    return{\n        name, \n        age, //name : name 생략 가능\n    }\n}\n//이렇게 함.. \n\n\n//4. constructor Function\nfunction Person(name, age){\n    this.name = name\n    this.age = age\n}\n```\n\n\n\n\n## in operator: property existence check (key in obj)\n```javascript\nconsole.log('name' in ellie) //true\nconsole.log('age' in ellie)\nconsole.log('random' in ellie) //false\nconsole.log(ellie.random)//undefined\n```\n\n## for..in vs for .. of\n```javascript\n//for (key in obj)\n\nfor (key in ellie) {\n    console.log(key) //ellie 안에 있는 모든 키를 가져옴\n}\n//for (key of obj)\nfor (value of interable){\n    console.log(value)// 순차적인 배열이 있는 모든 요소를 가져옴\n}\n\n```\n\n\n## Fun cloning\n```javascript\nconst user = {name: 'ellie', age: '20'}\n\nconst user2 = user\nuser2.name = 'coder'\nconsole.log(user) // 두개다 객체의 주소를 가르키기 때문에 가르키고 있는 내용은 변경된다\n\n//따라서 오브젝트를 그대로 복사하고 싶으면\nconst user3 = {}\nfor (key in user){\n    user3[key] = user[key]\n}\nconsole.log(user3) //옛날 방법\n\n//다른 방법으로는\n//기본지원으로 언제든지 사용할 수 있음\nconst user4 = Object.assign(user4, user)\n\n//another example\nconst fruit1 = { color: 'red'}\nconst fruit2 = { color: 'blue', size: 'big'}\nconst mixed = Object.assign({}, fruit1, fruit2)\n\nconsole.log(mixed.color) //뒤에 있는 fruit2가 fruit1을 덮어 씌운다\n//즉 fruit2 가 출력된다 color: blue size : big\nconsole.log(mixed.size)\n```\n"])</script><script>self.__next_f.push([1,"29:Te7f,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 인터뷰 예상 50문제 \n\u003e 항해측에서 제공하는 기본 50문제이다. 조금씩 채워 나가면서 면접을 준비 하자\n\n## var, let, const가 어떻게 다른가요?\n- var는 동일 이름으로 변수 선언시 에러가 안나고 , 코드량이 많아지면 오류를 찾기 힘듬\n- let은 동일 이름으로 변수 선언시 에러가 나고, let과 const와 다른점은 immutable 과  mutable\n- let은 변수를 재할당 할 수 있지만, const는 변수 재할당시 바꿀수 없다. 단 객체는 바꿀수 있다. (객체의 주소값을 바꿀수 없다.)\n\n## Event Loop가 무엇인가요? \n- Event loop 란 ...\n\n## Express의 역할은 무엇인가요?\n* npm과 yarn 각각에 대해 설명해주세요\n    - npm은 일렬로 작업으로 속도가 느리지만 yarn은 병렬로 설치되어 빠르다\n    - 둘다 패키지 종속성과 버전 번호를 추적한다.\n    - yarn은 항상 yarn.lock 파일을 생성 하고 업데이트한다.\n    - 보안성 측면으로 yarn이 조금더 보안이 좋다.\n    \n## event-driven programming에 대해 아시나요?\n## Promise에 대해 아시나요?\n## Node.js 의 장단점을 설명해주세요\n## 콜백지옥 해결방안에 대해 아는대로 설명해주세요\n## Signle Threaded Async가 무슨 뜻인지 아시나요?\n## 비동기 처리 Promise와 async/await의 차이에 대해 설명해주세요\n## REST API에 대해 설명해주세요\n## OOP에 대해 설명해주세요\n## GET,POST는 어떻게 다른가요?\n## Node.js를 사용해야 하는 이유가 있나요?\n## Node.js의 동작 원리를 설명해주세요\n## I/O 논블로킹에 대해 아는대로 설명해주세요\n## 웹 서버가 무엇인가요? WAS와 WS가 어떻게 다른가요?\n## Node.js에서 fork()와 spwan() 메소드의 차이는 무엇인가요?\n## 실행 컨텍스트에 대해 아는대로 설명해주세요\n## 콜백함수가 무엇인가요?\n## axios를 사용해본 경험이 있나요?\n## 호이스팅이 무엇인지 설명해주세요.\n- 선언문들은 제일 위로 올라가 제일 처음으로 읽히게 된다.\n- ES6에서는 let, const,function, class 등이 호이스팅 된다.\n- 선언 -\u003e 초기화 -\u003e 할당 \n\n## 클로저에 대해 설명해주세요.\n## WAS(nginx)는 어떤 이유로 사용하나요?\n## _proto_를 아시나요? 어떻게 사용하는지 설명해주세요\n## 동기와 비동기의 차이는 무엇인가요?\n## package.json이 꼭 필요한가요?\n## cors가 무엇인가요?\n## npm를 사용하는 이유는?\n## xs공격에 대해 아시나요?\n## Git을 사용해 협업한 경험이 있나요? 어떻게 사용했나요?\n## ORM을 사용해본 적 있나요?\n## this의 용법에 대해 아는대로 설명해주세요\n## 무한 스크롤을 구현해본 적 있나요? 방법은?\n## JWT에 대해 설명해주세요\n## Oauth에 대해 설명해주세요\n## 미들웨어의 역할이 무엇인가요?\n## moment를 사용하였다면 어떻게 사용하였는지, 그리고 그 이유는?\n## super, prototpype에 대해 아시는게 있다면 애기해주세요\n## 스택과 큐에 대해 설명해주세요\n## 힙에 대해 아는 것이 있다면 얘기해주세요\n## 알고있는 정렬의 종류에 대해 설명해주세요\n## 데이터에 대한 연산을 DB내에서 하는게 좋을까요? 서버에서 하는게 좋을까요?\n## 세션과 쿠키에 대해 설명해주세요.\n## Array.length의 시간 복잡도는 몇일까요?\n## setTimeout 함수를 실행했을 때 일어나는 과정에 대해 얘기해주세요.\n## 주소창에 naver.com을 쳤을 때 일어나는 과정을 설명해 주세요.\n## * TCP와 UDP의 차이에 대해 알려주세요.\n\n\n추가\n"])</script><script>self.__next_f.push([1,"2a:T843,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 트리(tree) \n## 기본개념 \n\n\u003e 각 노드가 m개 이하의 자식을 갖고 있으면, m-ary 트리(다항트리, 다진트리)라고 한다.\n- 노드의 차수가 2 이하일때 `이진트리`\n\n\n\n* 정 이진트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는다.\n* 완전 이진 트리(Complete BInaray Tree) : 마지막 레벨을 제외하고 모든 레벨이 완전히 체워져 있으며, 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있다.\n* 포화 이진 트리(Perfect Binary Tree) : 모든 노드가 2개의 자식 노드를 갖고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다. 문자 그대로, 가장 완벽한 유형의 트리다\n\n\n* 이진탐색(Binary Search Tree)\n\n* 이진트리(Binary Tree)\n\n## 문제풀이\n### 교재 내용\n * [[Leetcode-104]] Maximum Depth of Binary Tree \n  - 반복 구조로 BFS 풀이 \n  \n### leetcode solution\n\n## 풀면서 잘 몰랐던 부분 \n\n## 파이썬문법 모르는 부분 \n\n## 용어 개념\n* node: 트리에서 데이터를 저장하는 기본 요소 \n* Root Node: 트리 맨 위에 있는 노드\n* Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄\n* Parent Node: 어떤 노드의 상위 레벨에 연결된 노드\n* Child Node: 어떤 노드의 하위 레벨에 연결된 노드\n* Leaf NodeTerminal Node)(: Child Node가 하나도 없는 노드\n* Sibling: 동일한 Parent Node를 가진 노드\n* Depth: 트리에서 Node가 가질 수 있는 최대 LeveliNode: 트리에서 데이터를 저장하는 기본 요소 \n* Root Node: 트리 맨 위에 있는 노드\n* Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄\n* Parent Node: 어떤 노드의 상위 레벨에 연결된 노드\n* Child Node: 어떤 노드의 하위 레벨에 연결된 노드\n* Leaf NodeTerminal Node(: Child Node가 하나도 없는 노드\n* Sibling: 동일한 Parent Node를 가진 노드\n* Depth: 트리에서 Node가 가질 수 있는 최대 Level))\n"])</script><script>self.__next_f.push([1,"2b:Td07,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n\n\n# 항해 플러스 후기\n## 항해 플러스는 무엇인가?\n\u003e 1~3년차 주니어 개발자를 대상으로 다양한 경험을 할 수 있도록 사이드 프로젝트를 하면서 좀 더 발전하게 하는 부트캠프이다.\n1. TDD 경험\n2. CI/CD\n3. 장애 대응 훈련\n4. AutoScaling\n5. 오픈소스배포하기 \n\n## 왜 지원하게 되었나?\n\u003e 사실 대용량 처리, 마이크로서비스에 대한 강한 욕심때문에 신청했지만 TDD도 지금 하고 있지 않기때문에 실제로 어떻게 하는지 궁금했다.\n\n## 과거 개발 경력? \n\u003e 오래전에 컴공졸업 -\u003e 10년동안 다른일 함 -\u003e 중간중간 취미로 개발함 -\u003e 항해 99 졸업 -\u003e 취업 -\u003e 약 10개월차에 플러스시작 \n \n- Koajs, Nestjs를주로 다루며 조금씩 프론트도 하고 있다.. (하...)\n\n## 좋았던 점\n- 팀 프로젝트, 멘토링, 네트워킹, 특강 등 과정을 참여하며 실제로 가치가 크다고 느낀 것들\n* 코치진의 무한 에너지\n    - 다양한 경험을 가지고 있는 코치진들의 코치들이 정말 좋았었다.\n* 팀 프로젝트\n    - 모두 현직자이다 보니 열정적이기도 하고 적극적으로 참여해서 수월했다.\n    - 맨날 나만의 코드만 작성했는데 다른 사람들의 코드도 볼 수 있어서 좋았다.\n* 네트워킹\n    - 중간중간 소개팅 처럼 테이블을 돌아가면서 서로 알아가는 시간을 가지기도 했다.\n* 특강\n    - 오프라인 모임을 가게 되면 매주 약간의 이벤트로 유명하신 분들을 섭외해서 특강 및 질의 응답을 진행했다.\n    - vercel 최초 스카웃되신 분도 와서 질의 응답을 했다.\n\n## 결과물 \n- [Vetty](https://github.com/hgh9/vetty-backend)\n- [Dummy-generator](https://github.com/team-opensource-plus/dummy-generator)\n- [Dummy-generator npm](https://www.npmjs.com/package/dummy-generator)\n\n## 앞으로 도전해야 할것 \n* vetty : 마이크로 서비스로 nestjs 분산 처리\n    - kubernetes 사용해서 만들어 보고 싶다.\n* dummy-generator : 실사용에서도 사용할 수 있게 고도화\n    - nestjs entity로 만으로도 더미 데이터를 생성할 수 있도록\n    - mysql 이나 다른 디비에도 cli로만으로 삽입할 수 있도록\n\n\n## 소감 및 항해 플러스를 고민하는 분들에게 한마디\n* 일단 회사가 바쁘면 굉장히 어렵다.\n    - 중간에 대부분 나가신 분들은 바쁘신 분들이 많았다.\n    \n* 프론트에 관련된 내용은 거의 없다.\n    - 프론트를 하시는 분들중 백엔드에 관심없는 분들은 대부분 나가신거 같다.\n    \n* 지금 회사에서 TDD나 CI/CD를 해본적이 없으면 적극 추천한다.\n    - 난 소규모 스타트업에 일하고 있어서 TDD를 안하고 있다. 이렇게라도 해봐야 적용을 할 수 있을거 같다.\n    - CI/CD는 대부분 한번은 해보는 것이 좋긴한데 회사에서 미리 구현이 되어 있으면 해볼 기회가 없다.\n    \n* 다음 이직에 관한 다양한 정보들을 얻을 수 있다.\n    - 현직 분들이기때문에 굉장히 현실적인 조언을 많이 들을 수 있다.\n    - 추가 적으로 조금 더 친해지면 이력서 코칭도 받을 수 있다.\n    - 현재 커리어에 대한 고민들도 잘 들어주신다.\n\n\n\n\n"])</script><script>self.__next_f.push([1,"2c:T1bb4,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 항해플러스 1기 참가\n## 왜 참가했을까?\n     - 지금 내가 대용량 처리 및 TDD를 경험해 볼 수 없는 환경이다.\n     - 대용량 트래픽과 TDD에 대한 호기심 끝없는 욕구를 충족 시켜줄까 싶어 신청했다.\n\n## 챕터1\n### TDD를 해라\n* 과제\n    - 첫번째 과제가 주어지고 팀원들도 구성이 되었다.\n    - 첫날 발제 내용이 명확하지 않아 보였다. \n     ## 우리팀의 테스트 시나리오 -\u003e 설계 -\u003e 코딩 관련 전략들\n    \n    - 우리가 TDD 방법론과 설계의도를 소화한 방식\n    - - solid원칙을 지키는지에 대한 설명 포함\n    \n\n### 서버 구축  (2023-07-02)\n- 챕터 1  4주차 발제 \n    * 시간이 너무 부족하다. 특히나 하고 있는게 많고, 회사 배포일정까지 늦어지면서 굉장히 신경쓰이는 일이 많아 제대로 집중을 못하고 있다. 하지만 다른분들은 열심히 해주신 덕분에 피드백을 참조하면서 작성을 하고 있다.\n    * 일단 코치님의 실업무를 기반한 조언들이 굉장히 자극을 주기 충분했다. 객체지향이란 것에 대한 생각, 같은 코드를 짜더라도 어떻게 의미 전달을 더 잘할 수 있을까에 대한 생각. TDD에 원론적인 방법과 현실을 조금씩 알게되었다.\n- Nestjs를 계속 이용하면서 좀더 깊게 알게 되는거 같았고 이미 알고 있다고 한것중에 잘못된 부분도 팀원의 도움으로 알게 되었다.\n- 예를 들어 DTO같은 경우 Entity와 혼용해서 사용했는데... (뭐 현회사에는 Entity가 interface로 되어있긴하다...) 같이 swagger 데코레이터랑 혼용해서 엉망으로 하고 있긴하다. 그런데 Entity와 Dto의 분리는 명확해야한다는걸 알게되었다.\n- 객체지향의 대한 방법과 철학을 느낌으로 알지만 아직까지 잘모르는 거 같다. 내가 이해한 바로는 컨트롤러, 서비스, 각각에 도메인에 대한 내용만 최대한 넣어야 하며 리펙토링 과정에서 생기는  다른 함수 또는 클래스는 독립적으로 작동이 되어 최대한 다른 서비스에 영향을 끼치지 않아야 한다. 아니 끼치지 않게끔 설계를 해야한다. 즉 독립적인 메소드에 대한 테스트 코드가 가능해지고 레포지토리에 대한것은 그냥 외부 모듈로서 데이터를 찍고 온다는 느낌으로 가는 것이다 라고 이해했다.\n- 처음으로 경력분들과 일하게 되면서 다양한 의견과 코드 스타일 의논도 많이 하게 되었고, 조율하는데 있어서 새로운 경험이 되었다. 아직 조그만한 스타트업을 다니면서 혼자 또는 CTO님의 코드리뷰를 받기만 했지 따로 동등한 위치의 팀원과 코딩을 한건 이번에 처음이다.\n- 순수 TDD로만 개발하는 단계여서 그런지 다들 어떻게 해야할지 막막하고 생각도 많아 초반에는 진도가 정말 안나갔다. 하지만 한번 두번 테스트 코드를 작성하고 피드백을 받으면서 자기만의 스타일 + 코치님의 조언대로 이렇게 저렇게 해보면서 테스트 코드를 작성하니 훨씬 도움이 많이 되고 방향성을 잡을 수 있었다.\n- 아마도 항해 파트1기다 보니 실험적인 측면 + 다양한 시도를 해보고 있는 느낌을 받았다.\n- 생각보다 이탈자가 많이 보이는 듯 하다. 이유는 나도 느끼고 있지만 현업 + 공부 + 프로젝트까지 하기가 정말 힘들다.\n- 토요일은 하루종일 코딩만 한다고 생각하면 된다. 하루가 없어진다....\n- 아무튼 힘들긴 하지만 이것만 집중했더라면 재미있게 진행할 수 있을거 같다.\n\n### CI/CD (2023-07-08)\n- 굉장히 힘들었던 주차 였다.\n\n\n### 장애 대응\n\n### 프로젝트 발표\n\n### 회고\n\n## 챕터 5\n\n### 팀구성\n- \n\n### 오픈 소스 팀구성\n-\n\n\n\n\n\n\n\n\n\n\n\n## 마지막 회고\n- \n\n### 나는 누구?\n그냥잡부 였다. 이리저리 떠돌아 다니며 닥치는대로 일을 하면서 이것저것 했었고, 살기 위해 직업을 구했던거 같았다.\n\n### 왜 갑자기 개발자?\n원래 뼈속까지 개발자라고 하면서 어릴때 컴퓨터를 만지면서 놀곤 했다. 컴퓨터와 관련된것이라면 다 좋았다. COMMAND를 만지면서 DOS를 이리저리 만져보고 레드헷 리눅스를 설치하면서 나만의 홈페이지를 만들고 집에 2대의 컴퓨터를 이용해 네트워크를 구성하면서 APM을 설치하면서 웹서버도 설치해보고 그랬다. 그러던 내가 대학교에서도 열심히 컴퓨터 공부를 하다가 해외를 나가서 내 살길을 찾고자 10년동안 다양한 일들을 하면서 방황했다. 그리고나서 펜데믹이 터지고 아무것도 안할 바에는 어릴떄부터 꿈이었던 개발자를 다시 도전해보겠다며 독학으로 공부했다.\n\n### 독학의 한계\n옛날의 개발환경이랑 지금의 환경은 천지 개벽할 수준이었다. 일단 에디터부터 완전히 달라졌다. 내가 사용하던떄는 plusedit라는 사실상 메모장같은데에서 코딩을 했던 기억이 있다. sql은 지금도 쓰긴 하지만 phpadmin이라는 무료 DB매니져 프로그램을 썼고 무조건 로컬에 이리저리 환경변수를 설정하고 나서야 코딩이 가능했다. 그러나 지금은 vscode, 익스텐션, docker 등등 엄청나게 편리한 개발 환경들이 이미 존재하고 있어 밥을 떠먹여 주는 느낌이었다. \n\n그러나 처음 내가 혼자 독학으로 하기에는 한계가 있었다. 일단 내가 포트폴리오를 만들어서 이력서에 넣을 만한 실력도 안될뿐더러 내가 지금 잘하고 있는가 못하고 있는가에 대한 기준도 모호했다. 그래서 어쩔수 없이 빠른 포트폴리오를 위해 부트캠프라는것을 찾아서 구글 제일 위에 있던 것을 찾아서 신청했다. 돈은 ... 어떻게든 되겠지\n\n### 항해라는 부트캠프\n계속 해외에 살고 있어서 여기가 정화기 뭐하는곳인지는 그냥 모르겠고 일단 3개월만에 포트폴리오를 만들어준다고 해서 신청한것 뿐이었다. 이건 항해 후기를 남기려다 만거에 보면 ... [항해]\n\n### 어째든 취업\n운이 좋게 취업을 해서 지금까지 1년이라는 시간동아 백엔드를 개발을 했다.\n\n\n### \n\n\n### 1) 항해 플러스를 참여하기 전 백그라운드\n\n- 개발자 취업 과정, 현업에서 어떤 직무로 일하고 있는지 등\n\n### 2) 항해 플러스 1기에 합류하기로 결심한 이유\n\n### 3) 항해 플러스가 실제로 좋았던 부분\n\n- 팀 프로젝트, 멘토링, 네트워킹, 특강 등 과정을 참여하며 실제로 가치가 크다고 느낀 것들\n\n### 4) 결과물\n\n- 두 개 프로젝트 결과물 github\n\n### 5) 앞으로 더 도전해보고 싶은 것\n\n- 10주 과정을 통해 얻은 것들을 바탕으로 앞으로 더 도전해보고 싶은 것들\n\n### 6) 소감 및 항해 플러스를 고민하는 분들에게 한마디\n\n\n\n"])</script><script>self.__next_f.push([1,"2d:T17f9,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# 해시테이블 (hash table) \n\n## 기본개념 \n- 해시는 어떤 키값을 지정해서 그 키값을 가지고 찾아 linkedlist 또는 배열로 넣는 방식이다\n- indexing -\u003e 해시 함수를 이용하는 것을 hasing 이라고 한다\n- hasing : 검색을 빠르게 저장하고 검색하기 위해 사용\n    * hasing 은 최적의 검색이 필요한 분야에 사용됨\n    * 암호화 알고리즘에 사용 한다\n\n\n- 해시 함수 사용시 주의해야 할점 \n    * 해시 함수 값 충돌의 최소화\n    * 쉽고 빠른 연산\n    * 해시 테이블 전체에 해시 값이 균일하게 분포\n    * 사용할 키의 모든 정보를 이용하여 해싱 \n    * 해시 테이블 사용 효율이 높을 것\n\n## 생일 문제 \n\n365명중생일이 같을 경우는 365명 이상 모일경우에 중복될 확율은 기하 급수적으로 늘어난다.\n이를 [[pigenhole-principle]]{비둘기집 원리}[^Pigenhole-principle] 라고한다\n\n\n## 로드 펙터[^Load-Factor]\n* 해시 테이블의 크기를 조정해야 할지는 `로드 펙터`에 따라 달렸다\n* 해시 함수가 잘 작동되는가 효율성 측면에으로도 나타낸다 \n\n\n## 해쉬 함수\n해싱에는 여러 알고리즘이 있는데 데이터에 따라 각각 다른 효과를 나타낸다\n\n- 정수형 해싱 기법\n    * 모듈로 연산을 이용한 나눗셈 방식(Modulo-Division Method)\n    \n    $$ h(x) = z\\ mod\\ m $$\n    \n    \n    \n## 충돌\n* 아무리 좋은 해시 함수라도 충돌(Collision)은 발생하게 된다.\n\n| key | hash function   | hash |check |\n| :-:   | :-:               | :-------:    |:-:|\n| a     | hashFucntion(a) | 0    ||\n| b | hashFucntion(b) | 1    ||\n| c | hashFucntion(c) | 2 | crashed |\n| d | hashFucntion(d) | 2 | crashed |\n\n## 개별 체이닝(Sepraret Chaining)\n* 충돌이 일어나면 링크드리스트로(linkedlist)로 충돌한 내용을 순차적으로 관리한다\n* 전통적인 방법으로 보통 `해시 테이블`이라고 한다\n\n| key | hash function   | hash | linked list|\n| :-:   | :-:               | :-------:    |:-:|\n| a   | hashFucntion(a) | 0    ||\n| b | hashFucntion(b) | 1    ||\n| c | hashFucntion(c) | 2 | (c,2)        |\n| d | hashFucntion(d) | 2 | (c,2)-\u003e(d,2) |\n\n\n \n\n## 오픈 어드레싱(Open Addressing)\n* 충돌 발생시 빈공간을 찾아 나서는 방식이다\n* 전체 슬롯의 개수 이상은 저장할 수 없다\n\n\n| key | hash function   | hash      | index                      |\n| :-: | :-:             | :-------: | :-:                        |\n| a   | hashFucntion(a) | 0         | 2                          |\n| b   | hashFucntion(b) | 1         | 5                          |\n| c   | hashFucntion(c) | 2         | 7                          |\n| d   | hashFucntion(d) | 2         | findNextEmptySlot(d) -\u003e 17 |\n\n## 언어별 해시 테이블 구현 방식\n- Python dictionary\n    * 해시테이블로 구현된 파이썬의 자료형을 제시 -\u003e dictionary\n    * Dictionary -\u003e 오픈 어드레싱 방식으로 구현\n\n\u003e체이닝 시 malloc으로 메모리를 할당하는 오버헤드가 높아 오픈 어드레싱을 택했다\n\u003e\u003cbr\u003e\u003e 연결리스트 사용시 추가 `메모리 할당`이 필요하고 할당 작업은 상대적으로 `느리기 때문`이다\n\n* 연결리스트는 80%이상 차게 되면 급격한 성능 저하가 일어난다\n* 선형 탐사는 공간이 찰수록 탐사에 점점 더 오랜 시간이 걸린다\n* 파이썬은 로드 팩터를 낮게 잡아(0.66)  성능을 극대화 시킨다\n\n\n## 해시맵 디자인\n- 해시맵 구현시 아래와 같은 method가 필요하다\n    * put(key, value) : 키 값을 해시맵에 삽입한다. 이미 존재하는 키면 업데이트한다\n    * get(key) : 키에 해당하는 값을 조회한다. 만약 키가 존재하지 안흔다면 -1을 리턴한다\n    * remove(key) : 키에 해당하는 키, 값을 해시맵에서 삭제한다\n    \n    \n```python\nimport collections\n\nclass ListNode:\n    def __init__(self, key=None, value=None) -\u003e None:\n        self.key = key\n        self.value = value\n        self.next = None\n\nclass MyhashMap:\n    # 초기화 \n    def __init__(self):\n        self.size =1000\n        self.table = collections.defaultdict(ListNode)\n\n    \n    #삽입 \n    def put(self, key: int, value: int) -\u003e None:\n        index = key % self.size\n        # 인덱스에 노드가 없다면 삽입 후 종료\n        if self.table[index].value is None:\n            self.table[index] = ListNode(key, value)\n            return\n\n        # 인덱스에 노드가 존재하는 경우 연결 리스트 처리\n        p = self.table[index]\n        while p:\n            if p.key == key:\n                p.value = value\n                return\n            if p.next is None:\n                break\n            p = p.next\n        p.next = ListNode(key, value)\n\n    # 조회\n    def get(self, key: int) -\u003e int:\n        index = key % self.size\n        if self.table[index].value is None:\n            return -1\n\n        # 노드가 존재할 때 일치하는 키 탐색\n        p = self.table[index]\n        while p:\n            if p.key ==key:\n                return p.value\n            p = p.next\n        return -1\n\n    # 삭제\n    def remove(self, key: int) -\u003e None:\n        index = key % self.size\n        if self.table[index].value is None:\n            return\n        \n        #인덱스의 첫 번쨰 노드일 때 삭제 처리\n        p = self.table[index]\n        if p.key == key:\n            self.table[index] = ListNode() if p.next is None else p.next\n            return\n        \n        #연결 리스트 노드 삭제\n        prev = p\n        while p:\n            if p.key == key:\n                prev.next = p.next\n                return\n            prev, p = p, p.next\n```\n\n# ref\n이것이 코딩테스트다\n   \n\n# 주석\n[^Pigenhole-principle]: n개 아이템을 m개 컨테이너에 넣을때, n\u003em이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리를 말한다\n[^Load-Factor]: 로든 팩터란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈것이다\n"])</script><script>self.__next_f.push([1,"2e:T5b1,* TOC\n{:toc}\n\n# 레포에 ENV파일이 올라갔다면?\n## 상황\n\u003e ENV파일을 설정하던 도중 팀원 중 한명이 ENV파일이 PUSH되어 레포에 업데이트 되었다.\n당연히도 파일을 삭제하면 그래도 기존에 있던 내용이 삭제 되었다고 하며 기록이 남는다.\n이럴때는 뒤로 돌아가야 한다.\n\n이럴떄는 두가지 방법이 있다.\n* CLI로 확인하는방법\n    - git reflog로 hitory를 확인한다.\n    - 확인한 head의 넘버를 확인한다. \n     ```git\n      $ git reflog\n        b1333f5 (HEAD -\u003e main, origin/main, origin/HEAD) HEAD@{0}: commit: fix url2\n        2601e68 HEAD@{1}: commit: fix url\n        7195cc7 HEAD@{2}: commit: update\n        6cc429a HEAD@{3}: commit: theme change\n        3fb97a2 HEAD@{4}: reset: moving to HEAD~\n        5e8ebb6 HEAD@{5}: commit: theme change\n     ```\n    - 위 내용을 보고 어디까지 내려가야 하는지 확인한다\n    - git reset --hard HEAD~1(2601e68으로 되돌아간다)\n    - git commit -m \"return to back\"\n    - git push \n    \n* gitLens로 확인\n    - ![image](https://user-images.githubusercontent.com/56494905/173245735-3c3e81d1-6893-4c02-b5e4-dbc31ad121a0.png)\n    - ![image](https://user-images.githubusercontent.com/56494905/173245816-4cd3a450-85e3-4df4-b570-c49983830c1a.png)\n    - ![image](https://user-images.githubusercontent.com/56494905/173245801-560d33cd-6d9e-4c0c-82a3-b6ae210949c6.png)\n    - commit 하고 push  \n    \n\n2f:T9b8,"])</script><script>self.__next_f.push([1,"* TOC\n{:toc}\n\n# \n## 기본개념\n\u003e 트리기반의 자료구조로 데이터에서 `최대값과 최소값`을 빠르게 찾기 위해 고안된 `완전 이진 트리`(Complete Binary Tree)\n\n\n## 특징\n* 최대값\n- 항상 큰값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다.\n- 부모노드 \u003c  자식 노드 \n\n* 최소값\n- 자식노드 \u003e 부모노드\n\n* 2n+1 부터 시작하는게 편하다\n\n\n* 이미 파이썬에는 함수로 내장되어 있다\n- [링크](https://docs.python.org/ko/3.9/library/heapq.html?highlight=heap#module-heapq)\n- [[python-heapq]]{힙큐에대한 내용은여기} \n\n## 함수 설명 (max heap)\n\n\n### `__init__`\n\u003e 배열을 만들어 초기화 \n    1. [None]으로 초기화하여 인덱스를 1부터 카운팅\n\n```python\ndef __init__(self):\n    self.items = [None]\n```\n\n### `__len__`\n\u003e Magic method 로 기존에 내장되어 있던 len함수를 overriding 해서 나만의 함수로 만든다 \n\n```python\ndef __len__(self):\n    return len(self.items) - 1\n```\n\n### `push-up` (위로 올려 비교 )\n\u003e 현재 인덱스와 부모인덱스를 비교하여 자식노드의 값이 부모노드보다 작은면 바꾸기 \n\n```python\ndef _push_up(self):\n    cur = len(self)\n\n    parent = cur // 2 \n\n    while parent \u003e 0:\n        if self.items[cur] \u003e self.items[parent]:\n            self.items[cur], self.items[parent] =self.items[parent], self.items[cur]\n\n        cur = parent\n        parent = cur // 2 #2를 나눈 나머지는 버린다\n```\n\n\n### `push-down` (밑으로 내려서 마지막에 있을때 삭제)\n\u003e 현재 인덱스의\n*  2 * cur \u003c- 왼쪽 노드\n*  2 * cur +1 \u003c- 오른쪽 노드 \n\n```python\ndef _push_down(self, cur):\n    biggest = cur\n    left = 2* cur\n    right = 2 * cur + 1\n\n    if left \u003c= len(self) and self.items[left] \u003e self.items[biggest]:\n        biggest = left\n    if right \u003c= len(self) and self.items[right] \u003e self.items[biggest]:\n        biggest = right\n\n    if biggest != cur:\n        self.items[cur], self.items[biggest] = self.items[biggest], self.items[cur]\n```\n\n\n### `insert` (추가)\n\u003e 값을 리스트에 넣어준다 그리고 push_up 함수를 불러와 계속 비교한다 \n\n```python\ndef insert(self, k):\n    self.items.append(k)\n    self._push_up()\n```\n\n\n### `extract` (추출)\n\u003e 값을 아래로 내리면서 제일 아래로 내리고 마지막은 삭제 그리고 \n\n\n## 문제풀이  \n### 교재 내용\n\n### leetcode solution\n\n## 풀면서 잘 몰랐던 부분 \n\n## 파이썬문법 모르는 부분 \n\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1gBIa67YwYncMlz2nwFiK\",\"p\":\"\",\"c\":[\"\",\"wiki\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"wiki\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"div\",null,{\"style\":{\"minHeight\":\"100vh\",\"display\":\"flex\",\"flexDirection\":\"column\"},\"children\":[[\"$\",\"$L3\",null,{}],[\"$\",\"main\",null,{\"style\":{\"flex\":1},\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"h2\",null,{\"children\":\"404 - Page Not Found\"}],[\"$\",\"p\",null,{\"children\":\"The page you are looking for does not exist.\"}]]}],\"notFoundStyles\":[]}]}],[\"$\",\"$L6\",null,{}]]}]}]}]}]]}],{\"children\":[\"wiki\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"wiki\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$L7\",null,{\"wikiFiles\":[{\"slug\":\"2022\",\"title\":\"2022년 메모\",\"tags\":[\"개발일기\",\"AWS\",\"Kubernetes\",\"Elastic Beanstalk\",\"프로젝트 경험\"],\"date\":\"2022-03-20 14:56:40 +0900\",\"content\":\"$8\",\"aiSummary\":\"다양한 경험과 반성을 담은 개발자의 일기 형식의 문서로, 프로젝트를 통해 배운 점과 어려움, 기술적 문제에 대한 고민 및 해결 과정을 서술하고 있다. AWS, Kubernetes, Docker, Elastic Beanstalk 등 현대 개발 환경에서의 실수를 통해 스스로 성장하는 과정을 담고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.248Z\"},{\"slug\":\"2023\",\"title\":\"2023년 메모\",\"tags\":[\"diary\",\"front-end\",\"CI/CD\",\"environment variables\",\"boolean conversion\"],\"date\":\"2022-03-20 14:56:40 +0900\",\"content\":\"$9\",\"aiSummary\":\"A collection of diary entries related to front-end development, CI/CD implementation, personal reflections, and technical challenges like handling environment variables and boolean conversions.\",\"lastProcessed\":\"2024-11-05T13:09:30.250Z\"},{\"slug\":\"2024\",\"title\":\"2024년 메모\",\"tags\":[\"개발 업무\",\"프로젝트 진행\",\"챗봇 기능\",\"RAG\",\"백엔드\"],\"date\":\"2023-01-01 13:00:20 +0900\",\"content\":\"* [[TOC]]\\n{:toc}\\n\\n## 2024-07-17 14:44:23\\n### 최근 근황\\n많은 일이 있었지만 몇 가지 일을 정리하면 아래와 같다\\n- 약파스 배너기능 업데이트 ( 프론트 업무)\\n- 약파스 예약 게시 기능 ( 프론트 업무)\\n- AI 요약기능 개발(백엔드) with Test 페이지 개발\\n- 오늘의 퀴즈 셋팅 및  배포 (beta test)\\n- Custom Inapp 알림 추가 개선\\n- 다재약물 서비스 (백엔드 구성)\\n- 즉문즉답 챗봇 기능 개발 테스트 및 연구\\n\\n\\n\\n## 2024-07-12 15:00:23\\n### 즉문즉답 챗봇 기능 평가 완료\\n약 3달간의 약문약답의 챗봇을 평가하는 시간이었다.\\nRAG를 이용한 챗봇의 기능이 어느정도의 유의미한 결과를 보여줄지에 대한 평가를 자동화 시스템을 만들어 평가 하였다.\\n- 대체적으로 결과는 좋았지만, 특정 질문에 대한 답변이 부족한 경우가 많았다.\\n- 원인으로는 RAG의 검색 결과가 좋지 않아서 발생한 문제로 보인다.\\n\\n\\n\",\"aiSummary\":\"기술 업무 일지를 통해 최근 개발 업무 및 프로젝트 진행 상황을 요약하고, 챗봇 기능 평가 결과를 언급하였습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.250Z\"},{\"slug\":\"most-common-word\",\"title\":\"819. 가장흔한단어\",\"tags\":[\"LeetCode\",\"프로그래밍 문제\",\"알고리즘\",\"문자열 처리\",\"자바스크립트\"],\"date\":\"2022-03-24 23:05:07 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\\n## URL\\n* [LINK](https://leetcode.com/problems/most-common-word)\\n\",\"aiSummary\":\"이 문서는 LeetCode 문제 중 하나인 '가장 흔한 단어'에 대한 내용입니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.285Z\"},{\"slug\":\"Amplify\",\"title\":\"Amplify를 사용해서 간단하게 배포하자(FrontEnd)\",\"tags\":[\"Amplify\",\"AWS\",\"백엔드\",\"프론트엔드\"],\"date\":\"2022-09-04 15:17:54 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Amplify란?\\n\u003e S3 베이스로 프론트엔드(또는 백엔드)를 간단하게 배포할 수 있는 AWS 종합 솔루션 원스탑 서비스다.\\n# 프론트엔드는 Amplify로 몇 분만에 배포하기 \\n\\n## 프론트(react) github에 준비하기\\n1. Github에 Push 하기  \\n    \\n\\n3. \\n\",\"aiSummary\":\"Amplify는 AWS의 종합 솔루션 서비스로 S3 베이스로 프론트엔드 또는 백엔드를 쉽게 배포할 수 있는 서비스입니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.251Z\"},{\"slug\":\"array-APIs\",\"title\":\"array 관해서 알아보자\",\"tags\":[\"JavaScript\",\"Array\",\"APIs\",\"Programming\",\"Web Development\"],\"date\":\"2022-04-05 20:20:55 +0900\",\"content\":\"$a\",\"aiSummary\":\"이 문서는 JavaScript의 배열(Array) 개념과 관련된 API 사용법을 설명합니다. 배열의 선언, 인덱스 접근, 반복문을 통한 배열 요소 출력, 추가 및 삭제 방법, 배열 결합 및 검색 방법 등을 다루고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.264Z\"},{\"slug\":\"arrow-function\",\"title\":\"Arrow Fucntion?\",\"tags\":[\"JavaScript\",\"Functions\",\"Arrow Function\",\"IIFE\",\"Programming\"],\"date\":\"2022-04-05 06:44:09 +0900\",\"content\":\"$b\",\"aiSummary\":\"이 문서는 자바스크립트의 함수 선언, 매개변수, 기본 매개변수, 지역 스코프, 값 반환, 조기 리턴 등 다양한 함수 기능을 설명하며, 특히 화살표 함수(Arrow Function)와 즉시 실행 함수(IIFE)에 대한 내용을 다룬다.\",\"lastProcessed\":\"2024-11-05T13:09:30.265Z\"},{\"slug\":\"async-defer\",\"title\":\"async 와 defer의 차이점\",\"tags\":[\"JavaScript\",\"async\",\"defer\",\"strict mode\",\"web development\"],\"date\":\"2022-04-01 22:31:01 +0900\",\"content\":\"$c\",\"aiSummary\":\"This document discusses the usage of 'async' and 'defer' attributes in script tags for loading JavaScript, explaining their differences with examples, and highlights the importance of using 'strict mode' in JavaScript programming.\",\"lastProcessed\":\"2024-11-05T13:09:30.265Z\"},{\"slug\":\"aws\",\"title\":\"AWS\",\"tags\":[\"AWS\",\"Cloud Services\",\"EC2\",\"S3\",\"Database\"],\"date\":\"2022-05-15 13:57:31 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 목차 \\n## EC2\\n## S3\\n## Codepipeline\\n## Amplify \\n## CloudFront\\n## CloudWatch\\n## RDS(Relational Database Service)\\n## Route 53(도메인 서비스)\\n## \\n\",\"aiSummary\":\"이 문서는 AWS(Amazon Web Services) 관련 서비스인 EC2, S3, Codepipeline, Amplify, CloudFront, CloudWatch, RDS, Route 53에 대한 내용을 포괄적으로 다루고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.266Z\"},{\"slug\":\"ElasticKubernetes\",\"title\":\"AWS \u0026 쿠버네티스\",\"tags\":[],\"date\":\"2022-09-01 21:00:14 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.256Z\"},{\"slug\":\"ElasticBeanstalk\",\"title\":\"AWS Elastic Beanstalk 사용방법\",\"tags\":[\"AWS\",\"Elastic Beanstalk\",\"EB-CLI\",\"Docker\",\"Node.js\"],\"date\":\"2022-05-15 13:56:05 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 개요\\n\u003eAWS Elastic Beanstalk는 Docker 또는 Node프로그램을 올려 백엔드 관리할 수 있다.\\n\\n## AWS EB-CLI\\n설치 방법은 github repo 클론 한다음 python을 설치해줘야 한다.\\n나는 wls 에서 작업하거나 맥 iterms fish 또는 zsh를 이용한다.\\n- [깃헙 레포](https://github.com/aws/aws-elastic-beanstalk-cli-setup)\\n\\n```bash\\n$ git clone https://github.com/aws/aws-elastic-beanstalk-cli-setup.git\\n\\n$ python .\\\\aws-elastic-beanstalk-cli-setup\\\\scripts\\\\ebcli_installer.py\\n```\\n\\n- 주의 할점은 아마도 git config 할때 등록한 이메일로 EB-ClI가 작동되는거 같다. 여러대의 컴퓨터를 이용하다가 각각 다른 이메일 주소로 GIT Config 를 해놨더니 기존에 AWS Free tier 가 끝난 계정에 여러 인스턴스가 만들어져서 300불이 나와 구제 요청 받아서 인보이스를 무효화 했다.\\n\\n\\n\\n\\n\",\"aiSummary\":\"AWS Elastic Beanstalk는 Docker 또는 Node 프로그램을 올려 백엔드를 관리할 수 있는 서비스입니다. AWS EB-CLI를 설치하는 방법과 주의할 점에 대해 안내하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.256Z\"},{\"slug\":\"backend\",\"title\":\"BackEnd\",\"tags\":[\"Documents\",\"Table of Contents\",\"Metadata\",\"Structure\",\"Organization\"],\"date\":\"2022-04-11 01:33:02 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Documents\\n\\n\\n\\n\",\"aiSummary\":\"The document appears to be a table of contents but lacks specific details or sections to summarize further.\",\"lastProcessed\":\"2024-11-05T13:09:30.266Z\"},{\"slug\":\"bfs\",\"title\":\"BFS(Breadth-First Search)\",\"tags\":[\"BFS\",\"Algorithm\",\"Graph\",\"Search\",\"Data Structure\"],\"date\":\"2022-04-05 17:26:46 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# BFS(Breadth-First Search)\\n* 주로 큐를 이용해서 구현한다\\n* \\n\\n\\n## graph exam \\n```python\\ngraph = {\\n    1 : [2,3,4],\\n    2 : [5],\\n    3 : [5],\\n    4 : [],\\n    5 : [6,7],\\n    6 : [],\\n    7 : [3],\\n}\\n```\\n\",\"aiSummary\":\"이 문서는 너비 우선 탐색(Breadth-First Search, BFS)에 대한 내용을 다루고 있으며, BFS가 주로 큐를 이용해 구현된다는 것을 설명합니다. 예제 그래프도 제공됩니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.267Z\"},{\"slug\":\"Certificate\",\"title\":\"Certificate Manager (과금)\",\"tags\":[\"과금\",\"구제 신청\",\"조심\"],\"date\":\"2022-07-03 23:41:52 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 과금 조심\\n\u003e 30일만 무료이다 조심히 쓰자. 과금이 너무 많이 나왔다. 이번에도 구제 신청을 했는데 잘 안된거 같다. 조심하자..\\n\",\"aiSummary\":\"30일 무료 이후 과금이 많이 나와 구제 신청이 어려운 상황에 대비하자.\",\"lastProcessed\":\"2024-11-05T13:09:30.252Z\"},{\"slug\":\"chapter4\",\"title\":\"Chapter 4. 전등을 분해해 봅시다.\",\"tags\":[\"전기신호\",\"CPU\",\"전압\",\"전류\",\"저항\"],\"date\":\"2022-03-21 09:27:48 +0900\",\"content\":\"$d\",\"aiSummary\":\"챕터 4에서는 전기신호를 통해 CPU와 상호작용하는 방법을 설명하며, 전압, 전류, 저항의 개념을 다룬다. 1(불을 킴)과 0(불을 끔)의 개념을 명확히 하여 CPU가 이해할 수 있도록 한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.268Z\"},{\"slug\":\"chapter11\",\"title\":\"chapter11\",\"tags\":[\"논리게이트\",\"논리회로\",\"스위치\",\"릴레이\",\"드모르간의 법칙\"],\"date\":\"2022-03-21 16:31:24 +0900\",\"content\":\"$e\",\"aiSummary\":\"이 문서에서는 논리게이트의 정의와 종류(AND, OR, NOT 등), 스위치와 릴레이의 차이점, 논리회로의 개념, 드모르간의 법칙에 대해 설명하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.268Z\"},{\"slug\":\"Cheerio\",\"title\":\"Cheerio 사용법\",\"tags\":[\"Cheerio\",\"jQuery\",\"Node.js\",\"web scraping\"],\"date\":\"2022-07-31 18:37:37 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Cheerio란? \\n\u003e Fast, flexible \u0026 lean implementation of core jQuery designed specifically for the server.\\n\\n\u003e 빠르고, 유연하게 특별하게 설계된 jquery의 빠르게 구현하기\\n\\n## 방법\\n- nodejs에서 원하는 웹사이트의 내용을 Jquery 변환하여 가져오는 것이다. \\n\\n\\n\",\"aiSummary\":\"Cheerio is a fast, flexible, and lean implementation of core jQuery designed for server-side use in Node.js.\",\"lastProcessed\":\"2024-11-05T13:09:30.252Z\"},{\"slug\":\"ci-cd\",\"title\":\"CI/CD(Continuous Integrateion/Continuous Delivery)\",\"tags\":[\"CI/CD\",\"지속적 통합\",\"지속적 제공\",\"웹 서비스\",\"배포 관리\"],\"date\":\"2022-04-05 14:38:56 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 작성중\\n\\n\\n\\n# CI/CD\\n- CI/CD(Continuous Integration/Continuous Delivery) \\n\\n## 지속적인 통합(Continous Integreation)\\n* 웹서비스를 운용한다라는 것은 장애 없이 즉 서비스의 멈춤 또는 에러 등이 발생하지 않는 것이 중요하다\\n* 그러나 유지보수중에 다양한 이유로 서비스에 장애가 생기기도 한다 \\n\\n\\n## 지속적 제공(Continous Delivery)\\n* 지속적인 배포를 \\n\\n\\n\\n## CI/CD 이용의 장점\\n* 단시간의 배포 시간\\n* 오류처리 및 롤백 가능한 시점을 설정할 수 있음\\n\\n\\n\",\"aiSummary\":\"이 문서는 CI/CD(지속적 통합 및 지속적 제공)의 개념과 이점에 대해 설명하고 있습니다. 특히, 장애 없는 웹 서비스 운영의 중요성과 CI/CD를 통해 얻는 장점인 단시간 배포 및 오류 처리 가능성에 대해 다룹니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.268Z\"},{\"slug\":\"class-vs-object\",\"title\":\"class \u0026 object\",\"tags\":[\"JavaScript\",\"클래스\",\"객체지향 프로그래밍\",\"ES6\",\"상속\"],\"date\":\"2022-04-05 11:22:35 +0900\",\"content\":\"$f\",\"aiSummary\":\"이 문서는 JavaScript의 클래스와 객체지향 프로그래밍을 설명합니다. 클래스는 객체의 템플릿을 정의하고, 객체는 그 템플릿을 기반으로 생성된 인스턴스입니다. ES6에서 도입된 클래스 문법, 생성자, getter/setter, static, 상속 및 instanceof 연산자를 포함한 여러 개념들이 포함되어 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.268Z\"},{\"slug\":\"CloudWatch\",\"title\":\"cloudwatch로AWS 과금을 책정하자\",\"tags\":[\"CloudWatch\",\"과금 확인\",\"Slack 통합\",\"Elastic Beanstalk\",\"배포 알림\"],\"date\":\"2022-07-04 22:39:14 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Cloudwatch 로 할수있는 것들\\n* 과금 확인을 할 수 있다.\\n* Slack으로 EB 관련 배포를 확인 푸시 받을 수 있다\\n\",\"aiSummary\":\"CloudWatch를 사용하여 과금 확인 및 Slack 통합으로 Elastic Beanstalk 배포 알림 수신이 가능합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.253Z\"},{\"slug\":\"Codepipeline\",\"title\":\"Codepipeline으로 CI/CD 구축하기\",\"tags\":[\"CodePipeline\",\"AWS\",\"Continuous Integration\",\"Continuous Deployment\"],\"date\":\"2022-07-06 22:02:31 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Codepipleine으로 구축하려면..\\n## \\n\\n\",\"aiSummary\":\"Using CodePipeline to build\",\"lastProcessed\":\"2024-11-05T13:09:30.253Z\"},{\"slug\":\"cognitoWithNestjs\",\"title\":\"Cognito UserPool을 이용한 인증(feat. nestjs)\",\"tags\":[\"AWS Cognito\",\"NestJS\",\"CTO\",\"프로젝트\",\"문제 해결\"],\"date\":\"2022-10-10 17:55:00 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 개요 \\n- CTO님염원을 해결해 드리고자 aws cognito를 공부하면서 실전 프로젝트에 적용한다.\\n- 어려웠던점과 해결방안 어떻게 구현했는지에 대해 조금씩 정리해보려고 한다.\\n- 장단점을 요약한다\\n\\n\\n## Cognito의 장점\\n## Nestjs와Cognito \\n\",\"aiSummary\":\"이 문서는 AWS Cognito를 실전 프로젝트에 적용하기 위한 학습 내용을 정리하며, 발생했던 문제와 그 해결 방법, 장단점을 논의한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.269Z\"},{\"slug\":\"cs-study\",\"title\":\"CS스터디\",\"tags\":[\"CS스터디\",\"자율학습\",\"Node팀\",\" 발표\",\"교재\"],\"date\":\"2022-03-21 09:27:48 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# CS스터디\\nCS스터디는 항해측에서 제공해주는 교재를 가지고 진행을 했다. \\n하지만 대부분 불만을 많이 해서 그런지 중간에 적당히 끊고 각자 맞는 방식을 선택해서 알아서 공부를 했다. \\n우리 Node팀은 7명밖에 안되서 한명씩 돌아가면서 사다리 타면서 발표를 했다.\\n\\n## 나는 2개의 챕터를 진행했다 \\n\\n* [[chapter4]]\\n* [[chapter11]]\\n\\n\\n\\n\\n\",\"aiSummary\":\"CS스터디는 항해측 제공 교재로 진행되었고, 참여자들은 중간에 자율학습으로 전환했다. Node팀은 7명으로 구성되어, 각자 발표를 진행했다.\",\"lastProcessed\":\"2024-11-05T13:09:30.270Z\"},{\"slug\":\"dfs\",\"title\":\"DFS(깊이 우선 탐색)\",\"tags\":[\"DFS\",\"Graph Traversal\",\"Algorithm\",\"Depth First Search\",\"Data Structure\"],\"date\":\"2022-04-05 15:03:39 +0900\",\"content\":\"$10\",\"aiSummary\":\"이 문서는 깊이 우선 탐색(DFS) 알고리즘에 대한 설명과 구현 방법을 다루고 있다. DFS는 그래프를 순회하는 방법 중 하나로 주로 스택이나 재귀를 통해 구현되며, 그래프를 표현하는 방법으로 인접 행렬과 인접 리스트를 소개한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.271Z\"},{\"slug\":\"Docker\",\"title\":\"Docker\",\"tags\":[\"Docker\",\"container\",\"network\",\"commands\",\"Docker-compose\"],\"date\":\"2022-03-25 06:38:42 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Docker? \\n\\n# 명령어 \\n* [[command]]{명령어}\\n\\n## docker image\\n\\n\\n## docker container \\n\\n\\n## docker compose\\n\\n\\n\\n## docker network\\n- none\\n    - 완전한 네트워크 독립 컨테이너 네트워크\\n- host\\n    - \\n- bridge\\n\\n- macvlan\\n\\n\\n## 명령어\\n- docker inspect nginx  : 지정한 컨테이너의 네트워크 설정을 확인\\n- ip a | grep docker0 \\n   \\n\\n## documnets\\n\",\"aiSummary\":\"This document provides an overview of Docker and various Docker commands related to images, containers, compose, and networks. It also includes examples of network types in Docker and command examples like inspecting container network settings.\",\"lastProcessed\":\"2024-11-05T13:09:30.254Z\"},{\"slug\":\"docker-basic\",\"title\":\"Docker basic\",\"tags\":[\"Docker\",\"Ubuntu\",\"SSH\",\"Virtualization\",\"Dockerfile\"],\"date\":\"2022-03-29 21:43:15 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 기본개념 \\n\u003e 나만의 이미지를 깃헙처럼 commit 해서 현재 상태를 유지하고 push 를 해서 이미지화 하여 똑같이 clone 을 해서 다른 시스템에 복붙할 수 있는 가상화 프로그램이다\\n\\n\\n\u003e 이 페이지에서는 dockerfile과 docker-compose.yml 파일을 셋팅해서 ubuntu에 ssh를 설치 하는거 까지 진행한다\\n\\n\\n## docker 설치 \\n\\n* mac \\n[download page](https://docs.docker.com/desktop/mac/install/)\\n\\n## dockerfile\\n적당한 폴더에서 dockerfile을 생성한다\\n\\n```bash\\n# touch dockerfile\\n# vi dockerfile\\n```\\n\\n\",\"aiSummary\":\"이 문서는 Docker를 사용하여 Ubuntu에 SSH를 설치하는 과정을 설명하며, Dockerfile과 docker-compose.yml 파일 설정에 대한 내용을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.272Z\"},{\"slug\":\"dockerBuildx\",\"title\":\"Docker Buildx로 다양한 플렛폼에서도 빌드하자\",\"tags\":[\"Docker\",\"buildx\",\"M1 Mac\",\"ARM64\",\"빌드 관리\"],\"date\":\"2022-09-05 15:47:55 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Docker buildx란?  \\n\u003e 도커를 빌드할때 M1맥북에서 빌드할때와 AMD에서 빌드할때와 Intel에서 빌드할때의 빌드 방식이 달라 yaml파일마다 각각 맞는 리소스를 넣어야 빌드가 된다.\\n\u003e 이런 귀찮은 일을 buildx 명령어로 한방에 해결할 수 있다.\\n\\n\\n\u003e M1 맥북은 플렛폼이 ARM64기반이다. 근데 ElasticBeanstalk를 이용해서 도커를 사용할때는 다른 플렛폼을 사용하는거 같다. \\n\u003e AMD64는 x86_64이고 arm64는 aarch64이다.  \\n\\n## 명령어\\n- 나는 아래의 명령어만 가지고 빌드를 하고 적용하니 잘되었다\\n\\n```bash\\n$  docker buildx build \\\\\\n--push \\\\\\n--platform linux/arm64/v8,linux/amd64 \\\\\\n--tag gurumee92/buildx-test .\\n\\n```\\n\\n\\n\\n## reference\\n- [https://gurumee92.tistory.com/311](https://gurumee92.tistory.com/311)\\n\",\"aiSummary\":\"Docker buildx는 M1 맥북과 다른 플랫폼에서의 도커 빌드를 쉽게 관리할 수 있는 도구로, 각 플랫폼에 맞는 리소스를 지정할 필요 없이 간편하게 빌드를 수행할 수 있게 도와준다.\",\"lastProcessed\":\"2024-11-05T13:09:30.272Z\"},{\"slug\":\"command\",\"title\":\"Docker command\",\"tags\":[\"Docker\",\"bash\",\"command\",\"container\",\"devops\"],\"date\":\"2022-03-23 15:54:06 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# update list\\n- docker exec -it imagie-Name /bin/bahs\\n\\n\\n\",\"aiSummary\":\"This document provides a command for executing a bash shell inside a Docker container.\",\"lastProcessed\":\"2024-11-05T13:09:30.269Z\"},{\"slug\":\"DockerCompose\",\"title\":\"Docker compose 사용법\",\"tags\":[\"Docker\",\"Docker compose\",\"설정\",\"네트워크\",\"링크\"],\"date\":\"2022-05-01 16:42:28 +0900\",\"content\":\"$11\",\"aiSummary\":\"Docker compose는 여러 개의 Dockerfile을 포함하고 그것들을 컨트롤하는 Dockerfile의 부모 역할을 합니다. Docker compose를 사용하면 각 Dockerfile에 대한 세부 설정을 할 수 있고 Docker CLI로 실행하는 방식을 스크립트로 자동화할 수 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.255Z\"},{\"slug\":\"Dockerfile\",\"title\":\"Dockerfile 설정방법\",\"tags\":[\"Docker\",\"Dockerfile\",\"스크립트\",\"이미지\",\"컨테이너\"],\"date\":\"2022-05-01 16:12:38 +0900\",\"content\":\"$12\",\"aiSummary\":\"이 문서는 Dockerfile 설정 방법에 대한 기본적인 내용과 스크립트 명령어를 소개하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.255Z\"},{\"slug\":\"DOM\",\"title\":\"DOM\",\"tags\":[\"DOM\",\"노드\",\"문서 객체 모델\",\"웹 페이지\",\"프로그래밍 언어\"],\"date\":\"2022-03-23 21:44:26 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# DOM 이란?\\n\u003e 문서 객체 모델\\n\u003e 웹 페이지를 스크립트 또는 프로그래밍 언어들에서 사용될 수 있게 연결시켜주는 역할을 담당한다.\\n\\n![image](https://user-images.githubusercontent.com/56494905/159727793-b89977e9-804a-4d8c-a462-82c3f1153bfd.png)\\n\\n## 노드(NODE)\\n* DOCUMENT_NODE(ex. window.documnet)\\n* ELEMENT_NODE(ex. \u003chtml\u003e, \u003cbody\u003e, \u003ca\u003e, \u003cp\u003e, \u003cscript\u003e, \u003cstyle\u003e, \u003ch1\u003e)\\n* ATTRIBUTE_NDOE(ex. class=\\\"hi\\\")\\n* TEXT_NODE(ex. 줄바꿈과 공백을 포함한 HTML 문서 내의 텍스트)\\n* DOCUMENT FRAGMENT NODE (ex. document.createDocumentFragment())\\n* DOCUMENT TYPE NODE (ex. \u003c!DOCTYPE html\u003e)\\n\\n\\n\\n# DOM 의 역할\\n\u003e \\n\\n# 참고 사이트\\n* [https://www.howdy-mj.me/dom/what-is-dom/]{사이트1} \\n* https://dom.spec.whatwg.org/\\n* https://elmprogramming.com/virtual-dom.html\\n* https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction \\n\",\"aiSummary\":\"DOM은 웹 페이지를 스크립트나 프로그래밍 언어에서 사용할 수 있게 연결시켜주는 문서 객체 모델을 말한다. DOM의 주요 노드 유형과 역할을 알아보자.\",\"lastProcessed\":\"2024-11-05T13:09:30.254Z\"},{\"slug\":\"enumerate\",\"title\":\"enumerate\",\"tags\":[\"Python\",\"enumerate\",\"자료형\",\"인덱스\",\"프로그래밍\"],\"date\":\"2022-03-23 14:05:40 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# enumerate \\n\u003e 여러가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate  객체로 리턴한다\\n\\n\\n\\n```python\\na = [1,2,3,2,45,2,5]\\n\\nlistInEnu = enumerate(a)\\n\\nprint(listInEnu)\\n\\n# \u003cenumrate object at 0x1010f3f0\u003e\\n# 위와같이 enumrate 객체가 주소를 가리키고 있다라고 나온다\\n\\nlist(enumerate(a))\\n# [(0,1),(1,2),(2,3),(3,2),(4,45),(5,2),(6,5)]\\n# list 함수로 이걸 출력해보면 위와같이 자동으로 인덱스가 지정되어 나온다\\n```\\n\\n\\n\\n\",\"aiSummary\":\"이 문서는 Python의 enumerate 함수에 대해 설명하며, 여러 자료형을 인덱스가 포함된 enumerate 객체로 변환하는 방법을 보여줍니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.273Z\"},{\"slug\":\"ESC\",\"title\":\"ESC\",\"tags\":[\"AWS\",\"트러블슈팅\",\"권한\",\"AWS CLI\"],\"date\":\"2023-05-29 18:13:44 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 트러블슈팅\\n - 아래와 같이 에러가 날때는\\n ``Unable to locate credentials. You can configure credentials by running \\\"aws configure\\\".\\n Error: Cannot perform an interactive login from a non TTY device\\n ``\\n - AmazonEC2ContainerRegistryFullAccess 권한을 주면된다!\\n\",\"aiSummary\":\"해결책: AmazonEC2ContainerRegistryFullAccess 권한을 추가하면 'Unable to locate credentials' 에러를 해결할 수 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.255Z\"},{\"slug\":\"express\",\"title\":\"express\",\"tags\":[\"Express.js\",\"HTTP 메서드\",\"PUT\",\"PATCH\",\"웹 프레임워크\"],\"date\":\"2022-03-25 10:04:08 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# express \\n\\n\\n## app()\\n\\n## Router()\\n\\n* GET\\n\\n* POST\\n\\n* PUT\\n\\n* PATCH\\n\\n* DELETE\\n\\n \\n \\n## PUT 과 PATCH의 차이점\\n[[PUT]]{참조 페이지}\\n\",\"aiSummary\":\"이 문서는 Express.js의 구조에 대한 기본 정보를 제공하며, app()와 Router() 메서드, 다양한 HTTP 요청 메서드(GET, POST, PUT, PATCH, DELETE)의 사용 방법을 설명한다. 특히 PUT과 PATCH의 차이점에 대해 언급하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.273Z\"},{\"slug\":\"middleware\",\"title\":\"Express의 미들웨어 작동방식\",\"tags\":[\"Express.js\",\"미들웨어\",\"JavaScript\",\"웹 개발\",\"서버\"],\"date\":\"2022-04-13 06:31:41 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n## 사용방법\\n* 사용방법은 간단한다\\n\\n\\n```javascript\\nimport express from 'express'\\nconst app = express()\\n\\n// 라우터의 경로와 콜백함수 사이에 원하는 미들웨어를 집어넣으면 된다\\napp.use('/', middleware, (req, res, next)=\u003e{\\n})\\n\\n\\n// 콜백함수 3번째에 next를 넣고 호출하게 되면 다음 라우터로 데이터 값이 자동으로 넘어간다\\napp.use('/', (req, res, next) =\u003e {\\n    \\n    next() // next() 함수로 다음 단계의 라우터로 넘어간다\\n})\\n```\\n\\n## Application-level middleware \\n```javascript \\nimport express from 'express'\\nconst app = express()\\n\\napp.use('/',   )\\n\\n\\n```\\n\\n## Router-level middleware\\n* \\n\\n## Error-handling middleware\\n* \\n\\n\\n\\n\",\"aiSummary\":\"이 문서는 Express.js에서 미들웨어를 사용하는 방법에 대해 설명하고 있으며, 미들웨어의 사용 예시와 다양한 유형(애플리케이션 레벨, 라우터 레벨, 에러 처리)에 대한 간단한 소개를 포함하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.285Z\"},{\"slug\":\"flask\",\"title\":\"flask\",\"tags\":[\"Flask\",\"웹 프레임워크\",\"문서\",\"개발\",\"준비 중\"],\"date\":\"2022-04-04 10:56:01 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n\\n# flask(준비중) \\n\\n\\n\\n# Docuements \\n\",\"aiSummary\":\"이 문서는 Flask에 대한 내용을 포함할 예정이며, 현재 준비 중입니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.273Z\"},{\"slug\":\"forinforof\",\"title\":\"for in 과 for of 차이점\",\"tags\":[\"JavaScript\",\"for...in\",\"for...of\",\"iterable\",\"디버깅\"],\"date\":\"2022-04-09 06:39:54 +0900\",\"content\":\"$13\",\"aiSummary\":\"이 문서는 JavaScript에서 for...in과 for...of 문에 대한 차이점과 사용 용례에 대해 설명하고 있다. for...in은 객체의 열거 가능한 속성을 반복하는 데 사용되며, 주로 디버깅 목적으로 사용되고, for...of는 배열과 기타 반복 가능한 객체를 반복하는 데 적합하다.\",\"lastProcessed\":\"2024-11-05T13:09:30.274Z\"},{\"slug\":\"commitconvention\",\"title\":\"Git commit template 설정하기\",\"tags\":[],\"date\":\"2022-05-02 16:15:51 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.269Z\"},{\"slug\":\"git-actions\",\"title\":\"github action + ssh + git pull\",\"tags\":[],\"date\":\"2022-05-02 05:51:50 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.274Z\"},{\"slug\":\"gitactions3cloudfront\",\"title\":\"github action으로 업로드 자동화\",\"tags\":[\"S3\",\"CloudFront\",\"웹 스토리지\",\"캐시 서버\",\"클라우드 서비스\"],\"date\":\"2022-05-02 05:53:41 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 들억가기 앞서 알아야할 내용\\n- S3 : 간단하게 사용할수 있는 스토리지 그런데 Endpoint를 이용해서 정적 웹페페이지를 이용할 수 있음\\n- CloudFront : 캐시 서버, 전세계 퍼져있는 캐시 서버(엣지 로케이션이라고)를 토대로 한번 요청한 데이터를 재사용하기 위해서 cloudFront 를 사용한다. 즉  region에 구애 받지 않고 빠른 업로드가 가능하다\\n- https\\n- route53\\n- CLAs\\n- IAM\\n\\n\\n\u003e 용어가 너무 생소해서 빨리 파악하지 못한거 같다 용어를 기억하자 \\n\\n\\n## 셋팅 방법\\n\\n\\n## reference\\nhttps://earth-95.tistory.com/m/127\\n\\n\",\"aiSummary\":\"S3와 CloudFront를 활용한 스토리지 및 캐싱 개념을 소개하며, 이와 관련된 추가적인 클라우드 서비스 용어들을 설명하는 문서이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.274Z\"},{\"slug\":\"group-anagram\",\"title\":\"group anagram\",\"tags\":[],\"date\":\"2022-04-04 05:26:14 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.275Z\"},{\"slug\":\"hbsvspug\",\"title\":\"hbs 와 pug\",\"tags\":[\"Handlebars\",\"Pug\",\"템플릿 엔진\",\"웹 개발\",\"가독성\"],\"date\":\"2022-04-11 01:37:53 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n## hbs(Handlebars)\\n[사이트링크](https://handlebarsjs.com/guide/)\\n\\n* 장점\\n    - HTML태그 그대로 사용가능\\n    - 정적인 부분과 동적인 부분을 따로 관리가능\\n    - Router에서쉽게 데이터 받기 가능\\n    - flask랑 유사함\\n    \\n    \\n\\n\\n## pug()\\n[사이트링크](https://pugjs.org/api/getting-started.html)\\n* 장점\\n    - HTML의 \u003c\u003e 를 없애서 `가독성`이 좋다\\n    - 정적인 부분과 동적인 부분을 따로 할 수 있다.\\n    - 다른 Templates Engine보다 Google Trend 수치가 높다\\n    \\n\\n\",\"aiSummary\":\"이 문서는 Handlebars와 Pug 템플릿 엔진의 장점을 요약하고, 각 엔진에 대한 간단한 링크를 포함하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.276Z\"},{\"slug\":\"python-heapq\",\"title\":\"heapq\",\"tags\":[\"Python\",\"heapq\",\"내장함수\",\"자료구조\",\"프로그래밍\"],\"date\":\"2022-03-25 09:27:15 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 내장함수 heapq\\n\\n## 함수 list \\n\\n* heapq.heappush(heap, item)\\n\\n## REF\\n- [링크](https://docs.python.org/ko/3.9/library/heapq.html?highlight=heap#module-heapq)\\n\",\"aiSummary\":\"이 문서는 Python의 내장 모듈인 heapq에 관한 내용을 다루고 있으며, heapq.heappush() 함수를 설명합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.291Z\"},{\"slug\":\"install-jenkins\",\"title\":\"how to install jenkins\",\"tags\":[\"Jenkins\",\"Docker\",\"Installation\",\"DevOps\",\"CI/CD\"],\"date\":\"2022-04-01 14:07:08 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# install \\n\\n\\n```bash\\n#docker run\\n\\ndocker run -dit --name jenkins -p 9000:8080 -p 50000:50000 -v ~/jenkins:/var/jenkins_home --env JAVA_OPTS=-d64 -Xmx800m -XX:+UseSerialGC\\\"\\\" --restart always mlucken/jenkins-arm\\n\\n#download jenkins\\n \\nwget https://updates.jenkins.io/download/war/2.332.1/jenkins.war --no-check-certificate\\n\\n#copy jenkins to docker container\\ndocker cp jenkins.war docker-container-id:/usr/share/jenkins\\n   \\n#docker restart\\ndocker restart docker\\\"\\n```\\n\\n## ref\\n* [site](https://javanet.tistory.com/89)\\n\",\"aiSummary\":\"This document provides instructions for installing Jenkins using Docker, including running a Docker container, downloading the Jenkins WAR file, copying it to the Docker container, and restarting the container.\",\"lastProcessed\":\"2024-11-05T13:09:30.279Z\"},{\"slug\":\"https-ssl\",\"title\":\"HTTPS/SSL\",\"tags\":[\"데이터 프라이버시\",\"HTTP\",\"HTTPS\",\"SSL\",\"TLS\"],\"date\":\"2022-03-23 21:59:10 +0900\",\"content\":\"$14\",\"aiSummary\":\"이 문서는 데이터 프라이버시의 중요성, HTTP와 HTTPS의 차이점, TLS/SSL의 작동 원리 및 인증서 구매와 설정 방법에 대해 설명합니다. 또한, SSL Handshake와 중간자 공격 방법에 대해 다룹니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.278Z\"},{\"slug\":\"IIFE\",\"title\":\"IIFE 즉시 실행함수란?\",\"tags\":[\"IIFE\",\"JavaScript\",\"함수\"],\"date\":\"2022-04-13 11:09:11 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# IIFE(Immediately Invoked Function Expression) \\n* 즉시 실행함수\\n\\n## 사용방법\\n```javascript\\n(function () {\\nconsole.log(\\\"ehlloworld\\\")\\n})();\\n\\n```\\n\\n## 함수 리터럴 \\n\\n\\n\\n## 즉시 실행함수란?\\n\\n\\n\\n\",\"aiSummary\":\"IIFE(Immediately Invoked Function Expression)은 즉시 실행되는 함수 표현이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.257Z\"},{\"slug\":\"Javascript\",\"title\":\"Javascript\",\"tags\":[\"Javascript\",\"ES6\",\"Web Development\",\"Coding\",\"Programming\"],\"date\":\"2022-03-25 06:24:54 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 카테고리\\n## Javascript \\n- 엘리유튭 정리(Javascript ES6)\\n    * [[origin]]{1장. 기원}\\n    * [[async-defer]]{2장. sync와 defer 차이점}\\n    * [[letVsVar]]{3장. let vs var}\\n    * [[operator-if-for-loop]]{4장. operator, if, for loop}\\n    * [[arrow-function]]{5장. arrow fuction?}\\n    * [[class-vs-object]]{6장. class vs object}\\n    * [[what-is-object]]{7장. object가 무엇인가}\\n    * [[array-APIs]]{8장. Array} \\n    * [[json-js]]{10장.JSON 개념} \\n    * [[callback-function]]{11장.callback promise async await}\\n    \\n   - 수요일에 할거 \\n    * [[promise-js]]{12장. 프로미스 개념부터 활용까지 }\\n    * [[async-await]]{13장. async 와 await }\\n\\n\",\"aiSummary\":\"이 문서는 Javascript ES6에 대한 다양한 개념과 주제를 정리하고 있으며, 각 주제는 해당 부분으로의 링크를 포함하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.258Z\"},{\"slug\":\"MVC\",\"title\":\"javascript MVC 대해서\",\"tags\":[\"MVC\",\"파일 구조\",\"자바스크립트\",\"Express.js\",\"웹 개발\"],\"date\":\"2022-03-22 13:04:02 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# MVC 관하여 \\n\\n* 파일 구조\\n\\n```bash\\n/public\\n    /images\\n    /javascripts\\n    /stylesheets\\n/routes\\n    /index.js\\n    /user.js\\n/views\\n    /index.js\\n    /app.js\\n    /package.json\\n```\\n\\n\\n## Ref\\n* [JS MVC](https://code.tutsplus.com/tutorials/build-a-complete-mvc-website-with-expressjs--net-34168)\\n* [원형님 GITHUB](https://github.com/choewy/node-mvc-lecture) 원형님이 굉장히 정리를 잘해두셨다. \\n\\n\",\"aiSummary\":\"이 문서는 MVC 구조에 대한 설명과 관련된 파일 구조를 제시하고 있으며, 참고 링크를 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.260Z\"},{\"slug\":\"promise-js\",\"title\":\"Javascript Promise\",\"tags\":[\"Promise\",\"JavaScript\",\"비동기 처리\",\"프로그래밍\",\"웹 개발\"],\"date\":\"2022-04-06 15:15:33 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# promise \\n\",\"aiSummary\":\"이 문서는 'promise'에 대한 개요와 그 사용 방법에 대해 설명합니다. Promise는 비동기 작업의 결과를 나타내는 객체로, 작업이 완료되면 성공 또는 실패 상태를 반환합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.291Z\"},{\"slug\":\"origin\",\"title\":\"Javascript 기원\",\"tags\":[\"JavaScript\",\"ECMAScript\",\"프로그래밍 언어\",\"SPA\",\"웹 개발\"],\"date\":\"2022-04-01 22:17:20 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Nescape\\n\\n\\n기존에 scripting 으로 \\n\\n\\nJava -\u003e Scheme -\u003e 너무 어려워\\n쉽게 만들자 \\n-\u003e Mocha -\u003e liveScript 내장 -\u003e Java가 유명해서 이름을 Javscript 으로 변경 -\u003e 마이크로소프트에서 카피해서 Jscript으로 만듦 -\u003e 너무 두개가 틀려  -\u003e 문법적인 사항을 정리한 거 ECMAScript 1 1997년.. -\u003e explorer 95% 점유 -\u003e 2000년대부터 ECMAScript 발전없음 -\u003e 2004년 AJAX 비동기적으로 가능해짐 -\u003e 너무 다양한 브라우져에 따라 만들어야함 \\n\\nJquery dojo 등등 Library 같은게 발전됨\\n\\nChrome 2008 JIT Just-in-time compliation\\n\\n2009 ECMAscript 5\\n2015 ECMAscript 6\\n\\nJavascript 표준을 따른다\\n\\n\\nChrom - V8\\nFirefox - SpiderMonkey\\nSafari - JSCore\\nMS Edge - Chakra -\u003e V8\\nOpera - Carakan\\nAdobe FLash - Tamarin\\n\\nBabel -\u003e trans compiler \\n\\nSPA -\u003e Single Page Application\\nㄴreact angular veu\\n\\n\\nback-end, mobile,\\n\\n\\nweb assemble 가능함\\n\\n\",\"aiSummary\":\"이 문서는 JavaScript의 발전 역사와 주요 변천 과정을 설명하고 있습니다. 초기 스크립트 언어부터 ECMAScript의 발전, 다양한 브라우저에서의 구현, JavaScript 라이브러리들, 그리고 최신 기술인 SPA(Single Page Application) 및 웹 어셈블리까지 다룹니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.289Z\"},{\"slug\":\"vimwiki-vim-jekyll\",\"title\":\"jekyll blog\",\"tags\":[\"Jekyll\",\"GitHub Pages\",\"정적 웹사이트\",\"로컬 실행\",\"설정 방법\"],\"date\":\"2022-03-28 12:10:49 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# jekyll static website \\n\\n## github pages setup\\n\\n\\n### repo 만들기\\n* 레포를 만들고 레포 이름을 `[githubID].github.io` 만든다\\n\u003e 내 사이트는 `diasm3.github.io` 이다\\n\\n* 이후 setting에서 pages를 활성화 해준다\\n\\n\\n\\n## 로컬로 실행시 명령어\\n\\n```bash\\n~ $ gem install bundler jekyll\\n~ $ jekyll new my-aweosome-stie\\n~ $ cd my-aweosome-stie\\n~/my-awesome-site $ bundle exec jekyll serve\\n```\\n\",\"aiSummary\":\"이 문서는 Jekyll 정적 웹사이트를 GitHub Pages에서 설정하고 로컬에서 실행하는 방법에 대한 간단한 설명을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.301Z\"},{\"slug\":\"jenkins\",\"title\":\"Jenkins\",\"tags\":[\"Docker\",\"Installation\",\"Jenkins\",\"Guide\",\"Documentation\"],\"date\":\"2022-04-01 14:06:11 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# install (docker)\\n* [[install-jenkins]]{install} \\n# Documents \\n\",\"aiSummary\":\"This document provides instructions for installing Docker, including a section specifically on installing Jenkins.\",\"lastProcessed\":\"2024-11-05T13:09:30.280Z\"},{\"slug\":\"JSON-js\",\"title\":\"JSON 사용법\",\"tags\":[\"JSON\",\"ECMAScript\",\"AJAX\",\"data interchange\",\"serialization\"],\"date\":\"2022-04-05 20:45:05 +0900\",\"content\":\"$15\",\"aiSummary\":\"JSON(JavaScript Object Notation)은 ECMAScript 3rd에서 도입된 데이터 교환 포맷으로, 가벼운 텍스트 기반의 구조를 갖고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.257Z\"},{\"slug\":\"JWT\",\"title\":\"JWT\",\"tags\":[\"JWT\",\"보안\",\"Authorization\",\"Token\",\"JSON\"],\"date\":\"2022-03-20 14:45:40 +0900\",\"content\":\"$16\",\"aiSummary\":\"이 문서는 JWT(JSON Web Token)와 그 구조, 장점, 생성 및 사용 목적에 대해 설명하고 있다. JWT는 보안 목적과 권한 인증을 위한 토큰으로 사용되며, header, payload, signature로 구성된다.\",\"lastProcessed\":\"2024-11-05T13:09:30.258Z\"},{\"slug\":\"Latex\",\"title\":\"Latex syntax\",\"tags\":[\"LaTeX\",\"수학 문법\",\"문서 작성\",\"참고 자료\",\"텍스트 프로세싱\"],\"date\":\"2022-03-22 15:57:15 +0900\",\"content\":\"$17\",\"aiSummary\":\"이 문서는 기본적인 LaTeX 수학 문법과 사용 방법을 소개합니다. 사용자에게 수학 표현식 작성 방법과 심볼 사용법을 제공하며, 참고 자료로 사이트 및 PDF 링크를 제시합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.259Z\"},{\"slug\":\"mvc-parttern\",\"title\":\"Layered Architecture(Model, View, Controller)\",\"tags\":[\"Layered Architecture\",\"MVC\",\"Backend\",\"Design Pattern\",\"Scalability\"],\"date\":\"2022-04-22 12:55:16 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Layered Architecture?\\n\\n- 백앤드에서 사용되는 디자인 패턴으로 3개의 레이어(3 단계의 depth)로 엔드포인트인 라우터 부분, 중간에서 비지니스 로직(data의 가공), 마지막으로 DB와 직적 연결되는 부분을 나눈 것을 말한다\\n\\n![image](https://user-images.githubusercontent.com/56494905/164613140-545dc871-58ff-43b0-98c6-00a01269dab1.png)\\n\\n\u003e MVC 패턴을 모른상태에서는 라우터에 때려 넣는다. 그럼 가독성 및 확장성 생산성 모두를 잃게 된다\\n\\n## MVC(Model, View, Controller)\\n- Model(data model)\\n    - 데이터베이스의 모델을 지정한다 \\n    - 이 레이어에서 정의된 모델을 토대로 데이터가 Create, Update, Read, Delete 된다\\n    - 폴더의 이름은 보통 Models로 넣는다\\n    - 데이터 베이스와 1:1 통신한다\\n    \\n    - 만약에 데이터 \\n    \\n```javascript\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\n# 확장성\\n\\n## MVC 패턴으로 얼마나 확장성이 높아 질까?\\n\",\"aiSummary\":\"이 문서는 백엔드에서 사용되는 레이어드 아키텍처와 MVC 패턴에 대해 설명하고 있다. 레이어드 아키텍처는 엔드포인트, 비즈니스 로직, 데이터베이스 연결의 3개의 레이어를 나누어 가독성과 확장성을 높이며, MVC 패턴은 데이터 모델을 정의하여 데이터 처리의 효율성을 증대시킨다.\",\"lastProcessed\":\"2024-11-05T13:09:30.286Z\"},{\"slug\":\"letVsVar\",\"title\":\"let Vs var\",\"tags\":[\"JavaScript\",\"변수\",\"let\",\"var\",\"const\"],\"date\":\"2022-04-03 23:20:54 +0900\",\"content\":\"$18\",\"aiSummary\":\"이 문서는 JavaScript에서 변수 선언 방법과 관련된 내용을 다룹니다. 'let', 'var', 'const'의 차이점과 변수의 스코프, 그리고 다양한 데이터 타입에 대한 설명을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.282Z\"},{\"slug\":\"Linux\",\"title\":\"linux\",\"tags\":[\"table of contents\",\"document structure\",\"outline\",\"organization\",\"navigation\"],\"date\":\"2022-03-31 08:41:29 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Documents\\n\",\"aiSummary\":\"This document appears to be an outline or table of contents (TOC) for a larger set of documents, indicating a structured organization of topics or sections.\",\"lastProcessed\":\"2024-11-05T13:09:30.260Z\"},{\"slug\":\"locale-problem\",\"title\":\"locale 설정 방법\",\"tags\":[\"Ubuntu\",\"Locale\",\"한국어\",\"설정\",\"가이드\"],\"date\":\"2022-03-31 08:40:21 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\\n\\n## ref\\n- [link](https://beomi.github.io/2017/07/10/Ubuntu-Locale-to-ko_KR/)\\n\",\"aiSummary\":\"이 문서는 Ubuntu의 Locale을 한국어로 설정하는 방법에 대한 가이드이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.284Z\"},{\"slug\":\"magic-mothod\",\"title\":\"Magic Method\",\"tags\":[\"Python\",\"오버라이딩\",\"__len__\",\"객체지향\",\"프로그래밍\"],\"date\":\"2022-03-25 08:28:33 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# __len__\\n\u003e 기존에 있던  len 함수를  overriding 해준다\\n\\n## 내장함수\\n* 파이썬은 모든게 객체로 이루어져있다.\\n* 실제로 아무 변수를 만들고 객체를 탐색하면 __len__ 기타등등 의 Method가 보인다.\\n\\n\\n\\n\\n```python\\n\\nclass node:\\n    def __len__():\\n        return len(something) - 1\\n\\n\\n    def doSomthing():\\n        data = [1,2,3,4]\\n        print(len(data))\\n```\\n\\n\u003e`overriding` 해준다.\\n\\n* \\n\",\"aiSummary\":\"이 문서는 파이썬에서 __len__ 메서드를 오버라이딩하는 방법에 대해 설명한다. 사용자 정의 클래스에서 len 함수를 재정의하여 객체의 길이를 다르게 정의할 수 있음을 보여준다.\",\"lastProcessed\":\"2024-11-05T13:09:30.284Z\"},{\"slug\":\"microservice\",\"title\":\"microservice에 대한 고찰\",\"tags\":[\"마이크로서비스\",\"소프트웨어 아키텍처\",\"Nestjs\",\"Kubernetes\",\"AWS\"],\"date\":\"2022-08-10 16:39:19 +0900\",\"content\":\"$19\",\"aiSummary\":\"마이크로서비스 아키텍처는 대규모 애플리케이션을 작은 독립적인 서비스로 나누어 각 서비스의 성능 및 확장성을 높이는 방식입니다. 이 구조는 문서화, 코드 관리, 복잡성 등을 고려해야 하며, 다양한 기술 스택을 사용할 수 있는 장점이 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.285Z\"},{\"slug\":\"todo-memo\",\"title\":\"mongodb \u0026 router\",\"tags\":[\"JavaScript\",\"기본 구조\",\"프로그래밍\",\"웹 개발\",\"코드 예제\"],\"date\":\"2022-04-08 12:12:23 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 기본 구조\\n\\n```javascript\\n\\n```\\n\",\"aiSummary\":\"이 문서는 JavaScript의 기본 구조에 대한 설명을 다룹니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.298Z\"},{\"slug\":\"mysql_sequelize\",\"title\":\"mysql과 sequelize\",\"tags\":[\"MySQL\",\"Docker\",\"EC2\",\"설치 방법\",\"데이터베이스\"],\"date\":\"2022-04-16 08:04:47 +0900\",\"content\":\"$1a\",\"aiSummary\":\"이 문서는 MySQL을 Docker로 설치하는 방법과 EC2 서버에서 MySQL을 설정하는 방법을 설명합니다. Docker에서 MySQL 이미지를 다운로드하고 설정하는 명령어와 EC2 인스턴스를 위한 SSH 접속 및 프로그램 설치 방법을 포함합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.286Z\"},{\"slug\":\"nestjs\",\"title\":\"Nestjs\",\"tags\":[\"Nestjs\",\"NodeJs\",\"TypeScript\",\"Swagger\",\"AWS Cognito\"],\"date\":\"2022-07-17 22:49:20 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Nestjs \\n- NodeJs, TypeScript 기반의 Backend frameworks\\n- Decorator를 이용한 의존성 주입이 특징\\n- 기본 MVC 패턴을 nest cli로 제공하여 협업에서 구조문제로 인한 이슈가 적음 \\n- DTO(Data transfer Object)방식으로 DATA validation 및 swagger 작성시에 유용하다\\n\\n## [[Swagger]]{Swagger with Nesjt}\\n- 다양한 Decorator를 사용함으로 yaml 파일 작성대신 쉽게 swagger를 작성할 수 있다.\\n\\n## [[cognitoWithNestjs]]{AWS Cognito with Nestjs}\\n- Nestjs 의 편리함과 함께 게정관리를 Cognito로 구현한다.\\n- 인증관련 해결방법\\n\\n## [[telegramWithNestjs]]{텔레그램을 사용한 서버 로그불러오기}\\n- eb-cli로 불러오는것도 귀찮다. 실시간으로 에러를 파악하고 저장하다\\n- nestjs telegraf winston 사용\\n\\n\\n\\n\\n\",\"aiSummary\":\"Nestjs는 NodeJs와 TypeScript를 사용하는 백엔드 프레임워크로, Decorator를 통한 의존성 주입, 기본 MVC 패턴, DTO를 통한 데이터 검증을 특징으로 한다. 이 문서는 Swagger 사용법, AWS Cognito 연동, 텔레그램을 이용한 서버 로그 관리 방법을 설명한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.287Z\"},{\"slug\":\"Swagger\",\"title\":\"Nestjs 내장 swagger\",\"tags\":[\"Swagger\",\"API\",\"테스트\",\"명세서\",\"툴\"],\"date\":\"2022-07-17 22:50:42 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# swagger 툴\\n\u003e API의 명세서와 쉽게 데이터를 주입시켜 테스트할 수 있다\\n\\n##  \\n\\n\\n\",\"aiSummary\":\"Swagger 툴은 API의 명세서를 작성하고, 데이터를 쉽게 주입하여 테스트할 수 있는 기능을 제공한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.263Z\"},{\"slug\":\"Node_js\",\"title\":\"Nodejs\",\"tags\":[],\"date\":\"2022-03-25 09:59:35 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.261Z\"},{\"slug\":\"nodejs\",\"title\":\"Nodejs\",\"tags\":[\"Node.js\",\"Express\",\"MongoDB\",\"MVC 패턴\",\"테스트 코드\"],\"date\":\"2022-04-04 08:00:08 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 항목\\n## Node_js\\n* [[express]]\\n* mongodb_library\\n* hbs\\n* [[PUT]]\\n* [[hbsvspug]]{hbs와 pug}\\n* [[middleware]]{express의 미들웨어}\\n* [[IIFE]]{IIFE란? 즉시 실행함수}\\n* [[literals]]{function literals?}\\n* [[mvc-parttern]]{MVC 패턴 (3 Layered Architecture)}\\n* [[LazyloadingEagerLoading]]{레이지로딩과 이거로딩, N+1}\\n    \\n    \\n* Node.js에서 리팩토링시 사용하며, npm을 통해 다운로드 했던 모듈을 불러오는 require 함수는 어떻게 동작하나요? IIFE와 연결지어 찾아보고 정리해보세요. \\n   \\n   \\n* 불필요한 테스트코드는 무엇이며, 100개의 테스트 케이스보다 1개의 테스트 케이스가 더 효과적일 수 있는 이유는 무엇인가요?\\n    \\n    \\n\\n## [[MVC]]{nodejs mvc pattern} \\n\\n\",\"aiSummary\":\"이 문서는 Node.js와 관련된 다양한 주제 및 개념들을 다루고 있으며, 특히 Express 프레임워크, MongoDB, Handlebars, IIFE, MVC 패턴, 레이지 로딩 및 이거 로딩 등을 포함하여 리팩토링과 테스트 코드의 중요성에 대해서도 언급합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.288Z\"},{\"slug\":\"oauth\",\"title\":\"oauth\",\"tags\":[\"OAuth\",\"인증\",\"보안\",\"API\",\"토큰\"],\"date\":\"2022-06-16 12:02:11 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# OAuth 란?\\n2007년 12월 OAuth 1.0 이 나왔다 그리고 강력한 보안으로 사람들이 많이 사용하기 시작했다. 구글은 OAuth 1.0을 2008년 부터 지원하기 시작하고 트위터도 third-party 앱에 사용하도록 구연했다.\\n\\n그러나  OAuth 1.0 은 보안 구성을 할때 암호로 구현하고 암호화로 상호 운용성이 필요했다. 많은 개발자들이 구현하기 힘들었다. 그래서 나온게 OAuth 2.0이 2012년 10월에 나왔다.\\n\\n\u003e 인터넷 표준 인증방식, 인증내역을 공유하여 애플리케이션간 회원정보를 공유할 수 있음\\n\\n## OAuth 1.0 과 OAuth 2.0 차이점\\n\\n\u003e 1. OAuth 2.0에서는 SSL을 사용함으로써 인증과정 간소화\\n1. 2.0에서는 Signature 가 필요없음\\n2. 토큰이 생성되고나서 OAuth 1.0은 매번 API를 호출할때마다 2개의 보안토큰이 필요하고, OAuth 2.0 은 하나의 토큰만 필요함.\\n\\n\\n\\nOAuth 1.0\\n* Transport-independent : 보안이 https/tls로 위임 받을 수 없다.\\n\\n1. 카카오, 트위터, 페이스북 등이 제공한다.\\n\\nOAuth 2.0\\n* Bearer Tokens 중심: 쉽게 사용할 수 있다. 그러나 보안으로는 좋지 않다. \\n* 범용성 : OAuth 1.0은 웹에서만 가능하지만, OAuth 2.0은 웹이 아닌 곳에서도 사용가능하다.\\n* 용도의 구분 : 리소스 요청에 대해 핸들링이 가능하고 유저마다 필요한 인증이 능하다.\\n\\n1. 클라이언트 어플리케이션 제공자다. (구글 트위터, 카카오, 네이버)\\n2. 트위터 제공\\n3. 클라이언트 어플리케이션은 \\\"클라이언트 시크릿\\\" 을 매번 요청한다.\\n4. 잘못된 요청이 있다고 하면 요청이 리젝된다.\\n\\n## Refrence\\n(https://oauth.net)\\n\",\"aiSummary\":\"이 문서는 OAuth의 개요와 OAuth 1.0과 2.0의 주요 차이점을 설명합니다. 특히, OAuth 2.0은 인증 과정을 간소화하고 범용성이 높아 다양하게 활용될 수 있음을 강조합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.288Z\"},{\"slug\":\"operator-if-for-loop\",\"title\":\"operator, if, for-loop\",\"tags\":[\"JavaScript\",\"Operators\",\"Control Structures\",\"Loops\",\"Data Types\"],\"date\":\"2022-04-05 05:55:48 +0900\",\"content\":\"$1b\",\"aiSummary\":\"이 문서는 JavaScript의 다양한 연산자와 제어 구조(if, switch 등), 반복문(for, while 등)에 대해 설명합니다. 또한, 데이터 타입의 불변성과 가변성, 연산자(산술, 할당, 비교, 논리 등)의 사용법을 다룹니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.288Z\"},{\"slug\":\"OSI-7-layers\",\"title\":\"OSI 7 layers\",\"tags\":[\"OS\",\"7 Layers\",\"Operating System\",\"Architecture\",\"Computer Science\"],\"date\":\"2022-03-20 22:36:16 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# OS 7 Layers \\n\",\"aiSummary\":\"이 문서는 OS의 7개 계층에 대한 구조와 기능을 설명합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.261Z\"},{\"slug\":\"palindrome-linked-list\",\"title\":\"palindrome-linked-list\",\"tags\":[\"linked list\",\"data structure\",\"algo\",\"LeetCode\",\"palindrome\"],\"date\":\"2022-03-24 21:45:13 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# question \\n\u003e basic linked list\\n\\n\\n\\n\\n## URL\\n* [linke](https://leetcode.com/problems/palindrome-linked-list/)\\n\",\"aiSummary\":\"This document discusses the basic concepts surrounding linked lists, a fundamental data structure, and provides a link to a specific problem related to palindrome linked lists on LeetCode.\",\"lastProcessed\":\"2024-11-05T13:09:30.289Z\"},{\"slug\":\"pm2\",\"title\":\"PM2\",\"tags\":[\"PM2\",\"NODE.js\",\"프로세스 관리\",\"배포 도구\",\"개발 도구\"],\"date\":\"2022-04-24 20:49:49 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# PM2\\n- NODE.js 를 더 편리하게 디플로이 하고 프로세스를 관리해준다\\n\\n## 참고 사이트\\n- [PM2 github](https://github.com/keymetrics/docker-pm2)\\n- [참고 블로그](https://blog.joon-lab.com/164)\\n\\n\\n\",\"aiSummary\":\"PM2는 NODE.js의 배포 및 프로세스 관리를 용이하게 해주는 도구이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.290Z\"},{\"slug\":\"PUT\",\"title\":\"PUT과 PATCH\",\"tags\":[\"HTTP\",\"PUT\",\"PATCH\",\"Idempotency\",\"IETF\"],\"date\":\"2022-04-09 07:13:03 +0900\",\"content\":\"$1c\",\"aiSummary\":\"이 문서는 PUT과 PATCH HTTP 메소드의 차이점과 멱등성 개념을 설명합니다. PUT은 자원의 전체 교체를 위한 메소드이고, PATCH는 자원의 일부 교체를 위한 메소드입니다. 멱등성 및 HTTP 메소드의 성격도 함께 다룬다.\",\"lastProcessed\":\"2024-11-05T13:09:30.262Z\"},{\"slug\":\"random-python\",\"title\":\"Random()\",\"tags\":[\"Python\",\"Random Module\",\"random()\",\"seed()\",\"Programming\"],\"date\":\"2022-04-04 13:22:59 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Rndom() \\n```python\\nfrom Random import random\\nfrom random import seed\\n\\nval = Random() \\n\\nrandomVal = val.rnadom \\n\\n\\n```\\n\\n\\n## random()\\n\\n## seed(int)\\n\",\"aiSummary\":\"이 문서는 Python의 Random 모듈에 대한 내용을 포함하고 있으며, random() 함수와 seed(int) 함수의 사용법을 다루고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.292Z\"},{\"slug\":\"range\",\"title\":\"range 관련해서..\",\"tags\":[\"TOC\",\"range\",\"mathematics\",\"programming\",\"documentation\"],\"date\":\"2022-03-23 15:45:20 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# range\\nk\\n\",\"aiSummary\":\"This document contains a table of contents (TOC) section and a placeholder for 'range k', indicating a section that may explain a certain range in a mathematical or programming context.\",\"lastProcessed\":\"2024-11-05T13:09:30.293Z\"},{\"slug\":\"react\",\"title\":\"React\",\"tags\":[\"MD파일\",\"문서 처리\",\"파일 읽기\",\"기술 문서\",\"정보\"],\"date\":\"2022-04-04 08:03:06 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# [[readMDFile]]{MD파일 읽기}\\n# Documents\\n\",\"aiSummary\":\"이 문서는 MD 파일을 읽는 방법과 관련된 내용을 담고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.293Z\"},{\"slug\":\"readMDFile\",\"title\":\"react에서 md파일 읽기\",\"tags\":[\"React\",\"Markdown\",\"파일 읽기\",\"프로그래밍\",\"웹 개발\"],\"date\":\"2023-06-05 07:08:27 +0900\",\"content\":\"$1d\",\"aiSummary\":\"이 문서는 React에서 Markdown 파일을 읽는 방법에 대한 설명입니다. 글로벌 타입 선언과 함께, Markdown 파일을 fetch하고 이를 React 컴포넌트로 렌더링하는 간단한 예제 코드를 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.293Z\"},{\"slug\":\"refreshtoken\",\"title\":\"refresh token 구현하기\",\"tags\":[\"JWT\",\"Access Token\",\"Refresh Token\",\"Authentication\",\"Security\"],\"date\":\"2022-05-09 22:34:00 +0900\",\"content\":\"$1e\",\"aiSummary\":\"현재 JWT 토큰을 사용하여 3600초 동안 인증하는 테스트를 완료했으며, 실제 서비스에서는 Access Token과 Refresh Token을 이용한 3 Handshake 방식으로 인증을 개선할 계획이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.294Z\"},{\"slug\":\"regex\",\"title\":\"Regex 사용법\",\"tags\":[\"정규식\",\"문법\",\"수량자\",\"문자 클래스\",\"프로그래밍\"],\"date\":\"2022-04-05 10:34:35 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# regex 란?\\n* 일정한 페턴을 구별하고 그 규칙을 가지고 값을 반환한다\\n\\n# Sytax\\n## Groups and ranges\\n* \\\\| 또는\\n* () 그룹\\n* [] 문자셋, 괄호안의 어떤 문자든\\n* [\\\\^] 부정 문자셋, 괄호안의 어떤 문자가 아닐때\\n* (?:) 찾지만 기억하지 않음\\n\\n## Quantifiers(수량자)\\n* ? 없거나 있거나(zero or one)\\n* \\\\* 없거나 있거나 많거나(zero or more)\\n* \\\\+ 하나 또는 많이(one or more)\\n* {n} n번 반복\\n* {min,} 최소\\n* {min, max} 최소, 그리고 최대\\n\\n## Roundary-type\\n* \\\\b 단어 경계\\n* \\\\B 단어 경계가 아님\\n* ^  문장의 시작\\n* $ 문장의 끝\\n\\n## Character classes\\n* \\\\ 특수 문자가 아닌 문자\\n* . 어떤 글자(줄바꿈 문자 제외)\\n* \\\\d digit 숫자\\n* \\\\D digit 숫자 아님\\n* \\\\w word 문자\\n* \\\\W word 문자 아님\\n* \\\\s space 공백\\n* \\\\S space 공백 아님\\n\\n\\n\\n\\n\\n\\n\\n\\n## ref\\n* [엘리regex](https://www.youtube.com/watch?v=t3M6toIflyQ\u0026list=PLv2d7VI9OotSn1ThdDeqvBx8QuRSd01qv)\\n* \\n\\n\",\"aiSummary\":\"이 문서는 정규 표현식(regex)에 대한 소개와 기본 문법(Syntax), 수량자(Quantifiers), 유형(Roundary-type), 문자 클래스(Character classes)를 설명한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.294Z\"},{\"slug\":\"reorder-log-files\",\"title\":\"reorder log files\",\"tags\":[\"LeetCode\",\"algorithm\",\"log files\",\"data processing\",\"reordering\"],\"date\":\"2022-03-24 21:55:51 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\\n\\n## URL\\n* [Link](https://leetcode.com/problems/reorder-data-in-log-files/)\\n\",\"aiSummary\":\"This document contains a link to a LeetCode problem related to reordering data in log files.\",\"lastProcessed\":\"2024-11-05T13:09:30.294Z\"},{\"slug\":\"REST-API\",\"title\":\"REST-API\",\"tags\":[\"REST API\",\"인터넷 통신\",\"API 유형\",\"데이터 전송\",\"소프트웨어 아키텍처\"],\"date\":\"2022-03-24 06:00:05 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# restAPI? \\n\u003e REST(Representational State Transfer) 네트워크를 통해서 컴퓨터들끼리 통신할 수 있게 해주는 아키텍처 스타일\\n\\n\\n\\n## API?\\n\u003e운영체제와 상관없이 데이터를 주고 받는데 필요한 것\\n\\n* API 유형\\n1. private API\\n2. public API\\n3. partner API\\n\\n\\n\",\"aiSummary\":\"REST API는 컴퓨터 간의 통신을 위한 아키텍처 스타일로, 운영체제와 무관하게 데이터를 주고받을 수 있는 방법을 제공하는 API의 한 유형이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.262Z\"},{\"slug\":\"reverse-string\",\"title\":\"reverse-string\",\"tags\":[\"코드\",\"프로그래밍\",\"개발자\",\"기술 문서\",\"소프트웨어\"],\"date\":\"2022-04-04 05:25:27 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# code \\n\",\"aiSummary\":\"이 문서는 코드와 관련된 내용을 다루고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.295Z\"},{\"slug\":\"index\",\"title\":\"ROOT\",\"tags\":[\"인공지능\",\"기술 발전\",\"사용 사례\",\"트렌드\",\"기업 영향\"],\"date\":\"2017-11-26 12:42:03 +0900\",\"content\":\"\",\"aiSummary\":\"이 기술 문서는 최신 인공지능 기술의 발전과 그 사용 사례에 대해 설명하고, 다가오는 트렌드와 기업에 미치는 영향을 분석한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.278Z\"},{\"slug\":\"socketio\",\"title\":\"socketio 란 무엇인가?\",\"tags\":[\"WebSocket\",\"API\",\"데이터 송수신\",\"네트워크\",\"프로그래밍\"],\"date\":\"2022-06-28 16:49:01 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# websocket?\\n\\n\u003e WebSocket 객체는 WebScoekt 서버 연결의 생성과 관리 및 연결을 통한 데이터 송수신 API를 제공한다.\\n\\n\u003e websocket() 생성자를 이용하여 사용가능\\n\\n## reference\\n- [공식사이트링크](https://websockets.spec.whatwg.org/#the-websocket-interface)\\n- [모질라링크](https://developer.mozilla.org/ko/docs/Web/API/WebSocket)\\n\\n\\n\\n\",\"aiSummary\":\"WebSocket 객체는 WebSocket 서버와의 연결을 생성하고 관리하며, 연결을 통해 데이터를 송수신할 수 있는 API를 제공한다. websocket() 생성자를 통해 사용할 수 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.296Z\"},{\"slug\":\"spread-syntax\",\"title\":\"Spread syntax\",\"tags\":[\"JavaScript\",\"Spread Syntax\",\"Function\",\"Array\",\"Object\"],\"date\":\"2022-04-04 11:55:01 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Spread sysntax(...) \\n\u003e 자꾸 잊어버려서 정리해야겠다\\n\\n* 연속적인 배열 또는 문자열을 0 또는 인수 또는 인자값을 예약할 수 있다 \\n* 객체 또한 key-value 로 연속적인 부분을 예측 할 수 있다\\n\\n\\n```javascript\\n\\nfunction sum(x, y, z){\\n    retrun x+y+z\\n}\\n\\nconst numbers = [1,2,3]\\n\\nconsole.log(sum(...numbers))\\n//여기서 1,2,3 을 다 불러오라는 뜻이다\\n\\nconsole.log(sum.apply(null, numbers))\\n\\n```\\n\\n\\n# 주석 \\n\",\"aiSummary\":\"이 문서는 JavaScript의 Spread 구문에 대해 설명합니다. 배열이나 객체의 값을 쉽게 분배하고, 함수를 호출할 때 사용될 수 있는 방법을 보여줍니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.297Z\"},{\"slug\":\"SSH\",\"title\":\"ssh\",\"tags\":[\"문서작성\",\"가이드라인\",\"내용구조\",\"참고사항\",\"TOC\"],\"date\":\"2022-03-30 06:41:17 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Documents \\n\",\"aiSummary\":\"이 문서는 다양한 문서의 구조 및 내용에 대한 가이드라인을 제공하며, 문서 작성 시 참고할 주요 요소들을 정리하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.262Z\"},{\"slug\":\"ssh-key-copy\",\"title\":\"Ssh key copy to server\",\"tags\":[\"SSH\",\"Server\",\"File Transfer\",\"Key Management\",\"Linux\"],\"date\":\"2022-03-30 06:40:30 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# how to copy key files to server?\\n##\\n\\n```bash\\n# 예제 \\n$ ssh-copy-id -i ~/.ssh/id_rsa.pub YOUR_USER_NAME@IP_ADDRESS_OF_THE_SERVER\\n```\\n\\n```bash\\n# 실제 사용시\\n$ ssh-copy-id -i ~/.ssh/id_rsa.pub user_id@mydomainmane.co.kr\\n```\\n\",\"aiSummary\":\"This document provides a brief guide on how to copy key files to a server using the ssh-copy-id command.\",\"lastProcessed\":\"2024-11-05T13:09:30.297Z\"},{\"slug\":\"Synology\",\"title\":\"synology server\",\"tags\":[\"Synology\",\"NAS\",\"백업 솔루션\",\"Docker\",\"데이터 저장\"],\"date\":\"2022-03-24 11:05:13 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# About synology \\n\u003e NAS (Network Attached Storage)\\n* 기능 \\n  1. 데이터 저장 목적\\n  2. 손쉬운 데이터 타이머신 기능\\n  3. Docker 이용 App을 마음대로 추가 할 수 있\\n  4.  \\n*  \\n\\n\\n## 작성해야할것 \\n* DS video\\n* Docker를 이용한 \\n\\n# backup solution\\n\\n#\\n\",\"aiSummary\":\"이 문서는 Synology NAS에 대한 기능 소개와 데이터 저장, 타이머신 기능, Docker를 통한 앱 추가 가능성 등을 다룬다.\",\"lastProcessed\":\"2024-11-05T13:09:30.263Z\"},{\"slug\":\"tmux\",\"title\":\"tmux 사용법\",\"tags\":[\"tmux\",\"사용법\",\"리뷰\",\"문서\",\"링크\"],\"date\":\"2022-03-25 11:55:40 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\\n\\n## Ref\\n* [link](https://tmuxcheatsheet.com)\\n\",\"aiSummary\":\"이 문서는 tmux에 대한 내용을 다루고 있으며, tmux 사용의 법칙과 규칙을 설명하는 링크가 포함되어 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.298Z\"},{\"slug\":\"todo\",\"title\":\"TODO\",\"tags\":[\"할 일\",\"정리\",\"목록\",\"생산성\",\"계획\"],\"date\":\"2022-03-21 01:03:18 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 해야될일 적기 \\n\\n\\n\\n\\n\",\"aiSummary\":\"이 문서는 해야 할 일들을 기록하기 위해 작성되었습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.299Z\"},{\"slug\":\"awsTrobleShooting\",\"title\":\"TroubleShooting\",\"tags\":[],\"date\":\"2023-05-29 16:01:59 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.266Z\"},{\"slug\":\"ubuntu\",\"title\":\"Ubuntu\",\"tags\":[\"문서작성\",\"가이드라인\",\"내용구조\",\"참고사항\",\"TOC\"],\"date\":\"2022-04-04 17:07:12 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Documents \\n\",\"aiSummary\":\"이 문서는 다양한 문서의 구조 및 내용에 대한 가이드라인을 제공하며, 문서 작성 시 참고할 주요 요소들을 정리하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.300Z\"},{\"slug\":\"linux-locale\",\"title\":\"Ubuntu 설치 후 locale 문제\",\"tags\":[],\"date\":\"2022-04-04 17:06:36 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n\",\"aiSummary\":\"\",\"lastProcessed\":\"2024-11-05T13:09:30.283Z\"},{\"slug\":\"jest\",\"title\":\"Unit testing NestJS applications with Jest(의역) - 작성중\",\"tags\":[\"유닛 테스트\",\"테스트 기술\",\"Node.js\",\"비즈니스 로직\",\"소프트웨어 개발\"],\"date\":\"2022-07-18 13:16:21 +0900\",\"content\":\"$1f\",\"aiSummary\":\"이 문서는 유닛 테스트에 대한 기본 이해를 제공하며, 특히 Node.js 환경에서의 중요성과 구현 방식을 설명합니다. 유닛 테스트는 비즈니스 로직을 검증하는 한 단위의 함수 또는 메소드를 목표로 하며, 의존성이 없어야 하고 빠르게 수행되어야 한다고 강조합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.280Z\"},{\"slug\":\"valid-palindrome\",\"title\":\"Valid Palindrome\",\"tags\":[\"팰린드롬\",\"문자열\",\"알고리즘\",\"파이썬\",\"대소문자\"],\"date\":\"2022-03-24 21:52:19 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Question  \\n\u003e 주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며 영문자와 숫자만을 \\n## 리스트로 변환\\n```python\\nstrs = []\\nfor char in s:\\n    if char isalnum():\\n        strs.append(char.lower())\\n```\\n\\n\\n## what is the palindrome\\n\u003e 앞뒤가 똑같은 번호\\n\u003e ex) 12321\\n\\n## URL\\n* [link](https://leetcode.com/problems/valid-palindrome/)\\n\",\"aiSummary\":\"이 문서는 주어진 문자열이 팰린드롬인지 확인하는 방법을 설명하며, 대소문자를 구분하지 않고 영문자와 숫자만 고려합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.300Z\"},{\"slug\":\"vim\",\"title\":\"VIM\",\"tags\":[\"Vim\",\"Vimwiki\",\"Vimspector\",\"fzf\",\"VimScript\"],\"date\":\"2022-03-24 06:43:00 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 항목\\n\\n## [[vimwiki-vim-jekyll]]\\n## [[vimspector]]\\n\\n# resarch list\\n- fzf\\n    - function shortcurt is not working\\n- [[vim-script]]\\n\",\"aiSummary\":\"이 문서는 Vim과 관련된 여러 항목들을 나열하고 있으며, 특히 Vimwiki, Vimspector, fzf에 대한 문제점 및 Vim 스크립트에 대한 리서치를 포함하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.301Z\"},{\"slug\":\"vim-script\",\"title\":\"vim-script\",\"tags\":[\"Vim\",\"Scripting\",\"Keyboard Mapping\",\"Insert Mode\",\"Visual Mode\"],\"date\":\"2022-03-24 06:42:31 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# vim script 정리\\n## keyboard mapping\\n\\n\u003e Working in Insert Mode\\n* remap \\n* noremap\\n* nnoremap\\n    * \\n    \\n\u003e Working in Visual Mode\\n* vnoremap\\n    * \\n* vmap\\n\\n## reference site\\n* [stackoverflow](https://stackoverflow.com/questions/3776117/what-is-the-difference-between-the-remap-noremap-nnoremap-and-vnoremap-mapping)\\n\",\"aiSummary\":\"이 문서는 Vim 스크립트에서 키보드 매핑에 대한 내용을 정리한 것으로, Insert Mode와 Visual Mode에서의 다양한 매핑 옵션을 설명하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.300Z\"},{\"slug\":\"vimspector\",\"title\":\"vimspector\",\"tags\":[\"vimspector\",\"디버깅\",\"GitHub\",\"개발툴\",\"프로그래밍\"],\"date\":\"2022-03-24 07:43:53 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n\\n## vimspector\\n- [githubPage](https://puremourning.github.io/vimspector-web/#getting-started)\\n\",\"aiSummary\":\"이 문서는 vimspector에 대한 내용을 다루며, 주로 GitHub 페이지에서 시작하는 방법에 대한 정보를 제공합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.301Z\"},{\"slug\":\"root-index\",\"title\":\"wiki\",\"tags\":[\"Web Development\",\"Programming\",\"DevOps\",\"Algorithms\",\"Python\"],\"content\":\"$20\",\"aiSummary\":\"이 문서는 다양한 기술 주제에 대한 분류체계를 포함하고 있으며, Web Programming, Linux \u0026 Server, Synology, 알고리즘, JavaScript, Python 등의 세부 항목으로 구성되어 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.295Z\"},{\"slug\":\"homework\",\"title\":\"과제톡\",\"tags\":[\"목차\",\"TOC\",\"문서 구성\",\"기능 설명\",\"내비게이션\"],\"date\":\"2022-03-20 20:07:04 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n\",\"aiSummary\":\"이 문서는 목차(TOC) 기능을 설명하는 내용을 담고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.277Z\"},{\"slug\":\"graph\",\"title\":\"그래프(graph)\",\"tags\":[\"그래프\",\"알고리즘\",\"DFS\",\"BFS\",\"N-Queen\"],\"date\":\"2022-03-20 23:12:19 +0900\",\"content\":\"$21\",\"aiSummary\":\"이 문서는 그래프의 기본 개념과 그래프 순회 방법, 백트래킹 알고리즘을 설명하며, N-Queen 문제와 관련된 파이썬 코드 예제를 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.275Z\"},{\"slug\":\"naming\",\"title\":\"기호 영어이름\",\"tags\":[\"기호\",\"영어표기\",\"문서작성\",\"언어\",\"참고자료\"],\"date\":\"2022-04-05 10:13:51 +0900\",\"content\":\"$22\",\"aiSummary\":\"이 문서는 다양한 기호의 영어 명칭과 그에 대한 한국어 설명을 정리한 표를 제공합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.287Z\"},{\"slug\":\"nodeEventLoop\",\"title\":\"노드에서의 이벤트 루프는 어떻게 동작하는가?\",\"tags\":[\"이벤트 루프\",\"Node.js\",\"논블로킹 I/O\",\"비동기\",\"동기\"],\"date\":\"2022-06-15 07:10:51 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 이벤트 루프는 무엇인가?\\n\u003e 이벤트 루프는 Node.js 를 논블로킹 I/O를 가능하게끔 하는 것이다. 그런데 자바스크립트는 싱글 스레드이다. \\n\\n최신 커널들은 멀티 스레드를 지원하고, 백그라운드에서 여러개의 쓰레드를 관리 할 수 있다. 이때 작동인 완료 될때 커널은 nodejs에게 완료됐다고 콜백을 해주고 Poll 큐에 균등하게 등록된다음 균등하게 실행된다. \\n\\n- 비동기(asyncronous) : 두가지 작업이 동시에 시작하지 않는것\\n- 동기(syncronous) : 두가지 작업이 동시에 시작하는것\\n\\n##  이벤트 루프 설명\\n\\n노드가 시작될때, 이벤트루프가 초기화되고, 프로세스 들은 input script 로 비동기   \\n \\n\",\"aiSummary\":\"이벤트 루프는 Node.js의 논블로킹 I/O 기능을 지원하며, 자바스크립트의 싱글 스레드 구조 내에서 비동기 및 동기 작업을 관리하는 시스템이다. 최신 커널은 멀티 스레드를 지원하여 완료된 작업을 콜백으로 반환하고 Poll 큐에 등록하여 균등하게 실행한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.288Z\"},{\"slug\":\"diary\",\"title\":\"다이어리\",\"tags\":[\"기록\",\"2022\",\"2023\",\"문서\",\"목차\"],\"date\":\"2022-03-20 19:48:04 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n## Documents\\n[[2022]]{2022 기록}\\n[[2023]]{2023 기록}\\n\\n\",\"aiSummary\":\"이 문서는 2022년과 2023년도에 관련된 기록을 포함하는 목차를 제시하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.272Z\"},{\"slug\":\"deque\",\"title\":\"데크(deque)\",\"tags\":[\"데크\",\"문제풀이\",\"파이썬\",\"알고리즘\",\"LeetCode\"],\"date\":\"2022-03-20 22:47:24 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 데크(deque)\\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 데크(deque)의 기본 개념과 문제 해결 방법에 대한 내용을 다루며, 관련된 교재 내용 및 leetcode 솔루션을 포함하고 있습니다. 또한, 풀면서 잘 몰랐던 부분과 파이썬 문법에 대한 이슈도 정리되어 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.271Z\"},{\"slug\":\"deque-mothod\",\"title\":\"디큐 메소드 deque method\",\"tags\":[\"Python\",\"deque\",\"자료구조\",\"collections\",\"내장함수\"],\"date\":\"2022-03-28 07:06:34 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# Deque method\\n\u003e 파이썬 안에 있는 내장함수로 직접 구현하는것보다 빠르고 쉽게 사용할 수 있다\\n\\n## import\\n\\n```python\\nfrom collections import deque\\ndeque()\\n\\n```\\n\\n\\n## \\n\\n\\n\\n\\n## ref\\n* [site linke](https://realpython.com/linked-lists-python/)\\n\",\"aiSummary\":\"이 문서는 파이썬의 deque 메서드를 소개하며, 이를 사용하면 내장 함수보다 더 빠르고 쉽게 자료 구조를 구현할 수 있음을 설명합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.271Z\"},{\"slug\":\"LazyloadingEagerLoading\",\"title\":\"레이지 로딩과 이거 로딩\",\"tags\":[\"목차\",\"문서\",\"구성\",\"설명\",\"정보\"],\"date\":\"2022-04-24 20:03:08 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# ㅇ \\n\",\"aiSummary\":\"문서의 목차가 제공되며, 현재 내용은 'ㅇ'로 시작하는 항목에 대한 설명으로 보입니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.259Z\"},{\"slug\":\"leetcode\",\"title\":\"리트코드(Leetcode)\",\"tags\":[\"알고리즘\",\"문자열\",\"팰린드롬\",\"로그파일\",\"애너그램\"],\"date\":\"2022-03-20 19:48:04 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n## questions\\n\\n### chapter 6\\n\\n* [[valid-palindrome]]{유효한 팰린드롬}\\n* [[reverse-string]]{문자열 뒤집기}\\n* [[reorder-log-files]]{로그파일 재정렬}\\n* [[most-common-word]]{가장 흔한 단어}\\n* [[group-anagram]]{그룹 애너그램}\\n\\n\\n\\n* [[palindrome-linked-list]]{팔린드롬-링크드리스트}\\n\",\"aiSummary\":\"이 문서는 여러 알고리즘 문제들을 다루고 있으며, 특히 문자열, 팰린드롬, 로그파일 재정렬, 단어 빈도, 애너그램 그룹화와 같은 주제를 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.282Z\"},{\"slug\":\"shellCommend\",\"title\":\"맨날 잊어버리는 쉘명령어 모음\",\"tags\":[\"명령어\",\"파일복사\",\"scp\",\"파일찾기\",\"Linux\"],\"date\":\"2022-05-01 14:37:32 +0900\",\"content\":\"* TOC\\n{:toc}\\n \\n# 자주 잊어버리는 명령어 모음\\n## local에서 서버로 복사 붙여넣기\\n - scp -P portnumber 복사될path 붙여넣기할path\\n```bash\\n# scp -P 1600 myserveripaddress ~/dev/hello /usr/share/nginx/html\\n```\\n\\n## 파일찾기 \\n    - find name \\n\\n\\n\",\"aiSummary\":\"이 문서에서는 자주 잊어버리는 명령어들을 정리하고 있으며, 서버 간 파일 복사 및 파일 찾기 방법을 설명하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.295Z\"},{\"slug\":\"array\",\"title\":\"문자열조작 및 배열\",\"tags\":[\"배열\",\"문제풀이\",\"파이썬\",\"알고리즘\",\"추상 자료형\"],\"date\":\"2022-03-20 20:30:14 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 배열(Array)\\n## 기본개념 \\n\\n * 공간 기간의 연속 방식 vs 포인터 기반의 연결 방식 \\n * \\n    \\n## 문제풀이  \\n* 그룹 애너그램 \\n* 가장 긴 팰린드롬 부분 문자열\\n* 세 수의 합[]\\n* 배열 파티션\\n{:style=\\\"background-color: #ecf1e8;\\\"}\\n\\n\\n\\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n* [[enumerate]]\\n* set\\n* [[lst]]\\n\\n## 잘모르는 용어\\n* 추상 자료형 (Abstract Data Type ADT)\\n\",\"aiSummary\":\"이 문서는 배열(Array)의 기본 개념과 관련된 문제풀이를 다루고 있으며, leetcode 해결 방법과 파이썬 문법, 잘 모르는 용어들에 대한 정보도 포함되어 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.264Z\"},{\"slug\":\"miniproject\",\"title\":\"미니프로젝트\",\"tags\":[\"미니프로젝트\",\"Python\",\"Flask\",\"협업\",\"API\"],\"date\":\"2022-03-21 08:55:16 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 미니프로젝트\\n* 첫번째 프로젝트로 굉장히 민망하다.\\n\\n나도 너무나 부족했고 다른분들도 굉장히 힘들었던 프로젝트로 생각했다.\\n사용했던 스택은 Python, Flask, 그리고 API였다.\\n가장 힘들었던건 아무것도 모르고 시작하는 Python 사용법이다. 일단 마지막에는 조금 어떻게 돌아가는지 내용을 알았으나 프로젝트를 끝내지 못했다.\\n\\n프론트 두분께서 분발하셨지만 완성되기는 힘들어 보였다. 우선 나부터도 협업이라는 것을 처음해서 각자 만든걸 복붙 하고 그랬다.... GIT은 뭐 때문에 사용한것인가...  \\n\\n굉장히 실패했다고 생각했지만 Python으로 프론트 + 백까지 만들 수 있어서 굉장히 유용했었던거 같다.\\n\\n\\n부끄럽지만 링크는 걸어야겠다.\\n[링크](https://github.com/taeheeee/cocktail)\\n\\n\\n\",\"aiSummary\":\"미니프로젝트에서의 경험을 회고하며, Python과 Flask를 사용하여 API를 구현했지만 협업과 기술 부족으로 인해 완성도가 낮았음을 느꼈다. 프로젝트 종료 후 얻은 기술적 유익은 있었으나, 실패를 경험한 것으로 생각하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.285Z\"},{\"slug\":\"visitedlength\",\"title\":\"방문 길이 49994번\",\"tags\":[\"문제풀이\",\"Python\",\"알고리즘\",\"2차원 배열\",\"SET\"],\"date\":\"2022-03-24 21:22:52 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 문제풀이 \\n\u003e2022-03-24 21:37:09 풀었던 문제이다.\\n* 올바른 방향으로 진행은 했다.\\n* 결과값을 카운팅하는 부분에서 막혔다.\\n* 처음에는 2차원 배열로 같은 방향으로 진행되는 부분을 없애려고 했으나 SET사용이 어려웠다.\\n* 일반 배열의 SET은 그냥 사용하면 되었는데 2차원 배열의 SET은 좀 어려웠다\\n* 해결방법은 문자열로 4자리 수로 변경 앞에 2자리는 기존 좌표 나머지 좌표는 다음 좌표\\n* 예제) 5554 -\u003e (5,5) 에서 (5,4) 로 Y축 -1 만큼 이동\\n* [5554, 5444, ...]  이것을 SET으로 돌리면 같은 값은 없어진다. \\n* 그런데 간과 한게 양방향으로 같을 경우를 생각을 못했다....\\n\\n## 문제풀이 \\n\u003e 기존에 갔던 길은 카운터를 안하는게 중요한 문제이다\\n\\n\\n```python\\n\\ndef solution(dirs):\\n    #좌표값을 설정한다 위 아래 좌우로 이동시 X축과 Y축을 정의한다\\n    moving = {\\n        \\\"L\\\" : (-1, 0), #왼쪽으로 한 칸 가기\\n        \\\"R\\\" : (1, 0,   #오른쪽으로 한 칸 가기\\n        \\\"U\\\" : (0, 1),  #위로 한칸 가기\\n        \\\"D\\\" : (0, -1), #아래로 한칸 가기\\n    }\\n    \\n    \\n    group = [] \\n    cnt = 1 \\n    x, y = 5, 5\\n    a, b = 0, 0\\n    \\n    for i in dirs:\\n        x += moving[i][0]\\n        x += moving[i][1]\\n        \\n        \\n        \\n\\n\\n\\n\\n```\\n\\n* 조건\\n\\n* 이동한 경로를 몇번째에 이동했는지 ㅎ\\n\\n\\n##\\n\\n\\n## 문제링크\\n* [방문길이](https://programmers.co.kr/learn/courses/30/lessons/49994)\\n\",\"aiSummary\":\"이 문서는 특정 문제를 풀기 위한 접근 방법을 설명하고 있으며, 2차원 배열과 SET을 사용하여 중복 이동을 처리하는 방법을 다루고 있다. 주요 포인트는 양방향 이동을 고려하는 것과 이동 경로의 카운터 기능의 중요성이다.\",\"lastProcessed\":\"2024-11-05T13:09:30.302Z\"},{\"slug\":\"bubble-sort\",\"title\":\"버블정렬\",\"tags\":[\"문제풀이\",\"LeetCode\",\"파이썬\",\"개념정리\",\"코딩\"],\"date\":\"2022-03-21 08:18:31 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 기본 개념 및 문제 해결 방법에 대한 내용과 함께 관련된 교재 내용과 LeetCode 솔루션을 다루고 있습니다. 또한 문제 해결 과정에서 어려웠던 부분과 파이썬 문법에 대한 이해를 돕는 내용을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.267Z\"},{\"slug\":\"merge_sort\",\"title\":\"병합정렬\",\"tags\":[\"문제풀이\",\"LeetCode\",\"파이썬\",\"개념정리\",\"코딩\"],\"date\":\"2022-03-21 08:29:09 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 기본 개념 및 문제 해결 방법에 대한 내용과 함께 관련된 교재 내용과 LeetCode 솔루션을 다루고 있습니다. 또한 문제 해결 과정에서 어려웠던 부분과 파이썬 문법에 대한 이해를 돕는 내용을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.284Z\"},{\"slug\":\"callback-function\",\"title\":\"비동기 처리, 콜백 이해,\",\"tags\":[\"JavaScript\",\"Asynchronous\",\"Callbacks\",\"Synchronous\",\"Programming\"],\"date\":\"2022-04-06 14:42:06 +0900\",\"content\":\"$23\",\"aiSummary\":\"This document provides an overview of JavaScript's synchronous and asynchronous behavior, highlighting callback functions and demonstrating callback hell through a user authentication example using a class for user storage.\",\"lastProcessed\":\"2024-11-05T13:09:30.267Z\"},{\"slug\":\"inheritance-python\",\"title\":\"상속 inheritance\",\"tags\":[\"상속\",\"코딩문제\",\"파이썬\",\"팀협업\",\"메서드공유\"],\"date\":\"2022-03-27 17:41:32 +0900\",\"content\":\"$24\",\"aiSummary\":\"이 문서는 팀원들과의 협업 코딩 중에 발생한 상속 문제와 변수 공유 문제에 대한 내용을 다루고 있습니다. 헬퍼 메서드들을 서로 공유하기 위해 클래스를 상속하려 했지만, 변수 공유의 문제로 인해 작동하지 않는 상황에 대해 설명하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.279Z\"},{\"slug\":\"gitCommitCopyToNewRepo\",\"title\":\"새로운 레포에 기존 커밋 옮기기\",\"tags\":[\"AWS\",\"CodeCommit\",\"GitHub\",\"소스코드보안\",\"레포이주\"],\"date\":\"2022-09-05 15:11:00 +0900\",\"content\":\"$25\",\"aiSummary\":\"이 문서는 AWS로 레포를 이주하는 이유와 방법에 대해 설명하며, AWS CodeCommit의 가격 정보 및 GitHub에서 CodeCommit으로의 이주 과정에 대한 내용을 포함하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.274Z\"},{\"slug\":\"stack\",\"title\":\"스택\",\"tags\":[\"스택\",\"데이터구조\",\"파이썬\",\"연결리스트\",\"큐\"],\"date\":\"2022-03-20 20:42:34 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 스택\\n## 기본개념 \\n\u003e먼저들어오는게 마지막에 나간다...\\n\\n1. 스택으 기본적으로 두가지형태로 구현할 수 있다.\\n    * [[linked-list]] 로 구현가능\\n    * queue 로 구현가능\\n\\n## method \\n\\n``` python\\n# 노드 객체를 생성하고 \\nclass Node:\\n    def __init__(self, value):\\n        self.value = value \\n        self.next =  None \\n\\nclass Stack:\\n    def __init__(self,value)\\n        self.head = None\\n        \\n    def push(self, value):\\n        if self.head is not None:\\n            self.head = Node(value)\\n        else :\\n            temp = Node(value)\\n            self.head = self.head.next \\n            temp.next = temp\\n        \\n    def pop(self):\\n        if self.head is not None:\\n            return 0\\n            \\n        self.head = self.head.next\\n        \\n```\\n\\n\",\"aiSummary\":\"이 문서는 스택의 기본 개념과 구현 방법을 설명하며, 스택을 연결리스트 및 큐로 구현하는 방법을 예시 코드와 함께 제공한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.297Z\"},{\"slug\":\"lastComment\",\"title\":\"스파르타 항해99 취직후 후기\",\"tags\":[\"개발자\",\"부트캠프\",\"독학\",\"취업\",\"경험담\"],\"date\":\"2022-10-10 18:21:42 +0900\",\"content\":\"$26\",\"aiSummary\":\"이 문서는 개인이 개발자로 재취직 결심을 하게 된 경과와 항해99 부트캠프 수료 후의 경험을 담고 있다. 독학의 어려움과 좌절을 겪고 부트캠프의 장단점을 소개하며, 최종적으로 개발자로의 첫걸음에 대한 성취감을 느낀 과정을 기록하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.281Z\"},{\"slug\":\"algorithm\",\"title\":\"알고리즘\",\"tags\":[\"데이터 구조\",\"알고리즘\",\"문제 해결\",\"정렬\",\"프로그래밍 문제\"],\"date\":\"2022-03-20 19:48:04 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# How to solve problem?\\n## 5 ways step-by-step\\n* Search - 데이터 구조 안에서 아이템을 찾는 알고리즘이다\\n* Sort - 올바른 순서로 정렬를 하는 알고리즘이다\\n* insert - 데이터 구조 에서 아이템을 추가 하는 알고리즘이다\\n* Update - 데이터 구조에서 존제하는 아이템을 수정하는 알고리즘이다\\n* Delete - 데이터 구조에서 존자하는 아이템을 삭제하는 알고리즘이다\\n\\n## 선형구조 \\n* [[array]]{문자열조작/배열(0%)}\\n* [[linked-list]]{연결리스트}\\n* [[stack]]{스택(0%)}\\n* [[queue]]{큐(0%)}\\n* [[deque]]{데크(0%)}\\n* [[priority-queue]]{우선순위큐(0%)}\\n* [[hash-table]]{해시테이블}\\n\\n## 비선형 구조 \\n* [[graph]]{그래프}\\n* [[short-way]]{최단경로문제}\\n* [[dfs]]{DFS(깊이 우선 탐색)}\\n* [[tree]]{트리}\\n* [[heap]]{힙}\\n* [[try]]{트라이}\\n\\n## 알고리즘\\n* [[bubble-sort]]{버블정렬}\\n* [[merge_sort]]{병합정렬}\\n* [[quicksort]]{퀵정렬}\\n* 안정정렬-vs- 불안정정렬\\n* [[binary-search]]{이진검색}\\n* 비트조작\\n* 슬라이딩윈도우\\n* 그리디알고리즘\\n* 분할정복\\n* 다이나믹프로그래밍\\n\\n## [[leetcode]]{리트코드}\\n* [[palindrome-linked-list]]{팰린드롬-링크드리스트}\\n\\n\\n## [[programmers]]{프로그래머스}\\n* [[visitedlength]]{방문길이}\\n* [[targetNumber]]{타겟넘버}\\n\\n## Documents\\n\",\"aiSummary\":\"이 문서는 데이터 구조와 알고리즘의 다양한 방법론을 설명한다. 문제 해결을 위한 5가지 단계와 선형 및 비선형 데이터 구조, 주요 정렬 알고리즘, 그리고 몇 가지 유명한 프로그래밍 플랫폼인 LeetCode와 Programmers의 문제를 다룬다.\",\"lastProcessed\":\"2024-11-05T13:09:30.263Z\"},{\"slug\":\"linked-list\",\"title\":\"연결리스트\",\"tags\":[\"연결리스트\",\"파이썬\",\"자료구조\",\"스택\",\"큐\"],\"date\":\"2022-03-20 20:31:47 +0900\",\"content\":\"$27\",\"aiSummary\":\"이 문서는 연결리스트(linked list)의 기본 개념, 구현 예시, 스택과 큐의 차이점에 대해 설명하고 있으며, 파이썬에서 연결리스트와 큐의 기본 클래스 구현 방법을 제시한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.283Z\"},{\"slug\":\"what-is-object\",\"title\":\"오브젝트란?\",\"tags\":[\"JavaScript\",\"객체\",\"프로그래밍\",\"개념\",\"리터럴\"],\"date\":\"2022-04-05 12:07:19 +0900\",\"content\":\"$28\",\"aiSummary\":\"이 문서는 JavaScript의 객체(Object)에 대한 개념, 리터럴 및 프로퍼티, 계산된 프로퍼티, 프로퍼티 값 약식, 생성자 함수, 존재성 검사, 순환 방법, 복사 방법 등을 설명하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.302Z\"},{\"slug\":\"priority-queue\",\"title\":\"우선순위큐\",\"tags\":[\"우선순위큐\",\"문제풀이\",\"파이썬\",\"LeetCode\",\"알고리즘\"],\"date\":\"2022-03-20 22:50:27 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n\\n# 우선순위큐  \\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 우선순위큐의 기본 개념과 관련 문제 해결 방법에 대한 내용을 다루고 있으며, 특정 교재와 LeetCode 솔루션을 통해 문제를 푸는 과정 중 발생한 의문점들과 파이썬 문법에 대한 설명도 포함되어 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.290Z\"},{\"slug\":\"link-list\",\"title\":\"유용한 사이트 모음\",\"tags\":[\"디자인 패턴\",\"취업\",\"포트폴리오\",\"개발자\",\"자원\"],\"date\":\"2022-04-04 11:32:20 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 디자인 패턴\\n\\n* [design-pattern](https://refactoring.guru/design-patterns/history)\\n\\n\\n# 취업시 유용한 사이트\\n* [포트폴리오 10팁](https://velog.io/@chris/10-web-developer-portfolio-tips)\\n\",\"aiSummary\":\"이 문서는 디자인 패턴과 관련된 자료 및 취업에 유용한 사이트 정보를 제공합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.282Z\"},{\"slug\":\"interview50q\",\"title\":\"인터뷰 예약 50문제\",\"tags\":[\"면접준비\",\"JavaScript\",\"Node.js\",\"API\",\"비동기처리\"],\"date\":\"2022-06-09 23:37:55 +0900\",\"content\":\"$29\",\"aiSummary\":\"이 문서는 소프트웨어 개발 면접을 대비하기 위한 50개의 예상 질문과 답변 내용을 포함하고 있습니다. 질문들은 JavaScript의 변수 선언, event loop, Node.js의 특징, 비동기 처리, 웹 서버의 역할, 보안 및 API 관련 주제를 다룹니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.279Z\"},{\"slug\":\"howtoworksasync\",\"title\":\"자바스립트에서 어떻게 비동기가 작동될까?\",\"tags\":[\"JavaScript\",\"Event Loop\",\"Asynchronous\",\"Web API\",\"Task Queue\"],\"date\":\"2022-06-11 16:57:20 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# EventLoop\\n## \\n자바스크립트는 싱글쓰레드 언어이다.\\n\\n그러나 실제로는 비동기로 처리가 가능하다. \\n왜 그럴까?\\n\\n브라우져에서 지원하는 기능때문에 가능하다. \\n브라우져에서는 Web API와 callback queue라는게 있는데 이 두개를 가지고 필요한 비동기 작업을수행한다.\\n\\n\\n\\n### 간단 요약\\n1. WEB API : DOM(Document) AJAX(XMLHttpRequest) Timeout(setTimeout) 내장되어 있다.\\n2. Task Queue(Callback Queue) : Web API에서 비동기 작업이 완료된 후 호출된 콜백 함수들이 대기하는 공간 \\n3. Event Loop : 콜 스택과 태스크 큐를 수시로 확인하며 콜  스택이 비었을경우 태스크 큐에 있는 작업들을 콜 스택으로 넘겨준다.\\n\\n\\nTask Queue \\n    1) Microtask Queue\\n             ![image](https://user-images.githubusercontent.com/56494905/159731726-9ef04fce-62c0-4a72-bee9-fef8e382f7cb.png){:width=\\\"80%\\\", align=\\\"center\\\"}\\n\\n\\n    2) Macrotask Queue :  setTimeout() setInterval(0 setImmediate() 같은 task를 넘겨받는다. \\n       \\n\\n\\n\\n\\n\",\"aiSummary\":\"자바스크립트는 비동기 처리를 가능하게 하는 Event Loop, Web API, Task Queue에 대해 설명하며, 비동기 작업의 흐름을 이해하는 데 중요한 요소들을 다룬다.\",\"lastProcessed\":\"2024-11-05T13:09:30.277Z\"},{\"slug\":\"short-way\",\"title\":\"최단경로문제\",\"tags\":[\"문제풀이\",\"LeetCode\",\"파이썬\",\"개념정리\",\"코딩\"],\"date\":\"2022-03-21 00:59:45 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 기본 개념 및 문제 해결 방법에 대한 내용과 함께 관련된 교재 내용과 LeetCode 솔루션을 다루고 있습니다. 또한 문제 해결 과정에서 어려웠던 부분과 파이썬 문법에 대한 이해를 돕는 내용을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.296Z\"},{\"slug\":\"program\",\"title\":\"추천프로그램\",\"tags\":[\"맥\",\"프로그램\",\"유틸리티\",\"추천\",\"소프트웨어\"],\"date\":\"2022-03-23 15:48:36 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n\\n# 맥에서 유용한 추천 프로그램 리스트 \\n* Alfrad\\n* textExpenderc\\n* rocket \\n* keycaster\\n* iterm2 \\n* macvim \\n\\n# Documents\\n\",\"aiSummary\":\"이 문서는 맥 사용자에게 유용한 추천 프로그램 목록을 제공합니다. 프로그램에는 Alfrad, textExpander, rocket, keycaster, iterm2, macvim이 포함됩니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.290Z\"},{\"slug\":\"job-opportuinity\",\"title\":\"취업시 유용한 사이트\",\"tags\":[\"취업\",\"웹 개발\",\"포트폴리오\",\"자료 모음\",\"팁\"],\"date\":\"2022-03-25 07:00:36 +0900\",\"content\":\"* TOC\\n{:toc}\\n# 취업시 요용한 사이트 모음\\n\\n## Link\\n* [웹 개발자 포트폴리오를 위한 10가지 팁](https://velog.io/@chris/10-web-developer-portfolio-tips) \\n\",\"aiSummary\":\"이 문서는 취업을 준비하는 이들을 위한 유용한 웹사이트와 자료를 모아둔 목록이다. 특히 웹 개발자를 위한 포트폴리오 작성에 대한 유용한 팁을 포함하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.280Z\"},{\"slug\":\"queue\",\"title\":\"큐(queue)\",\"tags\":[\"큐\",\"문제풀이\",\"파이썬\",\"자료구조\",\"알고리즘\"],\"date\":\"2022-03-20 20:54:02 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 큐(queue)\\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 큐(queue)에 대한 기본 개념과 문제 해결 방법을 다루며, 교재 내용 및 LeetCode 솔루션을 포함하고 있습니다. 또한, 문제를 풀이하면서 어려웠던 부분과 파이썬 문법에 대한 질문도 기록되어 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.292Z\"},{\"slug\":\"targetNumber\",\"title\":\"타겟넘버\",\"tags\":[\"타겟넘버\",\"문제풀이\",\"프로그래밍\",\"알고리즘\",\"개선사항\"],\"date\":\"2022-03-25 06:34:51 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 타겟넘버(43165 문제) \\n\u003e\\n\\n* 노트에는 어떻게 돌어가는지에 대해서 구현은 완료되었다.\\n* 하지만 직접 구현하기에 시간내로는 실패했다.\\n* ㅓ \\n\\n\\n## Link\\n* [링크](https://programmers.co.kr/learn/courses/30/lessons/43165)\\n\",\"aiSummary\":\"타겟넘버(43165 문제)에 대한 노트가 있으며, 구현은 완료되었지만 시간 내에 직접 구현하는 데 실패했다.\",\"lastProcessed\":\"2024-11-05T13:09:30.298Z\"},{\"slug\":\"try\",\"title\":\"트라이\",\"tags\":[\"문제풀이\",\"LeetCode\",\"파이썬\",\"개념정리\",\"코딩\"],\"date\":\"2022-03-21 00:59:25 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# \\n## 기본개념 \\n\\n## 문제풀이  \\n### 교재 내용\\n\\n### leetcode solution\\n\\n## 풀면서 잘 몰랐던 부분 \\n\\n## 파이썬문법 모르는 부분 \\n\\n\",\"aiSummary\":\"이 문서는 기본 개념 및 문제 해결 방법에 대한 내용과 함께 관련된 교재 내용과 LeetCode 솔루션을 다루고 있습니다. 또한 문제 해결 과정에서 어려웠던 부분과 파이썬 문법에 대한 이해를 돕는 내용을 포함하고 있습니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.299Z\"},{\"slug\":\"tree\",\"title\":\"트리\",\"tags\":[\"트리\",\"이진트리\",\"데이터구조\",\"문제풀이\",\"용어정리\"],\"date\":\"2022-03-21 00:59:33 +0900\",\"content\":\"$2a\",\"aiSummary\":\"이 문서는 트리 구조의 기본 개념에 대한 요약, 다양한 유형의 이진 트리 설명, 그리고 관련 문제 풀이를 포함하고 있다. 주요 용어와 개념에 대한 정의도 제공된다.\",\"lastProcessed\":\"2024-11-05T13:09:30.299Z\"},{\"slug\":\"python\",\"title\":\"파이썬(python)\",\"tags\":[\"outline\",\"framework\",\"structure\",\"placeholder\",\"documentation\"],\"date\":\"2022-03-23 14:50:36 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# documnets \\n\\n\\n\",\"aiSummary\":\"The document appears to be a placeholder or outline without specific content, potentially indicating the structure or framework for a larger document.\",\"lastProcessed\":\"2024-11-05T13:09:30.292Z\"},{\"slug\":\"programmers\",\"title\":\"프로그래머스\",\"tags\":[\"문제풀이\",\"방문길이\",\"타겟넘버\",\"알고리즘\",\"데이터구조\"],\"date\":\"2022-03-24 21:19:31 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 문제풀이 \\n\\n* [[visitedlength]]{방문길이}\\n* [[targetNumber]]{타겟넘버}\\n\\n\",\"aiSummary\":\"이 문서는 문제풀이와 관련된 두 가지 주제인 방문길이와 타겟넘버에 대한 내용을 다루고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.291Z\"},{\"slug\":\"literals\",\"title\":\"함수 리터럴이란 무엇인가?\",\"tags\":[\"자바스크립트\",\"함수 리터럴\",\"프로그래밍\",\"개념\",\"MDN\"],\"date\":\"2022-04-13 11:14:51 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n# 함수 리터럴(function literals)\\n* 자꾸 함수 리터럴이 나오는데 자꾸 뭔지 찾아보게 된다 \\n\u003eliterals 사전적인 의미 : 정확한....  융통성 없는, 문자 그대로 정확한, 문자의, 문자사아의  \\n\\n* MDN에서는 이렇게 나타낸다\\n\u003eLiterals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script.\\n\\n    - Array literals\\n    - Boolean literals\\n    - Floating-point literals\\n    - Numberic literals\\n    - Object literals\\n    - RegExp literals\\n    - String literals\\n\\n\\n## 뭔지 생각해보자\\n* 함수의 문자그대로?\\n* 아직도 감이 안온다 코드를 보면서 생각해보자\\n\\n```javascript\\n\\n// 일반적인 함수와 같지만 함수명을 사용하지 않고 상태만 나타내는 부분이 특징이다\\n\\nconst what = function(){\\nconsole.log(\\\"hello world\\\")\\n}\\n```\\n\\n* 자바스크립의 모든 리터럴 값은 객체로 되어 있다\\n* 따라서 객체를 개체로 담는것도 가능하다\\n* 즉 변수선언도 함수 선언도 각각 하고 나서 함수를 변수에 넣는것도 가능하다\\n\\n* 단 몇가지 요소로 구성되어 있으며 조건이 몇개 있다\\n* 함수를 정의 하고 변수에 담는데 함수 이름은 없이 저장한다\\n    - 예약어 function (필수ㅔ)\\n\\n\\n\\n## 참고사이트\\n\\n\\n\\n\\n## 함수 리터럴이란?\\n\",\"aiSummary\":\"함수 리터럴은 자바스크립트에서 함수명을 사용하지 않고 함수의 상태를 나타내는 방식으로, 변수를 통해 함수를 담을 수 있는 개념이다. 이 글에서는 리터럴의 정의와 자바스크립트에서의 활용에 대해 설명한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.283Z\"},{\"slug\":\"sparta\",\"title\":\"항해99\",\"tags\":[\"부트캠프\",\"프로그래밍\",\"알고리즘\",\"면접준비\",\"프로젝트\"],\"date\":\"2022-03-20 19:48:04 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n\\n# 스파르타 부트캠프\\n\u003e 99일동안 하루에 기본 10시간 이상 월요일부터 토요일까지 협업하면서 진행하는 BOOTCAMP\\n `일반반`과 `심화반`으로 나누어져 있으며 일반반은 협업위주 실전프로젝트 + 주특기 개발 \\n 반면 심화반은 알고리즘 4주와 주특기 실전프로젝트 가 조금다르다 \\n 마지막주에는 면접 준비 및 이력서 리뷰를 같이 해준다고한다\\n\\n\\n## [[miniproject]]{미니프로젝트}\\n첫주에 첫 팀원과 아무것도 모르는 상태에서 Jinja2 , flask, mongodb, aws 를 이용한 미니 프로젝트\\n\\n## [[homework]]{과제톡(알고리즘)}\\n알고리즘을 풀고 매일 발표자 한명씩 발표\\n\\n## [[cs-homework]]{항해톡(웹일반지식)}\\nCODE라는 책을 읽고 매일 발표 준비\\n\\n## [[cs-study]]{CS스터디(기초CS)}\\n일반 웹지식으로 면접시 단골 질문\\n\\n## [[interview50q]]{인터뷰50Q}\\n인터뷰50문제 \\n\\n## [[lastComment]]{취직후 마지막 후기} \\n취직후 마지막 결제를 하고 다시 회고 하며 적어본다.\\n\\n## [[lastCommentPlus]]{항해플러스후기}\\n항해 플러스 후기\\n\",\"aiSummary\":\"스파르타 부트캠프는 99일 동안 협업하여 실전 프로젝트와 알고리즘 스터디를 진행하는 프로그램으로, 일반반과 심화반으로 나뉘며 마지막 주에는 면접 준비와 이력서 리뷰를 제공합니다.\",\"lastProcessed\":\"2024-11-05T13:09:30.296Z\"},{\"slug\":\"lastCommentPlus\",\"title\":\"항해99 항해 플러스 후기\",\"tags\":[\"부트캠프\",\"주니어 개발자\",\"TDD\",\"CI/CD\",\"네트워킹\"],\"date\":\"2023-08-22 19:00:51 +0900\",\"content\":\"$2b\",\"aiSummary\":\"항해 플러스는 주니어 개발자들이 사이드 프로젝트를 통해 다양한 기술 경험을 쌓도록 지원하는 부트캠프이다. 참여자는 팀 프로젝트와 멘토링, 네트워킹을 통해 실제 가치 있는 경험을 얻으며, TDD 및 CI/CD 등의 기술을 배울 수 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.281Z\"},{\"slug\":\"cs-homework\",\"title\":\"항해톡\",\"tags\":[\"JWT\",\"REST API\",\"HTTPS\",\"OSI 7 layers\",\"CORS\"],\"date\":\"2022-03-20 20:28:30 +0900\",\"content\":\"* TOC\\n{:toc}\\n\\n## 작성완료\\n * [[JWT]]\\n\\n\\n## 작성해야함\\n* [[REST-API]]\\n* HTTPS-VS-HTTP\\n* Cookie-vs-Session-vs-Cache\\n* [[OSI-7-layers]]\\n* Process-Thread\\n* Sync-Async\\n* DB-Index\\n* DNS\\n* [[DOM]]\\n* How-to-work-browser\\n* CORS\\n* JPA\\n* [[https-ssl]]{https-ssl(50%)}\\n* Middleware\\n\\n## Documents\\n\",\"aiSummary\":\"이 문서는 JWT에 대한 작성 완료 목록과 함께 REST API, HTTPS와 HTTP, 쿠키, 세션, 캐시, OSI 7계층, 프로세스와 스레드, 동기 및 비동기, DB 인덱스, DNS, DOM, 브라우저 작동 방식, CORS, JPA, HTTPS/SSL, 미들웨어 등과 같은 기술 문서 작성을 위해 예정된 항목들을 나열하고 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.270Z\"},{\"slug\":\"plus\",\"title\":\"항해플러스\",\"tags\":[\"항해플러스\",\"TDD\",\"CI/CD\",\"개발자 경험\",\"팀워크\"],\"date\":\"2023-05-28 09:20:10 +0900\",\"content\":\"$2c\",\"aiSummary\":\"이 문서는 항해플러스 1기에 참가한 경험에 대한 후기를 다루고 있으며, TDD, 대용량 처리 및 CI/CD와 같은 개발 과정에서의 배움과 팀워크의 중요성, 그리고 자아를 찾는 여정에 대해 이야기한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.289Z\"},{\"slug\":\"hash-table\",\"title\":\"해시테이블\",\"tags\":[\"해시테이블\",\"해시함수\",\"충돌해결\",\"로드팩터\",\"파이썬\"],\"date\":\"2022-03-20 20:54:17 +0900\",\"content\":\"$2d\",\"aiSummary\":\"해시 테이블은 키 값으로 데이터를 저장하고 조회하는 구조로, 해시 함수와 로드 팩터 개념을 바탕으로 성능 최적화를 도모한다. 충돌 해결 방식으로는 개별 체이닝과 오픈 어드레싱이 있으며, 파이썬의 딕셔너리 구현을 예로 들어 설명한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.276Z\"},{\"slug\":\"gitreset\",\"title\":\"환경변수가 git에 올라갔을때\",\"tags\":[\"git\",\"ENV파일\",\"버전 관리\",\"CLI\",\"gitLens\"],\"date\":\"2022-06-13 00:20:11 +0900\",\"content\":\"$2e\",\"aiSummary\":\"팀원이 ENV파일을 레포에 업데이트한 상황에서 이를 되돌리는 방법에 대해 설명한다. CLI와 gitLens라는 두 가지 방법을 통해 이전 상태로 복구하는 절차를 안내한다.\",\"lastProcessed\":\"2024-11-05T13:09:30.275Z\"},{\"slug\":\"heap\",\"title\":\"힙\",\"tags\":[\"완전 이진 트리\",\"Heap\",\"파이썬\",\"자료구조\",\"최대 최소값\"],\"date\":\"2022-03-21 00:59:31 +0900\",\"content\":\"$2f\",\"aiSummary\":\"이 문서는 완전 이진 트리(Heap)의 기본 개념과 특징, 파이썬에서의 구현 방법을 소개하며, 최대값과 최소값을 신속하게 찾는 데 유용한 자료구조에 대한 설명이 포함되어 있다.\",\"lastProcessed\":\"2024-11-05T13:09:30.277Z\"}]}],null,[\"$\",\"$L30\",null,{\"children\":\"$L31\"}]]}],{},null]},null]},null],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"bisnJms-Bps05PZQAyS3c\",{\"children\":[[\"$\",\"$L32\",null,{\"children\":\"$L33\"}],[\"$\",\"$L34\",null,{\"children\":\"$L35\"}],null]}]]}]]],\"m\":\"$undefined\",\"G\":[\"$36\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"35:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n33:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Your Blog Title\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Your blog description\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"31:null\n"])</script></body></html>